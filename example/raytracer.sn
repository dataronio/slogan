record vec3 (x = 0.0, y = 0.0, z = 0.0);

var vec3_normalize = function (self)
    let nor2 = vec3_length2 (self)
    if nor2 > 0 vec3_mult_f (self, 1 / sqrt (nor2));

var vec3_mult_f = function (self, f)
    vec3 (x = vec3_x (self) * f,
          y = vec3_y (self) * f,
          z = vec3_z (self) * f);

var vec3_arith = function (self, v, fn)
    vec3 (x = fn (vec3_x (self), vec3_x (v)),
          y = fn (vec3_y (self), vec3_y (v)),
          z = fn (vec3_z (self), vec3_z (v)));

var vec3_mult = function (self, v) vec3_arith (self, v, mult);
var vec3_add = function (self, v) vec3_arith (self, v, add);
var vec3_sub = function (self, v) vec3_arith (self, v, sub);

var vec3_dot = function (self, v) 
    vec3_x (self) * vec3_x (v) + vec3_y (self) * vec3_y (v) + vec3_z (self) * vec3_z (v);

var vec3_neg = function (self) 
    vec3 (x = sub (vec3_x (self)), y = sub (vec3_y (self)), z = sub (vec3_z (self)));

var vec3_length2 = function (self)
    let x = vec3_x (self),
        y = vec3_y (self),
        z = vec3_z (self)
    x * x + y * y + z * z;

var vec3_length = function (self) sqrt (vec3_length2 (self));

var vec3_print = function (self, out = current_output_stream ())
    print (to = out, "[", vec3_x (self), " ", vec3_y (self), " ", vec3_z (self), "]");


var sphere = function (@key center, radius, 
                       surface_color, emission_color,
                       transparency, reflection) {
    let radius2 = radius * radius
    let does_intersect = function (rayorig, raydir)
        let vl = vec3_sub (center, rayorig)
        let tca = vec3_dot (vl, raydir)
        if tca < 0 false
        else let d2 = vec3_dot(vl, vl) - tca * tca
        if d2 > radius2 false
        else let thc = sqrt (radius2 - d2)
        [tca - thc, tca + thc]
    function (message)
        case message {
            !intersect: does_intersect
            else: error ("invalid message. ", message)
        }
};

var mix = function (a, b, m) b * m + a * (1.0 - m);

var M_PI = 3.141592653589793;
var INFINITY = +inf.0;
var MAX_RAY_DEPTH = 5;

var find_intersection_with_sphere = function (rayorig, raydir, spheres) {
    let tnear = INFINITY, s = false    
    for_each (function (sphere) {
        let i = sphere.intersect (rayorig, raydir)
        if i {
            let t0 = head (i), t1 = tail (i) {
                if t0 < 0 { t0 = t1 };
                if t0 < tnear {
                    tnear = t0;
                    s = sphere
                }
            }
        }
    }, spheres);
    [tnear, s]
};
                
var trace = function (rayorig, raydir, 
	              spheres, depth) {
    let intersections = find_intersection_with_sphere (rayorig, raydir, spheres)
    let tnear = head (intersections), sphere = tail (intersections) {
        if not (sphere) vec3 (x = 2, y = 2, z = 2)
        else let surface_color = vec3 (), phit = vec3_mult_f (vec3_add (rayorig, raydir), tnear) {
	    let nhit = vec3_normalize (vec3_sub (phit, sphere.center)), bias = 1e-4, inside = false {
	        if (raydir.dot (nhit) > 0) { nhit = vec3_neg (nhit); inside = true };
	        if ((sphere.transparency > 0 || sphere.reflection > 0) && depth < MAX_RAY_DEPTH) {
		    let facingratio = sub (vec3_dot (raydir, nhit))
		    let fresneleffect = mix (expt (1 - facingratio, 3), 1, 0.1)
                    false
                    // TODO
                }
            }
        }
    }
};
