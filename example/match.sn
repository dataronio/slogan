function m_not (b) {
    match b {
        true: false
        false: true
    }
};

println (m_not (1 == 2)); // => true
println (m_not (1 == 1)); // => false

function conjunction (a, b) {
    match [a b] {
        [true true]: true
        else: false
    }
};

println (conjunction (1 == 2, 2 == 2)); // => false
println (conjunction (1 == 1, 2 == 2)); // => true
println (conjunction (1 == 2, 2 == 1)); // => false

function fst (p) {
    match p {
        [a _]: a
    }
};

function snd (p) {
    match p {
        [_ b]: b
    }
};

println (fst ([1,2,3,4,5])); // => 1
println (snd ([1,2,3,4,5])); // => [2,3,4,5]

println(match [1, 2, 3] {
    [head tail]: { println ("head=", head, " tail=", tail) }
});

println(match [1,2,3] {
    [a,b]: [b,a]
    [a,b,c]: [c,b,a]
}); //=> [3, 2, 1]

println(match 1 {
    "hello": "ok"
    1: 1 + 2
}); // => 3

println(match "hello" {
    "hello" : "ok"
    1: 1 + 2
}); // => "ok"

println(match [1, "hello"] {
    [2, "hello"]: 1
    [1, "hi"]: 2
    [1, "hello"]: 3
}); // => 3

println(match[1, 2, 3] {
    [a, _, _] where a == 2: !no
    [a, _, _] where a == 1: !yes
}); // => yes

record person (name, age);

var a = person(name="bill", age=36);

println(match a {
    person(name="bill", age=36): "bill"
    person(name="susan"): "susan"
}); // => "bill"

record point(x, y);

var p = point(x=10, y=20);

var f = function(r) {
    match r {
	person(name, age): name
	point(x, y): x + y
    }
};
    
println(f(a)); // => "bill"
println(f(p)); // => 30

// Pascals triangle where pattern matching:

var shift_left = function (lst) {
    match lst { 
        [h t]: [h shift_left (t)] 
        else: [0] 
    }
};

var shift_right = function (lst) [0 lst];

var add_lists = function(lst1, lst2) {
    match lst1 {
        [h1 t1]: match lst2 {
            [h2 t2]: [h1 + h2 add_lists(t1, t2)]
        }
        else: []
    }
};

var pascal = function (n) {
    if n == 1 [1]
    else let p = pascal (n - 1) {
        add_lists(shift_left (p), shift_right (p))
    }
};

println (pascal (10));
// => [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
println (pascal (20));
// => [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1]

/* Some traditional list functions using patterns matching: */

function m_append (a, b) {
    match a {
        []: b
        [head tail]: [head m_append (tail, b)]
    }
};

println (m_append ([1, 2], [3, 4, 5])); // => [1, 2, 3, 4, 5]

function m_length (lst) {
    match lst {
        []: 0
        [_ tail]: 1 + m_length (tail)
    }
};

println (m_length ([1,2,3])); // => 3

// length as an iterative process:

var m_length = 
    letrec iter_len = function (lst, i) {
        match lst {
            []: i
            [_ tail]: iter_len (tail, i + 1)
        }
    }
    function (lst) iter_len (lst, 0);

println (m_length ([1,2,3])); // => 3

var m_reverse =
    letrec iter_rev = function (lst, rlst) {
        match lst {
            []: rlst
            [h t]: iter_rev (t, [h rlst])
        }
    }
    function (lst) iter_rev (lst, []);

println (m_reverse ([1,2,3,4,5])); // => [5,4,3,2,1]

// recursive list length.
function mr_length (lst) {
    match lst {
        []: 0
        [h t]: if is_list (h) mr_length (h) + mr_length (t)
        else 1 + mr_length (t)
    }
};

var x = [[1, 2], 4, [], [[5], 10]];
println (mr_length (x)); // => 5
println (mr_length ([x, x])); // => 10

// merge sort
function merge (xs, ys) {
    match [xs ys] {
        [[] ys]: ys
        [xs []]: xs
        [[x xr] [y yr]]: {
            if x < y [x merge (xr, ys)]
            else [y merge (xs, yr)]
        }
    }
};

function my_split (xs) {
    match xs {
        []: [[] []]
        [x]: [[x] []]
        [x1 [x2 xr]]: let r = my_split (xr) { 
            [[x1 head (r)] [x2 tail (r)]]
        }
    }
};

function merge_sort (xs) {
    match xs {
        []: []
        [x]: [x]
        else: let r = my_split (xs) {
            merge (merge_sort (head (r)), merge_sort (tail (r)))
        }
    }
};

println(merge_sort([1, 10, 5, 0, 2])); // => [0, 1, 2, 5, 10]

function quick_sort (lst) {
    match lst {
        []: []
        [x xs]: append (quick_sort (filter (xs, function (e) e <= x)), 
                        [x], 
                        quick_sort (filter (xs, function (e) e > x)))
    }
};

println(quick_sort([1, 10, 5, 0, 2])); // => [0, 1, 2, 5, 10]

function m_flatten (lst) {
    match lst {
        []: []
        [h t]: if is_list (h) append (m_flatten (h), m_flatten (t))
        else [h m_flatten (t)]
    }
};

println(m_flatten ([[1, 2], [[3], [4]], [], [5, [6]]])); // => [1, 2, 3, 4, 5, 6]            

function m_filter (lst, predic) {
    match lst {
        []: []
        [h t] where predic (h): [h m_filter (t, predic)]
        [_ t]: m_filter (t, predic)
    }
};

println (m_filter ([1,2,3,4,5], is_odd)); // => [1, 3, 5]
println (m_filter ([1,2,3,4,5], is_even)); // => [2, 4]

// List drop-n-elements:
function my_drop (n, xs) {
    match [n xs] {
        [n xs] where n <= 0: xs
        [_ []]: []
        [n [x xs]]: my_drop (n - 1, xs)
    }
};

println (my_drop (3, [1, 2, 3, 4, 5])); // => [4, 5]

// The splitLines sample from RWH (Real World Haskell).
function split_lines (cs) map (list_to_string, split_lines_helper (string_to_list (cs)));

function split_lines_helper (cs) {
    if cs == [] []
    else let pre_suf = split (cs, is_line_terminator) {
        [head (pre_suf) match tail (pre_suf) {
            ['\r', ['\n' rest]]: split_lines_helper (rest)
            ['\r' rest]: split_lines_helper (rest)
            ['\n' rest]: split_lines_helper (rest)
            else: []
        }]
    }
};

function is_line_terminator (c) c == '\r' || c == '\n';
        
println (split_lines ("hello world")); // => ["hello world"]
println (split_lines ("hello \nwor\rld")); // => ["hello ", "wor", "ld"]
println (split_lines ("hello \r\nworld")); // => ["hello ", "", "world"]

            
