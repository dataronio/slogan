link("21_to_28"); // for combinations

// 46. (**) Define predicates and/2, or/2, nand/2, nor/2, xor/2, impl/2
//          and equ/2 (for logical equivalence) which succeed or fail according
//          to the result of their respective operations; e.g. and(A,B) will succeed,
//          if and only if both A and B succeed.
//
//          A logical expression in two variables can then be written as in the
//          following example: and(or(A,B),nand(A,B)).
//
//          Now, write a predicate table/3 which prints the truth table of a
//          given logical expression in two variables.

function my_not(b) 
    match(b) 
        true -> false,
        false -> true;

function and_2(a b) 
    match(a:b) 
        true:true -> true,
        _:_ -> false;

function or_2(a b) 
    match(a:b) 
        false:false -> false,
        _:_ -> true;

function nor_2(a b) my_not(or_2(a b));

function nand_2(a b) my_not(and_2(a b));

function xor_2(a b) 
    match(a:b) 
        true:false -> true,
        false:true -> true,
        _:_ -> false;

function impl_2(a b) or_2(not(a) b);

function equ_2(a b) 
    match(a:b) 
        true:true -> true,
        false:false -> true,
        _:_ -> false;

function table(f)  
    [ [a b f(a b)]
      | a <- [true false], b <- [true false]];

assert(table(fn(a b) and_2(a or_2(a b)))
       [[true, true, true],
        [true, false, true],
        [false, true, false],
        [false, false, false]]);

// 47. (*) Truth tables for logical expressions (2).
//         Continue problem P46 by defining and/2, or/2, etc
//         as being operators.

// Using slogan's built-in logical operators:
assert(table(fn(a b) a && (a || b))
       [[true, true, true],
        [true, false, true],
        [false, true, false],
        [false, false, false]]);

// 48. (**) Truth tables for logical expressions (3).
//          Generalize problem 47 in such a way that the
//          logical expression may contain any number of logical variables.

function eliminate_duplicates(xs) 
    match(xs) 
        [] -> [],
        x : xs -> x : eliminate_duplicates(filter(fn(y) not(x == y), xs));
        
function tablen(n f) 
    map(fn(args) append(args, [apply(f, args)]),
        eliminate_duplicates(combinations(n apply(append list_of(n [true false])))));

// assert(tablen(3, fn(a b c) a && ((b || c == (a && b)) || (a && c)))
//        [[true, false, true, true], [true, false, false, true],
//         [true, true, false, true], [true, true, true, true],
//         [false, true, false, true], [false, true, true, true],
//         [false, false, true, true], [false, false, false, true]]);

// 49. (**) Gray codes.

function gray(n) 
     eliminate_duplicates(combinations(n apply(append list_of(n [0 1]))));

assert(gray(3)
       [[0, 1, 0], [0, 1, 1],
        [0, 0, 1], [0, 0, 0],
        [1, 0, 1], [1, 0, 0],
        [1, 1, 0], [1, 1, 1]]);


// 50 (***) Huffman codes.

// This solution is based on the Huffman encoding exercise is SICP.
// TODO: Align solution to the original 99 problem defintion.

function make_leaf(sym weight) [!leaf sym weight];
function is_leaf(obj) first(obj) == !leaf;
function symbol_leaf(leaf) second(leaf);
function weight_leaf(leaf) third(leaf);

function make_code_tree(left right) 
    [left
     right
     append(symbols(left) symbols(right))
     weight(left) + weight(right)];

function left_branch(tree) first(tree);
function right_branch(tree) first(rest(tree));

function symbols(tree) 
    if (is_leaf(tree)) [symbol_leaf(tree)]
    else first(rest(rest(tree)));

function weight(tree) 
    if (is_leaf(tree)) weight_leaf(tree)
    else first(rest(rest(rest(tree))));

function decode(bits tree) {
    function decode_1(bits current_branch) 
        if (is_empty(bits)) nil
        else let (next_branch = choose_branch(first(bits) current_branch)) 
            if (is_leaf(next_branch)) symbol_leaf(next_branch) : decode_1(rest(bits) tree)
            else decode_1(rest(bits) next_branch);
    decode_1(bits tree)
};

function choose_branch(bit branch) 
    if (bit == 0) left_branch(branch)
    else if (bit == 1) right_branch(branch)
    else error("bad bit -- choose_branch" bit);

function encode(message tree) 
    if (is_empty(message)) nil
    else append(encode_symbol(first(message) tree)
                encode(rest(message) tree));

function encode_symbol(symbol tree) {
    function has_symbol(sym branch) member(sym symbols(branch));
    if (is_leaf(tree)) nil
    else let (left = left_branch(tree)
              right = right_branch(tree)) 
        if (has_symbol(symbol left)) 0 : encode_symbol(symbol left)
        else if (has_symbol(symbol right)) 1 : encode_symbol(symbol right)
        else error("symbol not in tree" symbol)
};

define sample_tree = make_code_tree(make_leaf(!A 4), make_code_tree(make_leaf(!B 2), make_code_tree(make_leaf(!D 1) make_leaf(!C 1))));
define message = %[A D A B B C A];
assert(decode(encode(message sample_tree) sample_tree)
       message);