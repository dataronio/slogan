load "1_to_10"; // for encode.

// 31. (**) Determine whether a given integer number is prime.

// Slogan has the is_prime() function built-in, so we call ours my_is_prime:
function my_is_prime(n)
    if (n < 4) n > 1
    else and(is_odd(n)
             let loop (k = 3) 
                 or(k * k > n
                    and(is_positive(remainder(n k))
                        loop(k + 2))));


assert(my_is_prime(7) true);
assert(my_is_prime(40) false);

// 32. (**) Determine the greatest common divisor of two positive integer numbers.
//          Use Euclid's algorithm.

// Slogan has the gcd() function built-in, so ours in my_gcd:
function my_gcd(a b)
    if (is_zero(b)) abs(a)
    else my_gcd(b, mod(a b));

assert([my_gcd(36 63) my_gcd(-3, -6) my_gcd(-3, 6)]
       [9 3 3]);

// 33. (*) Determine whether two positive integer numbers are coprime.
//         Two numbers are coprime if their greatest common divisor equals 1.

function is_coprime(a b) gcd(a b) == 1;

assert(is_coprime(35 64) true);

// 34. (**) Calculate Euler's totient function phi(m).
//          Euler's so-called totient function phi(m) is defined as the number of
//          positive integers r (1 <= r < m) that are coprime to m.

// Let's use lazy streams!
function ints(n) n :: ints(inc(n));

function totient_phi(m) {
    function totient_phi_helper(m) 
    let loop (n = m
              is = ints(1)
              c = 0) 
        if (n <= 1) c
        else loop(dec(n)
                  rest(is)
                  if (is_coprime(first(is) m)) inc(c) else c);

    if (m == 1) 1
    else totient_phi_helper(m)
};
    
assert(totient_phi(10) 4);

// 35. (**) Determine the prime factors of a given positive integer.
//          Construct a flat list containing the prime factors in ascending order.

function prime_factors(n) {
    function prime_factors_helper(n f) 
        if (n == 1) []
        else if (is_zero(mod(n f))) f : prime_factors_helper(div(n f) f)
        else prime_factors_helper(n inc(f));

    prime_factors_helper(n 2)
};

assert(prime_factors(315)
       [3, 3, 5, 7]);

// 36. (**) Determine the prime factors of a given positive integer.
//          Construct a list containing the prime factors and their multiplicity.

function prime_factors_mult(n) 
    let (swap = fn(p) match(p) [x y] -> [y x]) 
        map(swap encode(prime_factors(n)));

assert(prime_factors_mult(315)
       [[3, 2], [5, 1], [7, 1]]);


//  37 (**) Calculate Euler's totient function phi(m) (improved).
//          See problem 34 for the definition of Euler's totient function.
//          If the list of the prime factors of a number m is known in the form of
//          problem 36 then the function phi(m) can be efficiently calculated as follows:
//          Let ((p1 m1) (p2 m2) (p3 m3) ...) be the list of prime factors (and their multiplicities)
//          of a given number m. Then phi(m) can be calculated with the following formula:
//
//             phi(m) = (p1 - 1) * p1 ** (m1 - 1) * 
//                      (p2 - 1) * p2 ** (m2 - 1) * 
//                      (p3 - 1) * p3 ** (m3 - 1) * ...

function totient_phi_imp(m)
    apply(`*` map(fn(pm) match(pm) [p m] -> dec(p) * expt(p dec(m))
                  prime_factors_mult(m)));

assert(totient_phi_imp(315)
       totient_phi(315));

// 38 (*) Compare the two methods of calculating Euler's totient function.
//        Use the solutions of problems 34 and 37 to compare the algorithms.
//        Take the number of reductions as a measure for efficiency. Try to calculate phi(10090) as an example.

// (no solution required)

// 39 (*) A list of prime numbers.
//        Given a range of integers by its lower and upper limit, construct a list of all prime
//        numbers in that range.

function primes_r(a b) filter(is_prime, enumerate(a b));

assert(take(4, primes_r(10 20))
       [11, 13, 17, 19]);

// 40 (**) Goldbach's conjecture.
//         Goldbach's conjecture says that every positive even number greater than
//         2 is the sum of two prime numbers. Example: 28 = 5 + 23. It is one of the most
//         famous facts in number theory that has not been proved to be correct in the general case.
//         It has been numerically confirmed up to very large numbers.
//         Write a predicate to find the two prime numbers that sum up to a given even integer.

function goldbach(n)
    let (pr = primes_r(2, n-2)) 
        head([[x, y] | x <- pr, y <- pr where x + y == n]);

assert(goldbach(28), [5, 23]);


// 41 (**) Given a range of integers by its lower and upper limit, print a list of all even
//         numbers and their Goldbach composition.
//
//         In most cases, if an even number is written as the sum of two prime numbers,
//         one of them is very small. Very rarely, the primes are both bigger than say 50.
//         Try to find out how many such cases there are in the range 2..3000.

function goldbach_list(a b) map(fn(n) [n goldbach(n)], filter(is_even, range(a b)));

function goldbach_list_bigger(a b n) filter(fn(gb) length(second(gb)) == 2
                                                   && first(second(gb)) > n
                                                   && second(second(gb)) > n
                                            goldbach_list(a b));
