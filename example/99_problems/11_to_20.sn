load "1_to_10";

// 11. (*) Modified run-length encoding.
//         Modify the result of problem 10 in such a way that if an element
//         has no duplicates it is simply copied into the result list. 
//         Only elements with duplicates are transferred as (N E) lists. 

function encode_modified(xs) 
    map(fn(xs) 
	let (len = length(xs)) 
	    if (len == 1) first(xs)
	    else [length(xs) first(xs)],
	pack(xs));

assert(encode_modified(%[a a a a b c c a a d e e e e]),
       %[[4 a] b [2 c] [2 a] d [4 e]]);

// 12. (**) Decode a run-length encoded list. 

function decode_modified(xs) 
    fold_right(fn(a b) 
            if (is_pair(a)) append(a b) 
            else append([a] b),
	   [],
	   map(fn(xs) 
       	        if (not(is_pair(xs))) xs
	        else list_of(first(xs) second(xs)),
	       xs));

assert(decode_modified(encode_modified(%[a a a a b c c a a d e e e e])),
       %[a a a a b c c a a d e e e e]);

// 13. (**) Run-length encoding of a list (direct solution).
//          Implement the so-called run-length encoding data compression method directly. 
//          I.e. don't explicitly create the sublists containing the duplicates, as in problem 9, 
//          but only count them. As in problem P11, simplify the result list by replacing the 
//          singleton lists (1 X) by X. 

function encode_append(r c x) append(r if (c == 1) [x] else [[c x]]);

function encode_helper(c x1 xs r)
    match(xs)
	[] -> encode_append(r c x1),
	x2 : xs where x1 == x2 -> encode_helper(inc(c) x2 xs r),
        x2 : xs -> encode_helper(1 x2 xs encode_append(r c x1));

function encode_direct(xs) 
    match(xs)
	[] -> [],
	x : xs -> encode_helper(1 x xs []);

assert(encode_direct(%[a a a a b c c a a d e e e e]),
       %[[4 a] b [2 c] [2 a] d [4 e]]);

// 14. (*) Duplicate the elements of a list. 

function dupli(xs) 
    match(xs) 
	[] -> [],
	x : xs -> x : x : dupli(xs);

assert(dupli([ 1 2 3]),
       [1, 1, 2, 2, 3, 3]);

// 15. (**) Replicate the elements of a list a given number of times.

function repli(n xs) 
    match(xs) 
	[] -> [],
	x : xs -> append(list_of(n x)
			 repli(n xs));

assert(repli(3 %[a b c])
       %[a, a, a, b, b, b, c, c, c]);

// 16. (**) Drop every N'th element from a list. 

function drop_every(n i xs r) 
    match(xs) 
	[] -> reverse(r),
	x : xs -> drop_every(n inc(i) xs
			     if (is_zero(mod(i n))) r
			     else x : r);

function drop_nth(n xs) drop_every(n 1 xs []);

assert(drop_nth(3 %[a b c d e f g h i k])
       %[a, b, d, e, g, h, k]);

// 17. (*) Split a list into two parts; the length of the first part is given.

function split(n xs) [take(n xs) drop(n xs)];
    
assert(split(3 %[a b c d e f g h i k])
       %[[a, b, c], [d, e, f, g, h, i, k]]);

// 18. (**) Extract a slice from a list.
//          Given two indices, i and k, the slice is the list containing 
//          the elements between the i'th and k'th element of the original 
//          list (both limits included). Start counting the elements with 1.

function slice(i j xs) take(j - dec(i), drop(dec(i) xs));

assert(slice(3 7 %[a b c d e f g h i k])
       %[c, d, e, f, g]);

// 19. (**) Rotate a list N places to the left. 

function rotate(n xs) 
    let (n = if (is_negative(n)) length(xs) + n
  	      else n) 
	append(drop(n xs) take(n xs));

assert(rotate(-2, %[a b c d e f g h])
       %[g, h, a, b, c, d, e, f]);
assert(rotate(3 %[a b c d e f g h])
       %[d, e, f, g, h, a, b, c]);

// 20. (*) Remove the K'th element from a list. 

function remove_at(n xs)
    append(take(dec(n) xs)
	   drop(n xs));

assert(remove_at(2 %[a b c d])
       %[a, c, d]);