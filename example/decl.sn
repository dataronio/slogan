// Some declarative programming examples.

link("util");

// Programming with lists:
function len(xs) 
    match(xs) 
        [] -> 0,
        _ : xs -> inc(len(xs));

assert(len(%[a b c]), length(%[a b c]));

function iter_len(xs, n) 
    match(xs) 
        [] -> n,
        _ : xs -> iter_len(xs, inc(n));

assert(iter_len(%[a b c], 0), len(%[a b c]));

function apnd(xs ys) 
    match (xs : ys) 
        [] : ys -> ys,
        (x : xs) : ys -> x : apnd(xs ys);

assert(apnd([1 2 3] [4 5 6]), [1 2 3 4 5 6]);
        
// Finding square roots with Newton's method:
function sqrt(x) {
    function improve(guess) (guess + x/guess) / 2.0;
    function is_good_enough(guess) abs(x - guess*guess)/x < 0.00001;
    function sqrt_iter(guess) 
        if (is_good_enough(guess)) guess
        else sqrt_iter(improve(guess));
    sqrt_iter(1.0)
};

assert(floor(sqrt(10)), 3.);
assert(floor(sqrt(3)), 1.);

// Mergesort:
function merge(xs ys) 
    match(xs : ys) 
        [] : ys -> ys,
        xs : [] -> xs,
        (x:xr) : (y:yr) ->
            if (x < y) x : merge(xr ys)
            else y : merge(xs yr);

function split(xs) 
    match(xs) 
        [] -> nil : nil,
        [x] -> [x] : nil,
        x1:x2:xr -> 
            let (r = split(xr)) 
               append([x1:first(r)] [x2:second(r)]);

function mergesort(xs) 
    match(xs) 
        [] -> nil,
        [x] -> [x],
        else -> let (r = split(xs)) 
            merge(mergesort(first(r)), mergesort(second(r)));

assert(mergesort([10 2 3 1 9]), [1 2 3 9 10]);            

// Amortized constant-time ephemeral queue:

namespace queue;

function mkqueue() nil : nil;

function check(q) 
    match(q) 
        [] : r -> reverse(r) : nil,
        else -> q;

function insert(q x) 
    match(q) 
        f : r -> check(f : (x:r));

function delete(q) 
    match(q)
        f : r -> check(rest(f) : r);

function is_empty(q) 
    match(q) 
        f : _ -> f == nil;

define q = mkqueue();
q = insert(q 1);
q = insert(q 2);
q = delete(q);
assert(is_empty(q), false);
q = insert(q 3);
q = delete(delete(q));
assert(is_empty(q), true);

namespace; // queue

// Ordered binary trees:

namespace otree;

record leaf();
record tree(key value left right);

function lookup(x t) 
    match(t) 
        leaf() -> !notfound,
        tree(k _ lt _) where x < k -> lookup(x lt),
        tree(k _ _ rt) where x > k -> lookup(x rt),
        tree(k v _ _) where x == k -> v;

function insert(x v t) 
    match(t) 
        leaf() -> tree(key = x, value = v, left = leaf(), right = leaf()),
        tree(k _ _ _) where x == k -> t,
        tree(k w lt rt) where x < k -> tree(key = k, value = w, left = insert(x v lt), right = rt),
        tree(k w lt rt) where x > k -> tree(key = k, value = w, left = lt, right = insert(x v rt));

function remove_smallest(t) 
    match(t) 
        leaf() -> false,
        tree(k w lt rt) -> {
            match(remove_smallest(lt)) 
                false -> k:w:rt,
                yp:vp:tp -> yp:vp:tree(key=k, value=w, left=tp, right=rt)
        };

function delete(x t) 
    match(t) 
        leaf() -> t,
        tree(k w lt rt) where x == k -> {
            match(remove_smallest(rt)) 
                false -> lt,
                yp:vp:tp -> tree(key=yp, value=vp, left=lt, right=tp)
        },
        tree(k w lt rt) where x < k -> tree(key=k, value=w, left=delete(x, lt), right=rt),
        tree(k w lt rt) where x > k -> tree(key=k, value=w, left=lt, right=delete(x, rt));

define t = tree(key = 1, value = 100,
                left = tree(key = -1, value = 200, left = leaf(), right=leaf()),
                right= tree(key = 2, value = 300, left=leaf(), right=leaf()));

t = insert(5, 600, t);
assert(lookup(2, t), 300);
assert(lookup(5, t), 600);
assert(lookup(-1, t), 200);
assert(lookup(-5, t), !notfound);
t = delete(2, t);
assert(lookup(2, t), !notfound);
assert(lookup(5, t), 600);
assert(lookup(-1, t), 200);
t = delete(-1, t);
assert(lookup(-1, t), !notfound);

namespace; // otree
        
// Loops:

function foldl(xs f u) 
    match(xs) 
        [] -> u,
        x:xs -> foldl(xs f f(x u));

function foldr(xs f u) foldl(reverse(xs) f u);

assert(foldl([1 2 3 4 5] `+` 0), 15);
assert(foldr([1 2 3 4 5] `+` 0), foldl([1 2 3 4 5] `+` 0));
assert(foldl([1, -2 3, -4] `/` 10), 80/3);
assert(foldr([1, -2 3, -4] `/` 10), 15/4);


// Currying:

define lower_bound10 = partial(max, 10);
assert(lower_bound10(20), 20);
assert(lower_bound10(1), 10);

// Secure ADTs:

function mkwrapper() 
    let (key = gensym()) {
        function wrap(x) fn(k) if (k == key) x;
        function unwrap(w) w(key);

        fn(msg) 
        case(msg) 
            wrap -> wrap,
            unwrap -> unwrap,
            else -> error("invalid message - " msg)
    };

// Secure ADT example - Stack:

function mkstack() 
    let (wrapper = mkwrapper()) {
        function new() wrapper.wrap([]);
        function push(s e) wrapper.wrap(e : wrapper.unwrap(s));
        function pop(s) let (xs = wrapper.unwrap(s)) match(xs) x : xs -> wrapper.wrap(xs), else -> s;
        function is_empty(s) wrapper.unwrap(s) == nil;

        fn(msg) 
        case(msg) 
            new -> new,
            push -> push,
            pop -> pop,
            is_empty -> is_empty,
            else -> error("invalid message - " msg)
    };