// Section 2.1.1

function add_rat(x y) 
    make_rat(numer(x) * denom(y) + numer(y) * denom(x),
             denom(x) * denom(y));

function sub_rat(x y) 
    make_rat(numer(x) * denom(y) - numer(y) * denom(x),
             denom(x) * denom(y));

function mul_rat(x y) 
    make_rat(numer(x) * numer(y), denom(x) * denom(y));

function div_rat(x y) 
    make_rat(numer(x) * denom(y), denom(x) * numer(y));

function is_equal_rat(x y) 
    numer(x) * denom(y) == numer(y) * denom(x);

function make_rat(n, d) let (g = gcd(n, d)) n/g : d/g;
function numer(x) head(x);
function denom(x) tail(x);

function print_rat(x) showln(numer(x) "/" denom(x));

// Exercise 2.1

function make_rat(n, d) 
    let (g = gcd(n, d)) 
        if (is_negative(d)) -n/g : -d/g
        else n/g : d/g;

// Exercise 2.2

function make_point(x y) x:y;
function x_point(p) head(p);
function y_point(p) tail(p);

function print_point(p) showln("(" x_point(p) ", " y_point(p) ")");
    
function make_segment(start_point end_point) start_point:end_point;
function start_segment(s) head(s);
function end_segment(s) tail(s);

function average(x, y) (x + y)/2;
function midpoint_segment(s) 
    make_point(average(x_point(start_segment(s)), x_point(end_segment(s))),
               average(y_point(start_segment(s)), y_point(end_segment(s))));

// Exercise 2.3

function make_rect(a b) (abs(x_point(a) - x_point(b))):(abs(y_point(a) - y_point(b)));
function rect_width(r) head(r);
function rect_height(r) tail(r);

function rect_perimeter(r) 2 * (rect_width(r) + rect_height(r));
function rect_area(r) rect_width(r) * rect_height(r);

// Exercise 2.4
// Not replacing the defintions of cons, car and cdr because
// it will break the implementation of Slogan itself.
// We will replace the function pair, head and tail instead.
function my_pair(x y) fn(m) m(x y);
function my_head(z) z(fn(p q) p);
function my_tail(z) z(fn(p q) q);

// Exercise 2.5
function numdivs(n d) 
{ function iter(x result)
  { if (is_zero(remainder(x d)))
      iter(x/d, inc(result))
    else result };
  iter(n 0) };

function my_pair(x y) expt(2 x) * expt(3 y);
function my_head(z) numdivs(z 2);
function my_tail(z) numdivs(z 3);

// Exercise 2.6
function zero(f) fn(x) x;
function one(f) fn(x) f(x);
function two(f) fn(x) f(f(x));
function add_church(m n) fn(f) fn(x) (m(f))(n(f)(x));

define three = add_church(one two);
(three(inc))(0); // => 3

// Exercise 2.7
function make_interval(a, b) a:b;
function lower_bound(x) head(x);
function upper_bound(x) tail(x);

function add_interval(x y) 
    make_interval(lower_bound(x) + lower_bound(y)
                  upper_bound(x) + upper_bound(y));

function mul_interval(x y) 
    let (p1 = lower_bound(x) * lower_bound(y)
         p2 = lower_bound(x) * upper_bound(y)
         p3 = upper_bound(x) * lower_bound(y)
         p4 = upper_bound(x) * upper_bound(y)) 
        make_interval(min(p1 p2 p3 p4), max(p1 p2 p3 p4));

function div_interval(x y) 
    mul_interval(x, make_interval(1.0/upper_bound(y), 1.0/lower_bound(y)));

// Exercise 2.8
function sub_interval(x y) 
    make_interval(lower_bound(x) - upper_bound(y)
                  upper_bound(x) - lower_bound(y));

// Exercise 2.10
function spans_zero(y) lower_bound(y) <= 0 && upper_bound(y) >= 0;

function div_interval(x y) 
    if (spans_zero(y)) error("the denominator should not span 0 -" y)
    else mul_interval(x, make_interval(1.0/upper_bound(y), 1.0/lower_bound(y)));


// Exercise 2.17
function last_pair(xs) 
    if (is_empty(xs) || is_empty(tail(xs))) xs
    else last_pair(tail(xs));

// Exercise 2.18
function my_reverse(xs)  
    if (is_empty(xs)) xs
    else append(my_reverse(tail(xs)), [first(xs)]);

// An iterative version of my_reverse:
function my_reverse(xs) 
{ function iter(xs, result) 
    if (is_empty(xs)) result
    else iter(tail(xs), first(xs) : result);
  iter(xs, []) };

// Exercise 2.19
function has_no_more(coins) is_empty(coins);
function except_first_denomination(coins) tail(coins);
function first_denomination(coins) head(coins);

function cc(amount coin_values) 
    if (amount == 0) 1
    else if (amount < 0 || has_no_more(coin_values)) 0
    else add(cc(amount, except_first_denomination(coin_values)),
             cc(amount - first_denomination(coin_values), coin_values));

// Exercise 2.20
function filter_list(predic, xs) 
    if (is_empty(xs)) xs
    else if (predic(head(xs))) head(xs):filter_list(predic, tail(xs))
    else filter_list(predic, tail(xs));
    
function same_parity(x, @rest xs) filter_list(if(is_odd(x)) is_odd else is_even, x:xs);

// Exercise 2.21
function square(x) x * x;

function square_list(items) 
    if (is_empty(items)) items
    else square(head(items)) : square_list(tail(items));
    
function square_list(items) map(square, items);

// Exercise 2.23
function my_for_each(f, xs) 
    if (is_empty(xs)) true
    else { f(head(xs));
           my_for_each(f, tail(xs))
         };

// Exercise 2.25
head(tail(head(tail(tail([1 3 [5 7] 9])))));
head(head([[7]]));
head(tail(head(tail(head(tail(head(tail(head(tail(head(tail([1 [2 [3 [4 [5 [6 7]]]]]]))))))))))));

// Exercise 2.27
function deep_reverse(xs) 
{ function iter(xs, result) 
    if (is_empty(xs)) result
    else if (is_pair(head(xs))) iter(tail(xs), deep_reverse(head(xs)):result)
    else iter(tail(xs), head(xs):result);
  iter(xs, []) };

// Exercise 2.28
function fringe(xs) 
    if (is_empty(xs)) xs
    else if (is_pair(head(xs))) append(fringe(head(xs)), fringe(tail(xs)))
    else head(xs) : fringe(tail(xs));

// Exercise 2.29
function make_mobile(left right) [left right];
function make_branch(length structure) [length structure];
function left_branch(mobile) head(mobile);
function right_branch(mobile) head(tail(mobile));
function branch_length(branch) head(branch);
function branch_structure(branch) head(tail(branch));

function branch_weight(branch) 
    if (is_pair(branch_structure(branch)))
        total_weight(branch_structure(branch))
    else branch_structure(branch);

function total_weight(mobile) 
    branch_weight(left_branch(mobile)) + branch_weight(right_branch(mobile));

function branch_torque(branch) branch_length(branch) * branch_weight(branch);

function is_branch_balanced(branch) 
    if (is_pair(branch_structure(branch)))
        is_balanced(branch_structure(branch))
    else true;

function is_balanced(mobile) 
    and(branch_torque(left_branch(mobile)) == branch_torque(right_branch(mobile)),
        is_branch_balanced(left_branch(mobile)),
        is_branch_balanced(right_branch(mobile)));

// Exercise 2.30
function square_tree(xs) 
    if (is_empty(xs)) xs
    else if (is_pair(head(xs))) square_tree(head(xs)):square_tree(tail(xs))
    else square(head(xs)):square_tree(tail(xs));
    
function square_tree(xs) 
    map(fn(xs) if (is_pair(xs)) square_tree(xs) else square(xs), xs);

// Exercise 2.31
function tree_map(f, xs) map(fn(x) if (is_pair(x)) tree_map(f, x) else f(x), xs);

// Exercise 2.32
function subsets(s) 
    if (is_empty(s)) [[]]
    else let (rest = subsets(tail(s))) 
        append(rest, map(fn(x) first(s):x, rest));

// Section 2.2.3 - Sequence operations
// We use the Slogan built-in function `fold_right` instead of `accumulate`.
function fib(n)
    if (n <= 1) 0
    else if (n == 2) 1
    else fib(n-1) + fib(n-2);
    
function enumerate_tree(tree) 
    if (is_empty(tree)) tree
    else if (not(is_pair(tree))) [tree]
    else append(enumerate_tree(head(tree)),
                enumerate_tree(tail(tree)));

function sum_odd_squares(tree) 
    fold_right(`+`, 0, map(square, filter(is_odd, enumerate_tree(tree))));

function even_fibs(n) 
    fold_right(pair, [], map(fib, filter(is_even, range(0, n))));

// Exercise 2.33
function a_map(p, sequence) fold_right(fn(x y) p(x):y, nil, sequence);
function a_append(seq1, seq2) fold_right(pair, seq2, seq1);
function a_length(sequence) fold_right(fn(x y) inc(y), 0, sequence);

// Exercise 2.34
function horner_eval(x coefficient_sequence) 
    fold_right(fn(this_coeff higher_terms) x * higher_terms + this_coeff, 0, coefficient_sequence);

// Exercise 2.35
function count_leaves(tree) 
    fold_right(`+`, 0, map(fn(x) if (is_pair(x)) count_leaves(x) else 1, tree));

// Exercise 2.36
function accumulate_n(op init seqs) 
    if (is_empty(head(seqs))) nil
    else fold_right(op, init, map(head, seqs)):accumulate_n(op, init, map(tail, seqs));

// Exercise 2.37
function dot_product(v w) fold_right(`+`, 0, map(`*`, v, w));

function matrix_by_vector(m v) map(fn(row) dot_product(row v), m);

function transpose(m) accumulate_n(pair, nil, m);

function matrix_by_matrix(m n) 
    let (cols = transpose(n)) 
        map(fn(row) matrix_by_vector(cols row), m);

// Exercise 2.39
function my_reverse_r(sequence) fold_right(fn(x y) append(y, [x]), nil, sequence);
function my_reverse_l(sequence) fold_left(fn(x y) x:y, nil, sequence);

// Nested mappings
function flatmap(f seq) fold_right(append nil map(f seq));
function is_prime_sum(p) is_prime(first(p) + second(p));
function make_pair_sum(p) [first(p), second(p), first(p) + second(p)];

function prime_sum_pairs(n) 
    map(make_pair_sum
        filter(is_prime_sum
               flatmap(fn(i) map(fn(j) [i j], range(1, i-1))
                       range(1, n))));

function permutations(xs) 
    if (is_empty(xs)) [xs]
    else flatmap(fn(x) map(fn(p) x:p, permutations(remove(x, xs))), xs);

// Exercise 2.40
function unique_pairs(n) flatmap(fn(i) map(fn(j) [i j], range(1, i - 1)), range(1, n));
function prime_sum_pairs(n) map(make_pair_sum, filter(is_prime_sum, unique_pairs(n)));

// Exercise 2.41
function ordered_triples(n)
    flatmap(fn(i) flatmap(fn(j) map(fn(k) [i j k], range(1, j-1)), range(1, i-1)), range(1, n));

function is_triple_sum(triple s) fold_right(`+`, 0, triple) == s;
function make_triple_sum(triple) append(triple [fold_right(`+` 0 triple)]);

function ordered_triple_sum(n s) 
    map(make_triple_sum, filter(fn(triple) is_triple_sum(triple s), ordered_triples(n)));

// Exercise 2.54
function my_is_equal(xs ys) 
    if (is_empty(xs) && is_empty(ys)) true
    else if (is_empty(xs) || is_empty(ys)) false
    else if (is_pair(head(xs)) && is_pair(head(ys))) 
        my_is_equal(head(xs), head(ys)) && my_is_equal(tail(xs), tail(ys))
    else if (is_eq(head(xs), head(ys))) my_is_equal(tail(xs), tail(ys))
    else false;

// Section 2.3.2 - Symbolic Differentiation
function deriv(exp var) 
    if (is_number(exp)) 0
    else if (is_variable(exp)) if (is_same_variable(exp var)) 1 else 0
    else if (is_sum(exp)) make_sum(deriv(addend(exp) var), deriv(augend(exp) var))
    else if (is_product(exp)) make_sum(make_product(multiplier(exp) deriv(multiplicand(exp) var))
                                       make_product(deriv(multiplier(exp) var) multiplicand(exp)))
    else error("unknown expression type -- DERIV" exp);

function is_variable(exp) is_symbol(exp);
function is_same_variable(e1 e2) is_variable(e1) && is_variable(e2) && is_eq(e1 e2);
function make_sum(e1 e2) %[`+` %%e1 %%e2];
function make_product(e1 e2) %[`*` %%e1 %%e2];
function is_sum(x) is_pair(x) && is_eq(head(x), %`+`);
function addend(s) second(s);
function augend(s) third(s);
function is_product(x) is_pair(x) && is_eq(head(x), %`*`);
function multiplier(p) second(p);
function multiplicand(p) third(p);

function is_eq_number(exp num) is_number(exp) && exp == num;

function make_sum(a1 a2) 
    if (is_eq_number(a1 0)) a2
    else if (is_eq_number(a2 0)) a1
    else if (is_number(a1) && is_number(a2)) a1 + a2
    else list(!`+` a1 a2);

function make_product(m1 m2) 
    if (is_eq_number(m1 0) || is_eq_number(m2 0)) 0
    else if (is_eq_number(m1 1)) m2
    else if (is_eq_number(m2 1)) m1
    else if (is_number(m1) && is_number(m2)) m1 * m2
    else list(!`*` m1 m2);

// Exercise 2.56
function is_exponentiation(x) is_pair(x) && is_eq(head(x), !`**`);
function base(e) second(e);
function exponent(e) third(e);

function make_exponentiation(base exponent) 
    if (is_eq_number(exponent 0)) 1
    else if (is_eq_number(exponent 1)) base
    else if (is_number(base) && is_number(exponent)) expt(base exponent)
    else list(!`**` base exponent);

function deriv(exp var) 
    if (is_number(exp)) 0
    else if (is_variable(exp)) if (is_same_variable(exp var)) 1 else 0
    else if (is_sum(exp)) make_sum(deriv(addend(exp) var), deriv(augend(exp) var))
    else if (is_product(exp)) make_sum(make_product(multiplier(exp) deriv(multiplicand(exp) var))
                                       make_product(deriv(multiplier(exp) var) multiplicand(exp)))
    else if (is_exponentiation(exp)) make_product(make_product(exponent(exp)
                                                               make_exponentiation(base(exp)
                                                                                   make_sum(exponent(exp), -1))),
                                                  deriv(base(exp) var))
    else error("unknown expression type -- DERIV" exp);

// Section 2.3.3  Example: Representing Sets
// Sets as unordered lists

function is_element_of_set(x set) 
    if (is_empty(set)) false
    else if (x == head(set)) true
    else is_element_of_set(x tail(set));

function adjoin_set(x set) 
    if (is_element_of_set(x set)) set
    else x:set;

function intersetction_set(set1 set2) 
    if (is_empty(set1) || is_empty(set2)) nil
    else if (is_element_of_set(head(set1), set2))
        head(set1):intersetction_set(tail(set1) set2)
    else intersetction_set(tail(set1) set2);

// Exercise 2.59
function union_set(set1 set2) 
    if (is_empty(set1)) set2
    else if (is_element_of_set(head(set1) set2)) 
        union_set(tail(set1) set2)
    else union_set(tail(set1) head(set1):set2);

// Exercise 2.60
function adjoin_set(x set) x:set;
function union_set(set1 set2) append(set1 set2);

// Exercise 2.61
function adjoin_set(x set) 
    if (is_empty(set)) [x]
    else if (x == head(set)) set
    else if (x < head(set)) x:set
    else if (x > head(set)) head(set):adjoin_set(x, tail(set));

// Exercise 2.62
function union_set(set1 set2) 
    if (is_empty(set1)) set2
    else if (is_empty(set2)) set1
    else if (head(set1) == head(set2))
        head(set1):union_set(tail(set1) tail(set2))
    else if (head(set1) < head(set2))
        head(set1):union_set(tail(set1) set2)
    else head(set2):union_set(set1 tail(set2));

// Section 2.3.4 Huffman Encoding Trees

function make_leaf(symbol weight) [!leaf symbol weight];
function is_leaf(object) is_eq(head(object), !leaf);
function symbol_leaf(x) second(x);
function weight_leaf(x) third(x);

function make_code_tree(left right) 
    [left right append(symbols(left), symbols(right))
     weight(left) + weight(right)];

function left_branch(tree) head(tree);
function right_branch(tree) second(tree);

function symbols(tree) 
    if (is_leaf(tree)) [symbol_leaf(tree)]
    else third(tree);
    
function weight(tree) 
    if (is_leaf(tree)) weight_leaf(tree)
    else fourth(tree);

function decode(bits tree) 
{ function decode_1(bits current_branch) 
    if (is_empty(bits)) bits
    else let (next_branch = choose_branch(head(bits) current_branch)) 
        if (is_leaf(next_branch)) symbol_leaf(next_branch):decode_1(tail(bits) tree)
        else decode_1(tail(bits) next_branch);
  decode_1(bits tree) };
    
function choose_branch(bit branch) 
    if (bit == 0) left_branch(branch)
    else if (bit == 1) right_branch(branch)
    else error("bad bit -- choose_branch" bit);

function adjoin_set(x set) 
    if (is_empty(set)) [x]
    else if (weight(x) < weight(head(set))) x:set
    else head(set):adjoin_set(x tail(set));
    
function make_leaf_set(pairs) 
    if (is_empty(pairs)) nil
    else let (pair = head(pairs)) 
        adjoin_set(make_leaf(head(pair), second(pair))
                   make_leaf_set(tail(pairs)));

// Exercise 2.67
define sample_tree = make_code_tree(make_leaf(!A 4),
                                    make_code_tree(make_leaf(!B 2),
                                                   make_code_tree(make_leaf(!D 1),
                                                                  make_leaf(!C 1))));
define sample_message = [0 1 1 0 0 1 0 1 0 1 1 1 0];
decode(sample_message sample_tree); // => [A, D, A, B, B, C, A]

// Section 2.4.1  Representations for Complex Numbers
function add_complex(z1 z2) 
    make_from_real_imag(real_part(z1) + real_part(z2)
                        imag_part(z1) + imag_part(z2));
    
function sub_complex(z1 z2) 
    make_from_real_imag(real_part(z1) - real_part(z2)
                        imag_part(z1) - imag_part(z2));

function mul_complex(z1 z2) 
    make_from_mag_ang(magnitude(z1) * magnitude(z2)
                      angle(z1) + angle(z2));
    
function div_complex(z1 z2) 
    make_from_mag_ang(magnitude(z1) / magnitude(z2)
                      angle(z1) - angle(z2));

// Ben's representation:
function real_part(z) head(z);
function imag_part(z) tail(z);
function magnitude(z) sqrt(square(real_part(z)) + square(imag_part(z)));
function angle(z) atan(imag_part(z), real_part(z));
function make_from_real_imag(x y) x:y;
function make_from_mag_ang(r a) r * cos(a) : r * sin(a);

// Alyssa's representation:
function real_part(z) magnitude(z) * cos(angle(z));
function imag_part(z) magnitude(z) * sin(angle(z));
function magnitude(z) head(z);
function angle(z) tail(z);
function make_from_real_imag(x y) sqrt(square(x) + square(y)):atan(y x);
function make_from_mag_ang(r a) r:a;

// Section 2.4.2 Tagged data
function attach_tag(type_tag contents) type_tag:contents;

function type_tag(datum) 
    if (is_pair(datum)) head(datum)
    else error("Bad tagged datum -- TYPE-TAG" datum);

function contents(datum) 
    if (is_pair(datum)) tail(datum)
    else error("Bad tagged datum -- CONTENTS" datum);

function is_rectangular(z) is_eq(type_tag(z) !rectangular);
function is_polar(z) is_eq(type_tag(z) !polar);

// Ben's and Alyssa's representations updated using typetags:
namespace rectangular;
function real_part(z) head(z);
function imag_part(z) tail(z);
function magnitude(z) sqrt(square(real_part(z)) + square(imag_part(z)));
function angle(z) atan(imag_part(z), real_part(z));
function make_from_real_imag(x y) attach_tag(!rectangular, x:y);
function make_from_mag_ang(r a) attach_tag(!rectangular, r * cos(a) : r * sin(a));
namespace;

namespace polar;
function real_part(z) magnitude(z) * cos(angle(z));
function imag_part(z) magnitude(z) * sin(angle(z));
function magnitude(z) head(z);
function angle(z) tail(z);
function make_from_real_imag(x y) attach_tag(!polar, sqrt(square(x) + square(y)):atan(y x));
function make_from_mag_ang(r a) attach_tag(!polar, r:a);
namespace;

// Selectors based on typetags:
function real_part(z) 
    if (is_rectangular(z)) rectangular_real_part(contents(z))
    else if (is_polar(z)) polar_real_part(contents(z))
    else error("Unknown type -- REAL-PART" z);

function imag_part(z) 
    if (is_rectangular(z)) rectangular_imag_part(contents(z))
    else if (is_polar(z)) polar_imag_part(contents(z))
    else error("Unknown type -- IMAG-PART" z);

function magnitude(z) 
    if (is_rectangular(z)) rectangular_magnitude(contents(z))
    else if (is_polar(z)) polar_magnitude(contents(z))
    else error("Unknown type -- MAGNITUDE" z);

function angle(z) 
    if (is_rectangular(z)) rectangular_angle(contents(z))
    else if (is_polar(z)) polar_angle(contents(z))
    else error("Unknown type -- ANGLE" z);

function make_from_real_imag(x y) rectangular_make_from_real_imag(x y);
function make_from_mag_ang(r a) polar_make_from_mag_ang(r a);

// 2.4.3  Data-Directed Programming and Additivity
function install_package(pkgtype, fns) 
    let loop (fns = fns) 
        if (is_empty(fns)) !done
        else { put(head(head(fns)), pkgtype, tail(head(fns)));
               loop(tail(fns)) };

function install_rectangular_package() 
{ function real_part(z) head(z);
  function imag_part(z) tail(z);
  function magnitude(z) sqrt(square(real_part(z)) + square(imag_part(z)));
  function angle(z) atan(imag_part(z), real_part(z));
  function make_from_real_imag(x y) attach_tag(!rectangular, x:y);
  function make_from_mag_ang(r a) attach_tag(!rectangular, r * cos(a) : r * sin(a));
  // interface to the rest of the system
  function tag(x) attach_tag(!rectangular x);
  install_package([!rectangular],
                  list(!real_part:real_part
                       !imag_part:imag_part
                       !magnitude:magnitude
                       !angle:angle
                       !make_from_real_imag:fn(x y) tag(make_from_real_imag(x y))
                       !make_from_mag_ang:fn(r a) tag(make_from_mag_ang(r a)))) };

function install_polar_package() 
{ function real_part(z) magnitude(z) * cos(angle(z));
  function imag_part(z) magnitude(z) * sin(angle(z));
  function magnitude(z) head(z);
  function angle(z) tail(z);
  function make_from_real_imag(x y) attach_tag(!polar, sqrt(square(x) + square(y)):atan(y x));
  function make_from_mag_ang(r a) attach_tag(!polar, r:a);
  // interface to the rest of the system
  function tag(x) attach_tag(!polar x);
  install_package([!polar],
                  list(!real_part:real_part
                       !imag_part:imag_part
                       !magnitude:magnitude
                       !angle:angle
                       !make_from_real_imag:fn(x y) tag(make_from_real_imag(x y))
                       !make_from_mag_ang:fn(r a) tag(make_from_mag_ang(r a)))) };


// Message passing
function make_from_real_imag(x y) 
    fn(op) 
        match(op) 
            !real_part -> x,
            !imag_part -> y,
            !magnitude -> sqrt(square(x) + square(y)),
            !angle -> atan(y x),
            _ -> error("Unknown op -- make_from_real_imag" op);

// Exercise 2.75
function make_from_mag_ang(x y) 
    fn(op) 
        match(op) 
            !real_part -> x * cos(y),
            !imag_part -> x * sin(y),
            !magnitude -> x,
            !angle -> y,
            _ -> error("Unknown op -- make_from_mag_ang" op);

// Section 2.5.1 - Generic Arithmetic Operations
function add(x y) apply_generic(!add x y);
function sub(x y) apply_generic(!sub x y);
function mul(x y) apply_generic(!mul x y);
function div(x y) apply_generic(!div x y);

function install_scheme_number_package() 
{ function tag(x) attach_tag(!scheme_number x);
  install_package(%[scheme_number scheme_number],
                  list(!add:fn(x y) tag(x + y)
                       !sub:fn(x y) tag(x - y)
                       !mul:fn(x y) tag(x * y)
                       !div:fn(x y) tag(x / y)));
  put(!scheme_number, !make, fn(x) tag(x)) };

function make_scheme_number(n) (get(!make !scheme_number))(n);

// Exercise 2.78
function attach_tag(type_tag contents) 
    if (is_number(contents)) contents
    else type_tag:contents;

function type_tag(datum) 
    if (is_pair(datum)) head(datum)
    else if (is_number(datum)) !scheme_number
    else error("Bad tagged datum -- TYPE-TAG" datum);

function contents(datum) 
    if (is_pair(datum)) tail(datum)
    else if (is_number(datum)) datum
    else error("Bad tagged datum -- CONTENTS" datum);

// Exercise 2.79
put(%[scheme_number scheme_number], !is_equ, fn(x y) x == y);
put(%[rational rational], !is_equ, fn(x y) x == y);
put(%[complex complex], !is_equ, fn(x y) x == y);

// Exercise 2.80
put(%[scheme_number], !is_zero, fn(x) is_zero(x));
put(%[rational], !is_zero, fn(x) is_zero(number(x)));
put(%[complex complex], !is_equ, fn(x) is_zero(real_part(x)) && is_zero(imag_part(x)));



