// 4.1.1 The Core of the Evaluator
// In this implementation `eval` has been renamed to `evaluate` and `apply` to `fnapply`
// so that the original functions in Slogan is not rebound.

function evaluate(exp env) 
    if (is_self_evaluating(exp)) exp
    else if (is_variable(ex)) lookup_variable_value(exp env)
    else if (is_quoted(ex)) text_of_quotation(exp)
    else if (is_assignment(exp)) eval_assignment(exp env)
    else if (is_definition(exp)) eval_definition(exp env)
    else if (is_if(exp)) eval_if(exp env)
    else if (is_lambda(exp)) make_procedure(lambda_parameters(exp)
                                            lambda_body(exp)
                                            env)
    else if (is_begin(exp)) eval_sequence(begin_actions(exp) env)
    else if (is_cond(exp)) evaluate(cond_to_if(exp) env)
    else if (is_application(exp)) fnapply(evaluate(operator(exp) env)
                                          list_of_values(operands(exp) env))
    else error("Unknown expression type -- EVAL" exp);

function fnapply(procedure arguments) 
    if (is_primitive_procedure(procedure))
        apply_primitive_procedure(procedure arguments)
    else if (is_compound_procedure(procedure))
        eval_sequence(procedure_body(procedure)
                      extend_environment(procedure_parameters(procedure)
                                         arguments
                                         procedure_environment(procedure)))
    else error("Unknown procedure type -- APPLY" procedure);

function list_of_values(exps env) 
    if (has_no_operands(exps)) nil
    else evaluate(first_operand(exps) env):list_of_values(rest_operands(exps) env);

function is_true(exp) not(exp == false);

function eval_if(exp env) 
    if (is_true(evaluate(if_predicate(exp) env)))
        evaluate(if_consequent(exp) env)
    else evaluate(if_alternative(exp) env);

function eval_sequence(exps env) 
    if (is_last_exp(exps)) evaluate(first_exp(exps) env)
    else { evaluate(first_exp(exps) env);
           eval_sequence(rest_exps(exps) env) };

function eval_assignment(exp env) 
{ set_variable_value(assignment_variable(exp)
                     evaluate(assignment_value(exp) env)
                     env);
  !ok };

function eval_definition(exp env)
{ define_variable(definition_variable(exp)
                  evaluate(definition_value(exp) env)
                  env);
  !ok };

// Exercise 4.1
// left-right:
function list_of_values_lr(exps env) 
    if (has_no_operands(exps)) nil
    else let (e = evaluate(first_operand(exps) env)) 
        e:list_of_values(rest_operands(exps) env);

// right-left:
function list_of_values_rl(exps env) 
    if (has_no_operands(exps)) nil
    else let (es = list_of_values(rest_operands(exps) env)
              e = evaluate(first_operand(exps) env))
        e:es;

// 4.1.2 Representing Expressions
function is_tagged_list(exp tag) is_pair(exp) && is_eq(head(exp) tag);

function is_self_evaluating(exp) is_number(exp) || is_string(exp);
function is_variable(exp) is_symbol(exp);
function is_quoted(exp) is_tagged_list(exp, !quote);
function text_of_quotation(exp) head(tail(exp));

function is_assignment(exp) is_tagged_list(exp !`set!`);
function assignment_variable(exp) head(tail(exp));
function assignment_value(exp) head(tail(tail(exp)));

function is_definition(exp) is_tagged_list(exp !define);

function definition_variable(exp) 
    if (is_symbol(second(exp))) second(exp)
    else head(head(tail(exp)));
    
function definition_value(exp) 
    if (is_symbol(head(tail(exp)))) head(tail(tail(exp)))
    else make_lambda(tail(head(tail(exp))), tail(tail(exp)));

function is_lambda(exp) is_tagged_list(exp !lambda);
function lambda_parameters(exp) second(exp);
function lambda_body(exp) tail(tail(exp));
function make_lambda(parameters body) !lambda:(parameters:body);

function is_if(exp) is_tagged_list(exp !if);
function if_predicate(exp) second(exp);
function if_consequent(exp) third(exp);

function if_alternative(exp) 
    if (not(is_empty(nth_tail(3 exp))))
        head(nth_tail(3 exp))
    else false;

function make_if(predicate consequent alternative) [!if predicate consequent alternative];

function is_begin(exp) is_tagged_list(exp !begin);
function begin_actions(exp) tail(exp);
function is_last_exp(seq) is_empty(tail(seq));
function first_exp(seq) head(seq);
function rest_exps(seq) tail(seq);

function sequence_to_exp(seq) 
    if (is_empty(seq)) seq
    else if (is_last_exp(seq)) first_exp(seq)
    else make_begin(seq);

function make_begin(seq) !begin:seq;

function is_application(exp) is_pair(exp);
function operator(exp) head(exp);
function operands(exp) tail(exp);
function has_no_operands(ops) is_empty(ops);
function first_operand(ops) head(ops);
function rest_operands(ops) tail(ops);

function is_cond(exp) is_tagged_list(exp !cond);
function cond_clauses(exp) tail(exp);
function is_cond_else_clause(clause) is_eq(cond_predicate(clause) !else);
function cond_predicate(clause) head(clause);
function cond_actions(clause) tail(clause);
function cond_to_if(exp) expand_clauses(cond_clauses(exp));

function expand_clauses(clauses) 
    if (is_empty(clauses)) false
    else let (first = head(clauses)
              rest = tail(clauses)) 
        if (is_cond_else_clause(first)) 
            if (is_empty(rest)) sequence_to_exp(cond_actions(first))
            else error("ELSE clause isn't last -- COND->IF" clauses)
        else make_if(cond_predicate(first)
                     sequence_to_exp(cond_actions(first))
                     expand_clauses(rest));

// Exercises 4.4, 4.6, 4.7, 4.8, 4.20
function evaluate(exp env) 
    if (is_self_evaluating(exp)) exp
    else if (is_variable(exp)) lookup_variable_value(exp env)
    else if (is_quoted(exp)) text_of_quotation(exp)
    else if (is_assignment(exp)) eval_assignment(exp env)
    else if (is_definition(exp)) eval_definition(exp env)
    else if (is_if(exp)) eval_if(exp env)
    else if (is_lambda(exp)) make_procedure(lambda_parameters(exp)
                                            lambda_body(exp)
                                            env)
    else if (is_begin(exp)) eval_sequence(begin_actions(exp) env)
    else if (is_cond(exp)) evaluate(cond_to_if(exp) env)
    else if (is_and(exp)) eval_and(tail(exp) env)
    else if (is_or(exp)) eval_or(tail(exp) env)
    else if (is_let(exp)) evaluate(let_to_combination(tail(exp)), env)
    else if (is_letseq(exp)) evaluate(letseq_to_lets(tail(exp)), env)
    else if (is_letrec(exp)) evaluate(letrec_to_lets(tail(exp)), env)
    else if (is_application(exp)) fnapply(evaluate(operator(exp) env)
                                          list_of_values(operands(exp) env))
    else error("Unknown expression type -- EVAL" exp);

function is_and(exp) is_tagged_list(exp !and);
function eval_and(exp env)
    if (is_empty(exp)) true
    else if (is_last_exp(exp)) evaluate(head(exp) env)
    else let (r = evaluate(head(exp), env)) 
        if (not(is_true(r))) r
        else eval_and(tail(exp) env);

function is_or(exp) is_tagged_list(exp !or);
function eval_or(exp env) 
    if (is_empty(exp)) false
    else if (is_last_exp(exp)) evaluate(head(exp) env)
    else let (r = evaluate(head(exp), env)) 
        if (not(is_true(r))) eval_or(tail(exp) env)
        else r;

// and as a derived expression:
function and_to_ifs(exp) 
    if (is_empty(exp)) true
    else if (is_last_exp(exp)) exp
    else make_if(head(exp) and_to_ifs(tail(exp)) false);

// or as derived expression:
function or_to_ifs(exp) 
    if (is_empty(exp)) false
    else if (is_last_exp(exp)) exp
    else make_if(not(head(exp)) or_to_ifs(tail(exp)) true);

function is_let(exp) is_tagged_list(exp !let);
function let_to_combination(exp) 
    let (vars = let_vars(exp)
         vals = let_vals(exp)) 
        if (is_symbol(first(exp)))
            [!begin [!define first(exp) make_lambda(vars let_body(exp))]
             append(first(exp) vals)]
        else append([make_lambda(vars, [let_body(exp)])] vals);

function let_vars(exp) {
    function iter(bindings, vars) 
        if (is_empty(bindings)) reverse(vars)
        else iter(tail(bindings) first(first(bindings)):vars);
    iter(if (is_symbol(first(exp))) second(exp) else first(exp), [])
};

function let_vals(exp) {
    function iter(bindings vals) 
        if (is_empty(bindings)) reverse(vals)
        else iter(tail(bindings) second(first(bindings)):vals);
    iter(if (is_symbol(first(exp))) second(exp) else first(exp), [])
};

function let_body(exp) if (is_symbol(first(exp))) third(exp) else second(exp);

function make_let(bindings body) [!let bindings body];

function is_letseq(exp) is_tagged_list(exp !`let*`);

function letseq_to_lets(exp) 
    let (vars = let_vars(exp)
         vals = let_vals(exp)) {
        function iter(vars vals) 
            if (is_empty(vars)) let_body(exp)
            else make_let([[first(vars) first(vals)]] iter(tail(vars) tail(vals)));
        iter(vars vals)
    };

function is_letrec(exp) is_tagged_list(exp !letrec);

function letrec_to_lets(exp) 
    let (vars = let_vars(exp)
         vals = let_vals(exp)) 
        let iter(lvars = vars, letrec_bindings = []) 
            if (is_empty(lvars)) make_let(letrec_bindings, letrec_sets(vars vals let_body(exp)))
            else iter(tail(lvars) [head(lvars) %[quote `*unassigned*`]]:letrec_bindings);

function letrec_sets(vars vals letbody)  
{ function iter(vars vals sets) 
  if (is_empty(vars)) append([!begin] sets)
    else iter(tail(vars) tail(vals) [!`set!` head(vars) head(vals)]:sets);
  iter(vars vals [letbody]) };
                  
function make_procedure(parameters body env) [!procedure parameters body env];
function is_compound_procedure(p) is_tagged_list(p !procedure);
function procedure_parameters(p) second(p);
function procedure_body(p) third(p);
function procedure_environment(p) fourth(p);

function enclosing_environment(env) tail(env);
function first_frame(env) head(env);
define the_empty_environment = [];

function make_frame(variables values) variables:values;
function frame_variables(frame) head(frame);
function frame_values(frame) tail(frame);

function add_binding_to_frame(var val frame) {
    set_head(frame, var:head(frame));
    set_tail(frame, val:tail(frame));
};

function extend_environment(vars vals base_env) 
    if (length(vars) == length(vals)) make_frame(vars vals):base_env
    else if (length(vars) < length(vals)) error("Too many arguments supplied" vars vals)
    else error("Too few arguments supplied" vars vals);

function lookup_variable_value(var env) 
{ function env_loop(env) 
  { function scan(vars vals) 
      if (is_empty(vars)) env_loop(enclosing_environment(env))
      else if (is_eq(var head(vars))) head(vals)
      else scan(tail(vars) tail(vals));
      
      if (is_eq(env the_empty_environment)) error("Unbound variable" var)
      else let(frame = first_frame(env)) 
      scan(frame_variables(frame) frame_values(frame)) };
    env_loop(env) };

function set_variable_value(var val env) 
{ function env_loop(env) 
  { function scan(vars vals) 
      if (is_empty(vars)) env_loop(enclosing_environment(env))
      else if (is_eq(var head(vars))) set_head(vals val)
      else scan(tail(vars) tail(vals));
      
      if (is_eq(env the_empty_environment)) error("Unbound variable" var)
      else let(frame = first_frame(env)) 
      scan(frame_variables(frame) frame_values(frame)) };
    env_loop(env) };

function define_variable(var val env) 
    let (frame = first_frame(env)) 
    { function scan(vars vals) 
        if (is_empty(vars)) add_binding_to_frame(var val frame)
        else if (is_eq(var head(vars))) set_head(vals val)
        else scan(tail(vars) tail(vals));

      scan(frame_variables(frame) frame_values(frame)) };

function is_primitive_procedure(proc) is_tagged_list(proc !primitive);
function primitive_implementation(proc) head(tail(proc));

define primitive_procedures = [[!car car] [!cdr cdr]
                               [!cons cons] [!`+` `+`]
                               [!`-` `-`] [!`*` `*`] [!`/` `/`]
                               [!`null?` is_empty]];

function primitive_procedure_names() map(head primitive_procedures);
function primitive_procedure_objects() map(fn(proc) [!primitive head(tail(proc))] primitive_procedures);

function apply_primitive_procedure(proc args) apply(primitive_implementation(proc) args);

function setup_environment() 
    let (initial_env = extend_environment(primitive_procedure_names(),
                                          primitive_procedure_objects(),
                                          the_empty_environment))
    { define_variable(!true true initial_env);
      define_variable(!false false initial_env);
      initial_env };

define the_global_environment = setup_environment();

define input_prompt = ";;; M-Eval input:";
define output_prompt = ";;; M-Eval value:";

function driver_loop()
{ prompt_for_input(input_prompt);
  let (input = read()) 
      let (output = evaluate(input the_global_environment))
      { announce_output(output_prompt);
        user_print(output) };
  driver_loop() };
  
function prompt_for_input(string) { newline(); newline(); display(string); newline() };
function announce_output(string) { newline(); display(string); newline() };

function user_print(object) 
    if (is_compound_procedure(object)) 
        display([!compound_procedure procedure_parameters(object)
                 procedure_body(object)])
    else display(object);

// Exercise 4.21
(fn(n) (fn(fib) fib(fib n)) (fn(f k) if (k == 0) 0 else if (k == 1) 1 else f(f, k - 2) + f(f, k - 1)))(10); // => 55

// 4.1.7 Separating Syntactic Analysis from Execution
define evaluate_1 = evaluate;

function evaluate(exp env) let (e = analyze(exp)) { e(env) };

// Exercise 4.22
function analyze(exp) 
    if (is_self_evaluating(exp)) analyze_self_evaluating(exp)
    else if (is_quoted(exp)) analyze_quoted(exp)
    else if (is_variable(exp)) analyze_variable(exp)
    else if (is_assignment(exp)) analyze_assignment(exp)
    else if (is_definition(exp)) analyze_definition(exp)
    else if (is_if(exp)) analyze_if(exp)
    else if (is_lambda(exp)) analyze_lambda(exp)
    else if (is_begin(exp)) analyze_sequence(begin_actions(exp))
    else if (is_cond(exp)) analyze(cond_to_if(exp))
    else if (is_let(exp)) analyze(let_to_combination(tail(exp)))
    else if (is_application(exp)) analyze_application(exp)
    else error("Unknown expression type -- ANALYZE" exp);

function analyze_self_evaluating(exp) fn(env) exp;
function analyze_quoted(exp) let (qval = text_of_quotation(exp)) fn(env) qval;
function analyze_variable(exp) fn(env) lookup_variable_value(exp env);

function analyze_assignment(exp) 
    let (var = assignment_variable(exp)
         vproc = analyze(assignment_value(exp))) 
        fn(env) { set_variable_value(var vproc(env) env);
                  !ok };

function analyze_definition(exp) 
    let (var = definition_variable(exp)
         vproc = analyze(definition_value(exp))) 
        fn(env) { define_variable(var vproc(env) env);
                  !ok };

function analyze_if(exp) 
    let (pproc = analyze(if_predicate(exp))
         cproc = analyze(if_consequent(exp))
         aproc = analyze(if_alternative(exp))) 
        fn(env) if (is_true(pproc(env))) cproc(env) else aproc(env);

function analyze_lambda(exp) 
    let (vars = lambda_parameters(exp)
         bproc = analyze_sequence(lambda_body(exp))) 
        fn(env) make_procedure(vars bproc env);

function analyze_sequence(exps) 
{ function sequentially(proc1 proc2) fn(env) { proc1(env); proc2(env) };
    
  function loop(first_proc, rest_procs) 
      if (is_empty(rest_procs)) first_proc
      else loop(sequentially(first_proc head(rest_procs)), tail(rest_procs));

  let (procs = map(analyze exps)) 
      if (is_empty(procs)) error("Empty sequence -- ANALYZE")
      else loop(head(procs), tail(procs)) };

function analyze_application(exp) 
    let (fproc = analyze(operator(exp))
         aprocs = map(analyze operands(exp))) 
        fn(env) execute_application(fproc(env)
                                    map(fn(aproc) aproc(env) aprocs));

function execute_application(proc args) 
    if (is_primitive_procedure(proc)) apply_primitive_procedure(proc args)
    else if (is_compound_procedure(proc)) 
        (procedure_body(proc))(extend_environment(procedure_parameters(proc)
                                                  args
                                                  procedure_environment(proc)))
    else error("Unknown procedure type -- EXECUTE-APPLICATION" proc);
