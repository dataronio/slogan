// 4.1.1 The Core of the Evaluator
// In this implementation `eval` has been renamed to `evaluate` and `apply` to `fnapply`
// so that the original functions in Slogan is not rebound.

function evaluate(exp env) 
    if (is_self_evaluating(exp)) exp
    else if (is_variable(ex)) lookup_variable_value(exp env)
    else if (is_quoted(ex)) text_of_quotation(exp)
    else if (is_assignment(exp)) eval_assignment(exp env)
    else if (is_definition(exp)) eval_definition(exp env)
    else if (is_if(exp)) eval_if(exp env)
    else if (is_lambda(exp)) make_procedure(lambda_parameters(exp)
                                            lambda_body(exp)
                                            env)
    else if (is_begin(exp)) eval_sequence(begin_actions(exp) env)
    else if (is_cond(exp)) evaluate(cond_to_if(exp) env)
    else if (is_application(exp)) fnapply(evaluate(operator(exp) env)
                                          list_of_values(operands(exp) env))
    else error("Unknown expression type -- EVAL" exp);

function fnapply(procedure arguments) 
    if (is_primitive_procedure(procedure))
        apply_primitive_procedure(procedure arguments)
    else if (is_compound_procedure(procedure))
        eval_sequence(procedure_body(procedure)
                      extend_environment(procedure_parameters(procedure)
                                         arguments
                                         procedure_environment(procedure)))
    else error("Unknown procedure type -- APPLY" procedure);

function list_of_values(exps env) 
    if (has_no_operands(exps)) nil
    else evaluate(first_operand(exps) env):list_of_values(rest_operands(exps) env);

function eval_if(exp env) 
    if (is_true(evaluate(if_predicate(exp) env)))
        evaluate(if_consequent(exp) env)
    else evaluate(if_alternative(exp) env);

function eval_sequence(exps env) 
    if (is_last_exp(exps)) evaluate(first_exp(exps) env)
    else { evaluate(first_exp(exps) env);
           eval_sequence(rest_exps(exps) env) };

function eval_assignment(exp env) 
{ set_variable_value(assignment_variable(exp)
                     evaluate(assignment_value(exp) env)
                     env);
  !ok };

function eval_definition(exp env)
{ define_variable(definition_variable(exp)
                  evaluate(definition_value(exp) env)
                  env);
  !ok };

// Exercise 4.1
// left-right:
function list_of_values_lr(exps env) 
    if (has_no_operands(exps)) nil
    else let (e = evaluate(first_operand(exps) env)) 
        e:list_of_values(rest_operands(exps) env);

// right-left:
function list_of_values_rl(exps env) 
    if (has_no_operands(exps)) nil
    else let (es = list_of_values(rest_operands(exps) env)
              e = evaluate(first_operand(exps) env))
        e:es;

// 4.1.2 Representing Expressions
function is_tagged_list(exp tag) is_pair(exp) && is_eq(head(exp) tag);

function is_self_evaluating(exp) is_number(exp) || is_string(exp);
function is_variable(exp) is_symbol(exp);
function is_quoted(exp) is_tagged_list(exp, !quote);
function text_of_quotation(exp) head(tail(exp));

function is_assignment(exp) is_tagged_list(exp !`set!`);
function assignment_variable(exp) head(tail(exp));
function assignment_value(exp) head(tail(tail(exp)));

function is_definition(exp) is_tagged_list(exp !define);

function definition_variable(exp) 
    if (is_symbol(second(exp))) second(exp)
    else head(head(tail(exp)));
    
function definition_value(exp) 
    if (is_symbol(head(tail(exp)))) head(tail(tail(exp)))
    else make_lambda(tail(head(tail(exp))), tail(tail(exp)));

function is_lambda(exp) is_tagged_list(exp !lambda);
function lambda_parameters(exp) second(exp);
function lambda_body(exp) tail(tail(exp));
function make_lambda(parameters body) !lambda:(parameters:body);

function is_if(exp) is_tagged_list(exp !if);
function if_predicate(exp) second(exp);
function if_consequent(exp) third(exp);

function if_alternative(exp) 
    if (not(is_empty(nth_tail(3 exp))))
        head(nth_tail(3 exp))
    else false;

function make_if(predicate consequent alternative) [!if predicate consequent alternative];

function is_begin(exp) is_tagged_list(exp !begin);
function begin_actions(exp) tail(exp);
function is_last_exp(seq) is_empty(tail(seq));
function first_exp(seq) head(seq);
function rest_exps(seq) tail(seq);

function sequence_to_exp(seq) 
    if (is_empty(seq)) seq
    else if (is_last_exp(seq)) first_exp(seq)
    else make_begin(seq);

function make_begin(seq) !begin:seq;

function is_application(exp) is_pair(exp);
function operator(exp) head(exp);
function operands(exp) tail(exp);
function has_no_operands(ops) is_empty(ops);
function first_operand(ops) head(ops);
function rest_operands(ops) tail(ops);

function is_cond(exp) is_tagged_list(exp !cond);
function cond_clauses(exp) tail(exp);
function is_cond_else_clause(clause) is_eq(cond_predicate(clause) !else);
function cond_predicate(clause) head(clause);
function cond_actions(clause) tail(clause);
function cond_to_if(exp) expand_clauses(cond_clauses(exp));

function expand_clauses(clauses) 
    if (is_empty(clauses)) false
    else let (first = head(clauses)
              rest = tail(clauses)) 
        if (is_cond_else_clause(first)) 
            if (is_empty(rest)) sequence_to_exp(cond_actions(first))
            else error("ELSE clause isn't last -- COND->IF" clauses)
        else make_if(cond_predicate(first)
                     sequence_to_exp(cond_actions(first))
                     expand_clauses(rest));

// Exercises 4.4, 4.6, 4.7, 4.8
function evaluate(exp env) 
    if (is_self_evaluating(exp)) exp
    else if (is_variable(ex)) lookup_variable_value(exp env)
    else if (is_quoted(ex)) text_of_quotation(exp)
    else if (is_assignment(exp)) eval_assignment(exp env)
    else if (is_definition(exp)) eval_definition(exp env)
    else if (is_if(exp)) eval_if(exp env)
    else if (is_lambda(exp)) make_procedure(lambda_parameters(exp)
                                            lambda_body(exp)
                                            env)
    else if (is_begin(exp)) eval_sequence(begin_actions(exp) env)
    else if (is_cond(exp)) evaluate(cond_to_if(exp) env)
    else if (is_and(exp)) eval_and(tail(exp) env)
    else if (is_or(exp)) eval_or(tail(exp) env)
    else if (is_let(exp)) evaluate(let_to_combination(tail(exp)) env)
    else if (is_letseq(exp)) evaluate(letseq_to_lets(tail(exp)) env)
    else if (is_application(exp)) fnapply(evaluate(operator(exp) env)
                                          list_of_values(operands(exp) env))
    else error("Unknown expression type -- EVAL" exp);

function is_and(exp) is_tagged_list(exp !and);
function eval_and(exp env)
    if (is_empty(exp)) true
    else if (is_last_exp(exp)) evaluate(exp env)
    else let (r = evaluate(head(exp), env)) 
        if (not(is_true(r))) r
        else eval_and(tail(exp) env);

function is_or(exp) is_tagged_list(exp !or);
function eval_or(exp env) 
    if (is_empty(exp)) false
    else if (is_last_exp(exp)) evaluate(exp env)
    else let (r = evaluate(head(exp), env)) 
        if (not(is_true(r))) eval_or(tail(exp) env)
        else r;

// and as a derived expression:
function and_to_ifs(exp) 
    if (is_empty(exp)) true
    else if (is_last_exp(exp)) exp
    else make_if(head(exp) and_to_ifs(tail(exp)) false);

// or as derived expression:
function or_to_ifs(exp) 
    if (is_empty(exp)) false
    else if (is_last_exp(exp)) exp
    else make_if(not(head(exp)) or_to_ifs(tail(exp)) true);

function is_let(exp) is_tagged_list(exp !let);
function let_to_combination(exp) 
    let (vars = let_vars(exp)
         vals = let_vals(exp)) 
        if (is_symbol(first(exp)))
            [!begin [!define first(exp) make_lambda(vars let_body(exp))]
             append(first(exp) vals)]
        else append([[make_lambda(vars, let_body(exp))]] vals);

function let_vars(exp) {
    function iter(bindings, vars) 
        if (is_empty(bindings)) reverse(vars)
        else iter(tail(bindings) first(first(bindings)):vars);
    iter(if (is_symbol(first(exp))) second(exp) else first(exp))
};

function let_vals(exp) {
    function iter(bindings vals) 
        if (is_empty(bindings)) reverse(vals)
        else iter(tail(bindings) second(first(bindings)):vals);
    iter(if (is_symbol(first(exp))) second(exp) else first(exp))
};

function let_body(exp) if (is_symbol(first(exp))) third(exp) else second(exp);

function make_let(bindings body) [!let bindings body];

function is_letseq(exp) is_tagged_list(exp !`let*`);

function letseq_to_lets(exp) 
    let (vars = let_vars(exp)
         vals = let_vals(exp)) {
        function iter(vars vals) 
            if (is_empty(vars)) let_body(exp)
            else make_let([first(vars) first(vals)] iter(tail(vars) tail(vals)));
        iter(vars vals)
    };
