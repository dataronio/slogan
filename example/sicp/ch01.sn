// Exercises 1.7 and 1.8

function square(x) x * x;
function average(x, y) (x + y)/2;
function is_good_enough(guess, oldguess) abs(guess - oldguess) < guess * 0.001;

function rt_iter(guess, oldguess, x, improve)
{ if (is_good_enough(guess, oldguess)) guess
  else rt_iter(improve(guess, x), guess, x, improve) };

function sqrt_improve(guess, x) average(guess, x/guess);
function cubert_improve(guess, x) ((x/square(guess)) + 2 * guess) / 3;

function sqrt(x) rt_iter(1.0, 2.0, x, sqrt_improve);
function cubert(x) rt_iter(1.0, 2.0, x, cubert_improve);

// Exercise 1.11

function f(n) 
    if (n < 3) n
    else f(n-1) + (2 * f(n-2)) + (3 * f(n-3));

// f(n) as an iterative process:
function f_iter(n1, n2, n3, count) 
    if (count < 3) n1
    else f_iter(n1 + (2 * n2) + (3 * n3),
                n1, n2, count-1);

function f(n) 
    if (n < 3) n
    else f_iter(2, 1, 0, n);

// Exercise 1.12

function pascal_triangle(row, col)
    if (col > row) 0
    else if (col < 0) 0
    else if (col == 1) 1
    else pascal_triangle(row - 1, col - 1) + pascal_triangle(row - 1, col);
    
// Exercise 1.16

function expt_iter(b, n, a)
    if (n == 0) a
    else if (is_even(n)) expt_iter(square(b), n/2, a)
    else expt_iter(b, n-1, a*b);

function fast_expt(b, n) expt_iter(b, n, 1);

// Exercise 1.17

/* Solution is based on the following observations:
     
      a * b = 2 * (a * b/2) if `b` is even
      a * b = a + a * (b - 1) if `b` is odd
*/

function double(x) x + x;
function halve(x) x / 2;

function fast_mult(a, b) 
    if (b == 0) 0
    else if (b == 1) a
    else if (is_even(b)) double(fast_mult(a, halve(b)))
    else a + fast_mult(a, b - 1);


// Exercise 1.18

function mult_iter(a, b, r) 
    if (b == 0) r
    else if (is_even(b)) mult_iter(double(a), halve(b), r)
    else mult_iter(a, b - 1, a + r);

function fast_mult(a, b) mult_iter(a, b, 0);

// Exercise 1.19

function fib (n) fib_iter(1 0 0 1 n);

function fib_iter(a, b, p, q, count) 
    if (count == 0) b
    else if (is_even(count)) fib_iter(a, b, p*p + q*q, 2*p*q + q*q, count/2)
    else fib_iter(b*q + a*q + a*p, b*p + a*q, p, q, count-1);

// Exercise 1.29

function sum(term a next b) 
    if (a > b) 0
    else term(a) + sum(term, next(a), next, b);

function cube (x) mult(x, x, x);

function simpson(f a b n)
{ let h = (b - a) / n;
  function y(k) f(a + k * h);
  function term(k) 
  (if (is_odd(k)) 4
   else if (is_zero(k) || k == n) 1
   else if (is_even(k)) 2) * y(k);
  (h * sum(term, 0, inc, n))/3 };

// Exercise 1.30

function sum(term a next b) 
{ function iter(a result) 
    if (a > b) result
    else iter(next(a), result + term(a));
  iter(a, 0) };

// Exercise 1.31

function product(term, a, next, b) 
    if (a > b) 1
    else term(a) * product(term, next(a), next, b);

function factorial(x) product(identity, 1, inc, x);

// An iterative version of product.
function product(term, a, next, b) 
{ function iter(a, result) 
    if (a > b) result
    else iter(next(a), result * term(a));
  iter(a, 1) };

// Exercise 1.32

function accumulate(combiner, null_value, term, a, next, b) 
    if (a > b) null_value
    else combiner(term(a), accumulate(combiner, null_value, term, next(a), next, b));

function sum(term, a, next, b) accumulate(`+`, 0, term, a, next, b);
function product(term, a, next, b) accumulate(`*`, 1, term, a, next, b);

// An iterative version of accumulate.
function accumulate(combiner, null_value, term, a, next, b) 
{ function iter(a, result) 
    if (a > b) result
    else iter(next(a), combiner(result, term(a)));
    iter(a, null_value) };

// Exercise 1.33

function filtered_accumulate(filter, combiner, null_value, term, a, next, b) 
    if (a > b) null_value 
    else if (filter(a)) combiner(term(a), filtered_accumulate(filter, combiner, null_value, term, next(a), next, b))
    else filtered_accumulate(filter, combiner, null_value, term, next(a), next, b);

function square_primes(a, b) filtered_accumulate(is_prime, `+`, 0, square, a, inc, b);

function product_coprimes(n) 
{ function is_coprime(i) 1 == gcd(i n);
  filtered_accumulate(is_coprime, `*`, 1, identity, 1, inc, n-1) };

// Section 1.3.3

function search(f, negpoint, pospoint) 
    let (midpoint = average(negpoint, pospoint)) 
        if (is_close_enough(negpoint, pospoint)) midpoint
        else let (test_value = f(midpoint)) 
            if (is_positive(test_value)) search(f, negpoint, midpoint)
            else if (is_negative(test_value)) search(f, midpoint, pospoint)
            else midpoint;

function is_close_enough(x, y) abs(x-y) < 0.001;

function half_interval_method(f, a, b) 
    let (a_value = f(a), b_value = f(b)) 
        if (is_negative(a_value) && is_positive(b_value)) search(f, a, b)
        else if (is_negative(b_value) && is_positive(a_value)) search(f, b, a)
        else error("Values are not of opposite sign", a, b);

let tolerance = 0.00001;

// Exercise 1.35

function fixed_point(f, firstguess) 
{ function is_close_enough(v1, v2) abs(v1 - v2) < tolerance;
    function tryit(guess)
      let (next = f(guess)) 
        if (is_close_enough(guess, next)) next
        else tryit(next);
  tryit(firstguess) };

fixed_point (fn(x) 1 + 1/x, 2.0); // => 1.6180327868852458

// Exercise 1.36

function fixed_point(f, firstguess) 
{ function is_close_enough(v1, v2) abs(v1 - v2) < tolerance;
    function tryit(guess) 
    { showln(guess);
      let (next = f(guess)) 
        if (is_close_enough(guess, next)) next
        else tryit(next) };
  tryit(firstguess) };

fixed_point(fn(x) log(1000)/log(x), 2.0);
// With average damping:
fixed_point(fn(x) average(x, log(1000)/log(x)), 2.0);

// Exercise 1.37

function cont_frac(n, d, k) 
{  function frac(i) 
     if (i < k) n(i) / (d(i) + frac(i+1))
     else n(i)/d(i);
   frac(1) };

// Iterative version:

function cont_frac(n, d, k) 
{ function frac_iter(i, result) 
    if (i == 0) result
    else frac_iter(i-1, n(i)/(d(i) + result));
  frac_iter(k-1, n(k)/d(k)) };

// Exercise 1.38

function d(i) 
    if (not(is_zero(remainder(i+1, 3)))) 1
    else 2 * (inc(i)/3);

let e = 2 + cont_frac(fn(i) 1.0, d, 10);

// Exercise 1.39

function tan_cf(x k) 
{ function n(k) 
    if (k == 1) x
    else -(square(x));
  function d(k) dec(2 * k);
  cont_frac(n d k) };

// Exercise 1.40

let dx = 0.00001;
function deriv(g) fn(x) (g(x+dx) - g(x)) / dx;
function newton_transform(g) fn(x) x - g(x)/(deriv(g))(x);
function newtons_method(g guess) fixed_point(newton_transform(g), guess);

function cubic(a b c) fn(x) add(x*x*x, a*x*x, b*x, c);
newtons_method(cubic(3, -2.4, 6), 1); // => -3.9813366488305104

// Exercise 1.41

function double(f) fn(x) f(f(x));
((double(double(double)))(inc))(5); // => 21

// Exercise 1.42

function compose(f, g) fn(x) f(g(x));

// Exercise 1.43

// Using compose:
function repeated(f, n) 
    if (n == 1) f
    else compose(f, repeated(f, n - 1));

// Using iteration:
function repeated(f, n) 
{ fn iter(n, x) 
   if (is_zero(n)) x
   else iter(n-1, f(x));
  fn(x) iter(n-1, f(x)) };

// Exercise 1.44

function smooth(f dx) fn(x) add(f(x), f(x + dx), f(x - dx))/3;
function n_fold_smooth(f dx n) repeated(smooth(f dx), n);

(n_fold_smooth(sin,0.7,2))(3.14/2); // => .6297174613198419

// Exercise 1.46

function iterative_improve(is_good_enough, improve) 
{ function iter_imp(guess) 
    if (is_good_enough(guess)) guess
    else iter_imp(improve(guess));
  iter_imp };

function sqrt(x) 
    (iterative_improve(fn(guess) abs(square(guess)-x) < 0.001,
                       fn(guess) average(guess, x/guess)))(1.0);

function fixed_point(f firstguess) 
    (iterative_improve(fn(guess) abs(f(guess) - guess) < 0.00001,
                       fn(guess) f(guess)))(firstguess);
