// Exercise 3.1
function make_accumulator(n) fn(v) { n = n + v; n };

// Exercise 3.2
function make_monitored(f) 
    let (count = 0) 
        fn(arg) 
            match(arg) 
                !how_many_calls? -> count,
                !reset_count -> count = 0,
                _ -> { count = count + 1; f(arg) };

// Exercise 3.3
function make_account(balance, password) {
    function withdraw(amount, pswd) 
        if (pswd == password) 
            if (balance >= amount) {
                balance = balance - amount;
                balance
            } else "Insufficient funds"
        else error("Incorrect password");
    
    function deposit(amount, pswd) 
        if (pswd == password) {
            balance = balance + amount;
            balance
        } else error("Incorrect password");
    
    function dispatch(m) 
        match(m) 
            !withdraw -> withdraw,
            !deposit -> deposit,
            _ -> error("Unknown request -- MAKE_ACCOUNT" m);
    dispatch
};

// Exercise 3.4
function make_account(balance, password) {

    define incorrect_attempts = 0;

    function call_the_cops() "Cops called!";
    
    function check_incorrect_attempts() 
        if (incorrect_attempts >= 7) call_the_cops()
        else { incorrect_attempts = incorrect_attempts + 1;
               "Incorrect password" };
        
    function withdraw(amount, pswd) 
        if (pswd == password) {
            incorrect_attempts = 0;
            if (balance >= amount) {
                balance = balance - amount;
                balance
            } else "Insufficient funds"
        } else check_incorrect_attempts();
    
    function deposit(amount, pswd) 
        if (pswd == password) {
            incorrect_attempts = 0;
            balance = balance + amount;
            balance
        } else check_incorrect_attempts();
    
    function dispatch(m) 
        match(m) 
            !withdraw -> withdraw,
            !deposit -> deposit,
            _ -> error("Unknown request -- MAKE_ACCOUNT" m);
    dispatch
};

// Exercise 3.5
function monte_carlo(trials, experiment) {
    function iter(trials_remaining, trials_passed) 
        if (trials_remaining == 0) trials_passed/trials
        else if (experiment) iter(trials_remaining - 1, trials_passed + 1)
        else iter(trials_remaining - 1, trials_passed);
    iter(trials, 0)
};

function random_in_range(low, high) let (range = high - low) low + random_integer(range);

function P(x, y) expt(x - 5, 2) + expt(y - 7, 2) < expt(3, 2);

function estimate_integral(P, x1, x2, y1, y2, trials) {
    function experiment() P(random_in_range(x1, x2), random_in_range(y1, y2));
    monte_carlo(trials, experiment)
};

// Exercise 3.6
function make_rand(x) {
    fn reset(newx) x = newx;
    let (a = expt(2 32), c = 1103515245, m = 12345) 
        fn(msg) 
            match(msg) 
                !generate -> { x = mod(a * x + c, m);
                               x },
                !reset -> reset,
                _ -> error("not a valid message - rand", msg)
};

// Exercise 3.7
function make_account(balance, password) 
    let (passwords = [password]) {
        function withdraw(amount, pswd) 
            if (member(pswd, passwords))
                if (balance >= amount) {
                    balance = balance - amount;
                    balance
                } else "Insufficient funds"
            else error("Incorrect password");
    
        function deposit(amount, pswd) 
            if (member(pswd, passwords)) {
                balance = balance + amount;
                balance
            } else error("Incorrect password");

        function add_password(old_pswd, pswd) 
            if (member(old_pswd, passwords)) passwords = append(passwords, [pswd])
            else error("Incorrect password");
                
        function dispatch(m) 
            match(m) 
              !withdraw -> withdraw,
              !deposit -> deposit,
              !add_password -> add_password,  
               _ -> error("Unknown request -- MAKE_ACCOUNT" m);
                
        dispatch
    };        

function make_joint(account, pswd, new_pswd) {
    account.add_password(pswd, new_pswd);
    account
};

// Exercise 3.8
define f = let (state = 0) fn(x) let (s = state) { state = state + x; s };
`+`(f(0), f(1)); // will evaluate to 0 if `+` evaluates its arguments left-right, 1 otherwise.

// Exercise 3.17
function count_pairs(x) 
    let (counted = []) {
        fn iter(x) 
            if (not(is_pair(x))) 0
            else if (memq(x, counted)) 0
            else { counted = pair(x, counted);
                   inc(iter(head(x)) + iter(tail(x)))
                 };
        iter(x)
    };

// Exercise 3.18
function has_cycle(x) 
    let (visited = []) {
        fn iter(x) 
            if (is_empty(x)) false
            else if (memq(tail(x), visited)) true
            else { visited = pair(x visited);
                   iter(tail(x)) };
        iter(x)
    };

// Exercise 3.19
function has_cycle(x) {
    fn iter(a b) 
        if (not(is_pair(a))) false
        else if (not(is_pair(b))) false
        else if (is_eq(a b)) true
        else if (is_eq(a tail(b))) true
        else iter(tail(a) tail(tail(b)));
    iter(tail(x) tail(tail(x)))
};

// 3.3.2 Representing Queues
function front_ptr(queue) head(queue);
function rear_ptr(queue) tail(queue);
function set_front_ptr(queue item) set_head(queue item);
function set_rear_ptr(queue item) set_tail(queue item);

function is_empty_queue(queue) is_empty(front_ptr(queue));
function make_queue() []:[];

function front_queue(queue) 
    if (is_empty_queue(queue)) error("FRONT called with an empty queue" queue)
    else head(front_ptr(queue));

function insert_queue(queue item) 
    let (new_pair = item:[]) 
    { if (is_empty_queue(queue))
      { set_front_ptr(queue new_pair);
        set_rear_ptr(queue new_pair) }
      else { set_tail(rear_ptr(queue) new_pair);
             set_rear_ptr(queue new_pair) };
      queue };
    
function delete_queue(queue) 
    if (is_empty_queue(queue)) error("DELETE! called with an empty queue" queue)
    else { set_front_ptr(queue tail(front_ptr(queue)));
           queue };

// Exercise 3.21
function print_queue(queue) showln(front_ptr(queue));

// Exercise 3.22
function make_queue() 
    let (front_ptr = [],
         rear_ptr = []) 
        { function set_front_ptr(item) front_ptr = item;
          function set_rear_ptr(item) rear_ptr = item;
          function is_empty_queue() is_empty(front_ptr);
          
          function front_queue() 
              if (is_empty_queue()) error("FRONT called with an empty queue")
              else head(front_ptr);
          
          function insert_queue(item)
              let (new_pair = item:[]) 
              { if (is_empty_queue())
                { set_front_ptr(new_pair);
                  set_rear_ptr(new_pair) }
                else { set_tail(rear_ptr new_pair);
                       set_rear_ptr(new_pair) };
                front_ptr:rear_ptr };
    
          function delete_queue() 
              if (is_empty_queue()) error("DELETE! called with an empty queue")
              else { set_front_ptr(tail(front_ptr));
                     front_ptr:rear_ptr };

          function dispatch(message) 
              match(message) 
                  !front -> front_queue,
                  !insert -> insert_queue,
                  !delete -> delete_queue,
                  _ -> error("DISPATCH invalid message" message);
        dispatch };

// Exercise 3.23
function make_deque() []:[];
function front_ptr(deque) head(deque);
function rear_ptr(deque) tail(deque);
function is_empty_deque(deque) is_empty(front_ptr(deque));
function set_front(deque item) set_head(deque item);
function set_rear(deque item) set_tail(deque item);

function get_item(deque end) 
    if (is_empty_deque(deque)) error("Trying to retrieve item from empty deque" deque)
    else head(head(end(deque)));

function insert_deque(deque item end) 
    let (new_pair = (item:[]):[])
      if (is_empty_deque(deque))
      { set_front(deque new_pair);
        set_rear(deque new_pair) }
      else if (is_eq(end !front))
      { set_tail(new_pair front_ptr(deque));
        set_tail(head(front_ptr(deque)) new_pair);
        set_front(deque new_pair) }
      else { set_tail(rear_ptr(deque) new_pair);
             set_tail(head(new_pair) rear_ptr(deque));
             set_rear(deque new_pair) };
      
function front_delete_deque(deque) 
    if (is_empty_deque(deque)) error("Cannot delete from empty deque" deque)
    else { set_front(deque tail(front_ptr(deque)));
           is_empty_deque(deque) || set_tail(head(front_ptr(deque)) []) };
      
function rear_delete_deque(deque) 
    if (is_empty_deque(deque)) error("Cannot delete from empty deque" deque)
    else { set_rear(deque cdar(rear_ptr(deque)));
           if (is_empty(rear_ptr(deque))) set_front(deque [])
           else set_tail(rear_ptr(deque) []) };
      
function front_insert_deque(deque item) insert_deque(deque item !front);
function rear_insert_deque(deque item) insert_deque(deque item !rear);
function front_deque(deque) get_item(deque front_ptr);
function rear_deque(deque) get_item(deque rear_ptr);

// Exercise 3.24
function make_table(is_same_key)
{ function assoc(key records) 
    if (is_empty(records)) false
    else if (is_same_key(key, head(head(records)))) head(records)
    else assoc(key tail(records));

  let (local_table = [!`*table*`])
  { function lookup(key) assoc(key tail(local_table));

    function insert(key value)
        let (rec = assoc(key tail(local_table))) 
          if (rec) !ok
          else { set_tail(local_table, (key:value):tail(local_table));
                 !ok };

    function dispatch(message)
        match(message) 
            !lookup -> lookup,
            !insert -> insert,
        _ -> error("Unknown operation -- TABLE" m);
            
    dispatch }};

// Exercise 3.25
// The solution for Exercise 3.24 already works for this.
define table = make_table(is_equal);

// Exercise 3.26
function make_tree_node(key value left right) [key:value, left:right];
function make_empty_node() [nil:nil, nil:nil];
function node_key(node) head(head(node));
function node_value(node) tail(head(node));
function node_left(node) head(tail(node));
function node_right(node) tail(tail(node));
function node_set_key(node key) set_head(head(node), key);
function node_set_value(node value) set_tail(head(node), value);
function node_set_left(node left) set_head(tail(node), left);
function node_set_right(node right) set_tail(tail(node), right);
function node_is_empty(node) is_empty(node_key(node));

function make_tree() make_empty_node();
function tree_insert(tree key value cmpr) 
   if (node_is_empty(tree))
   { node_set_key(tree, key); node_set_value(tree, value);
     node_set_left(tree, make_empty_node()); node_set_right(tree, make_empty_node()) }
   else letseq (n = tree, c = cmpr(key, node_key(n)))
        match (c) 
            0 -> node_set_value(n value),
            1 -> tree_insert(node_right(n), key, value, cmpr),
           -1 -> tree_insert(node_left(n), key, value, cmpr);

function tree_lookup(tree key cmpr) 
    if (node_is_empty(tree)) false
    else letseq (n = tree, c = cmpr(key, node_key(n))) 
        match (c) 
            0 -> node_value(n),
            1 -> tree_lookup(node_right(n), key, cmpr),
           -1 -> tree_lookup(node_left(n), key, cmpr);
                 
function make_table(key_compare)
{ let (table = make_tree()) 
  { function insert(key value) tree_insert(table key value key_compare);
    function lookup(key) tree_lookup(table key key_compare);

    function dispatch(message) 
        match (message) 
            !insert -> insert,
            !lookup -> lookup,
            _ -> error("dispatch - invalid message" message);

    dispatch }};

// 3.5.1 Streams Are Delayed Lists
function stream_enumerate_interval(low high) 
    if (low > high) nil
    else low::stream_enumerate_interval(low + 1, high);

first(rest(filter(is_prime, stream_enumerate_interval(10000 1000000)))); // =? 10009

// Exercise 3.50
function stream_map(proc @rest argstreams) 
    if (is_empty(first(argstreams))) nil
    else apply(proc map(first argstreams))::apply(stream_map proc:map(rest argstreams));

// Exercise 3.54
function mul_streams(s1 s2) stream_map(`*` s1 s2);
function integers(n) n::integers(n+1);
define factorials = 1::mul_streams(factorials integers(2));

// Exercise 3.55
function add_streams(s1 s2) stream_map(`+` s1 s2);
function partial_sums(s) first(s)::add_streams(rest(s) partial_sums(s));

// Exercise 3.64
function stream_limit(stream tolerance) 
    if (abs(second(stream) - first(stream)) < tolerance) first(stream)
    else stream_limit(rest(stream) tolerance);

