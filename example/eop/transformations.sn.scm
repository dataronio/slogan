(define distance (lambda (x y f #!optional (eq is_equal)) (letrec ((dist_helper (lambda (x y n) (if (eq x y) n (dist_helper (f x) y (+ n 1)))))) (dist_helper x y 0))))
(define collision_point (lambda (x f p #!optional (eq is_equal)) (if (not (p x)) x (letrec ((loop (lambda (slow fast) (if (not (eq slow fast)) (if (not (p fast)) fast (let () (set! fast (f fast)) (if (p fast) (loop (f slow) (f fast)) fast))))))) (loop x (f x))))))
(define always_true (lambda (x) (begin #t)))
(define collision_point_nonterminating_orbit (lambda (x f #!optional (eq is_equal)) (collision_point x f always_true is_eq)))
(define is_terminating (lambda (x f p #!optional (eq is_equal)) (not (p (collision_point x f p eq)))))
(define is_circular_nonterminating_orbit (lambda (x f #!optional (eq is_equal)) (eq x (f (collision_point_nonterminating_orbit x f eq)))))
(define is_circular (lambda (x f p #!optional (eq is_equal)) (let ((y (collision_point x f p eq))) (and (p y) (eq x (f y))))))
(define convergent_point (lambda (x0 x1 f #!optional (eq is_equal)) (letrec ((loop (lambda (x0 x1) (if (eq x0 x1) x0 (loop (f x0) (f x1)))))) (loop x0 x1))))
(define connection_point_nonterminating_orbit (lambda (x f #!optional (eq is_equal)) (convergent_point x (f (collision_point_nonterminating_orbit x f eq)) f eq)))
(define connection_point (lambda (x f p #!optional (eq is_equal)) (let ((y (collision_point x f p eq))) (if (not (p y)) y (convergent_point x (f y) f eq)))))
