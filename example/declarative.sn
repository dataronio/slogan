// Examples of declarative programming in Slogan, mostly based 
// on code from "Concepts, Techniques, and Models of Computer Programming".

// Local functions:
var sqrt = let improve = function (guess, x) (guess + x / guess) / 2.0,
               good_enough = function (guess, x) (abs (x - guess * guess)) / x < 0.00001
           letrec sqr_iter = function (x, guess)
                               if good_enough (guess, x) guess
                               else sqr_iter (x, improve (guess,x))
           function (x) sqr_iter (x, 1.0);

// Loop abstraction with higher-order function:
var iterate = function (s, is_done, transform) {
    if is_done (s) s
    else iterate (transform (s), is_done, transform)
};

// sqrt using the loop abstraction:
var sqrt_with_iter = function (x) {
    iterate (1.0, 
             function (guess) { (abs (x - guess * guess)) / x < 0.00001 },
             function (guess) { (guess + x / guess) / 2.0 })
};

// Merge-sort:
var merge = function (xs, ys) {
    if is_empty (xs) && not (is_empty (ys)) ys
    else if is_empty (ys) && not (is_empty (xs)) xs
    else if head (xs) < head (ys) [head (xs) merge (tail (xs), ys)]
    else [head (ys) merge (xs, tail (ys))]
};

var split = function (xs) {
    letrec split_helper = function (xs, ys, zs) {
        if is_empty (xs) [ys zs]
        else if length (xs) == 1 [[head (xs) ys] zs]
        else split_helper (tail (tail (xs)), [head (xs) ys], [head (tail (xs)) zs])
    }
    split_helper (xs, [], [])
};

var merge_sort = function (xs) {
    if is_empty (xs) || length (xs) == 1 xs
    else let parts = split (xs)
    merge (merge_sort (head (parts)), merge_sort (tail (parts)))
};

// Integer loops:
var for = function (start, end, step, do) {
    let cmpr = if step > 0 is_number_lteq else is_number_gteq
    letrec loop = function (i) if cmpr (i, end) { do (i); loop (i + step) }
    loop (start)
};

// List loop (same as the built-in for_each):
var for_all = function (ls, do) {
    if not (is_empty (ls)) {
        do (head (ls));
        for_all (tail (ls), do)
    }
};

// List fold operations, same as the built-in reduce function.
var foldl = function (lst, fn, init) {
    if is_empty (lst) init
    else foldl (tail (lst), fn, fn (init, head (lst)))
};

var foldr = function (lst, fn, init) {
    foldl (reverse (lst), fn, init)
};

var good_reverse = function (lst) {
    letrec rev = function (lst, acc) {
        if is_empty (lst) acc
        else rev (tail (lst), pair (head (lst), acc))
    } rev (lst, [])
};

// Amortized constant-time ephemeral queue

var new_queue = function () [[] []];

var queue_check = function (q)
    if is_empty (head (q)) [reverse (tail (q)) []]
    else q;

var queue_insert = function (q, e) 
    queue_check ([head (q) [e tail (q)]]);

var queue_delete = function (q)
    let q = queue_check (q)
    if is_empty (head (q)) q
    else [tail (head (q)) tail (q)];
    