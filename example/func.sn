var shift_left = function (lst)
    if is_empty (lst) [0]
    else [head (lst) shift_left (tail (lst))];

var shift_right = function (lst) [0 lst];

var add_list = function (lst1, lst2) map (add, lst1, lst2);

// Generates Pascal's triangle
var pascal = function (n)
    if n == 1 [1]
    else let m = pascal (n - 1)
         add_list (shift_left (m), shift_right (m));

// lazy integer stream.
var int_stream = function (n) [n delay (int_stream (n + 1))];

var ints = function (i)
    if is_integer (i) int_stream (i)
    else force (tail (int_stream (head (i))));

println(head (ints (ints (ints (10))))); // => 12

var pascal_stream = function (row)
    [row delay (pascal_stream (add_list (shift_left (row), shift_right (row))))];

println (force (tail (force (tail (force (tail (pascal_stream ([1])))))))); // => [[1, 3, 3, 1] #<promise #...>]

// function as object

var counter = let c = 0
              function () { c = c + 1; c };

println (counter ()); // => 1
println (counter ()); // => 2

// function as an "object factory" or a "class".

var make_counter = function (n)
    let c = n
    function (msg)
        case msg {
            !bump: { c = c + 1 }
            !read: c
            else: error ("invalid message. ", msg)
        };

var c1 = make_counter (1);
var c5 = make_counter (5);
c1.bump;
c1.bump;
println (c1.read); // => 3
c5.bump;
println (c5.read); // => 6

// secure ADTs.

var wrapper = function ()
    let key = gensym ()
    let wrap = function (value) function (k) if k == key value else false
    let unwrap = function (w) w (key)
    function (msg)
    case msg {
        !wrap: wrap
        !unwrap: unwrap
        else: error ("invalid message. ", msg)
    };

var secure_stack = 
    let w = wrapper ()
    let new_stack = function () w.wrap ([])
    let push = function (s, e) w.wrap ([e w.unwrap (s)])
    let top = function (s) let stk = w.unwrap (s) 
                           if not (is_empty (stk)) head (stk)
                           else false
    let pop = function (s) let stk = w.unwrap (s)
                           if not (is_empty (stk)) w.wrap (tail (stk))
                           else false
    let is_stk_empty = function (s) is_empty (w.unwrap (s))
    function (msg)
    case msg {
        !new: new_stack
        !push: push
        !pop: pop
        !top: top
        !is_empty: is_stk_empty
        else: error ("invalid message. ", msg)
    };

// testing secure_stack:

var ss = secure_stack.new ();
ss = secure_stack.push (ss, 10);
ss = secure_stack.push (ss, 20);
println (secure_stack.top (ss)); // => 20
ss = secure_stack.pop (ss);
println (secure_stack.top (ss)); // => 10
ss = secure_stack.pop (ss);
println (secure_stack.top (ss)); // => false

// currying:

var sum = function(fn, a, b) {
    letrec loop = function(a, acc)
    if a > b acc
    else loop (a + 1, acc + fn (a))
    loop (a, 0)
};

var sum_sqrts = function(a, b) sum(sqrt, a, b);
println (sum_sqrts (10,20)); // => 42.35997728538408

// sum function redefined for currying:
sum = function (fn) {
    function (a, b) {
        letrec loop = function (a, acc)
        if a > b acc
        else loop (a + 1, acc + fn (a))
        loop (a, 0)
    }
};

println (sum (sqrt) (10 ,20)); // => 42.35997728538408

var map_reduce = function (fn, combiner, unit) {
    function (a, b) {
        if a > b unit
        else combiner (fn (a), map_reduce (fn, combiner, unit) (a + 1, b))
    }
};

sum = function (fn) {
    function (a, b) {
        map_reduce (fn, add, 0) (a, b)
    }
};

var product = function (fn) {
    function (a, b) {
        map_reduce (fn, mult, 1) (a, b)
    }
};

println (sum (sqrt) (10, 20)); // => 42.35997728538408
println (product (sqrt) (10, 20)); // => 2589290.5839244844