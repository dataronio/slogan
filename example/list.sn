var lst = pair ("a", "b");
println (head (lst));
println (tail (lst));
lst = pair ([1, 2, 3], "hello, world");
println (head (lst));
println (tail (lst));

letrec list_copy = function (ls) 
   if is_empty (ls) [] else pair (head (ls), list_copy (tail (ls)))
println (list_copy ([1, 2, 3])); // [1, 2, 3]

println (map (function (x) x * x, [1, 2, 3, 4, 5])); // => [1, 4, 9, 16, 25]

lst = [1, 89, 0, 100, 23];
println (sort (lst)); // => [0, 1, 23, 89, 100]

lst = ['f', 'a', 'e', 'x'];
println (sort (lst, test = char_is_lt)); // => [a, e, f, x]

// trees as lists.

var count_leaves = function (tree) {
    if is_empty (tree) 0
    else if not (is_pair (tree)) 1
    else count_leaves (head (tree)) + count_leaves (tail (tree))
};

var fringe = function (tree) {
    letrec helper = function (tree, result) {
        if is_empty (tree) reverse (result)
        else if not (is_pair (tree)) pair (tree, result)
        else append (helper (head (tree), result), helper (tail (tree), result))
    }
    helper (tree, [])
};

// tests:
var tree = [[1, 2], [3, 4]];
println (length (tree)); // => 2
println (count_leaves (tree)); // => 4

println (fringe (tree)); // => [1, 2, 3, 4]
println (fringe ([tree, tree])); // => [1, 2, 3, 4, 1, 2, 3, 4]

// binary mobiles (SICP Exercise 2.29)

var make_branch = function (length, structure) [length, structure];
var branch_length = function (branch) head (branch);
var branch_structure = function (branch) head (tail (branch));
var branch_weight = function (branch) {
    if is_pair (branch_structure (branch)) total_weight (branch_structure (branch))
    else branch_structure (branch)
};
var branch_torque = function (branch) branch_length (branch) * branch_weight (branch);
var is_branch_balanced = function (branch) {
    if is_pair (branch_structure (branch)) is_balanced (branch_structure (branch))
    else true
};

var make_mobile = function (left, right) [left, right];
var left_branch = function (mobile) head (mobile);
var right_branch = function (mobile) head (tail (mobile));
var total_weight = function (mobile) branch_weight (left_branch (mobile)) + branch_weight (right_branch (mobile));
var is_balanced = function (mobile) {
    and (branch_torque (left_branch (mobile)) == branch_torque (right_branch (mobile)),
         is_branch_balanced (left_branch (mobile)),
         is_branch_balanced (right_branch (mobile)))
};

// tests:
var a = make_mobile (make_branch (2, 3), make_branch (2, 3));
var b = make_mobile (make_branch (2, 3), make_branch (4, 5));
println (total_weight (a)); // => 6
println (total_weight (b)); // => 8
println (is_balanced (a)); // => true
println (is_balanced (b)); // => false

var c = make_mobile (make_branch (5, a), make_branch (3, b));
println (total_weight (c)); // => 14
println (is_balanced (c)); // => false

var foldr = function (op, initial, seq) {
    if is_empty (seq) initial
    else op (head (seq), foldr (op, initial, tail (seq)))
};

var foldl = function (op, initial, seq) {
    if is_empty (seq) initial
    else foldl (op, op (initial, head (seq)), tail (seq))
};

// list reverse using foldr and foldl:
var rev_r = function (seq) foldr (function (x, y) append (y, [x]), [], seq);
var rev_l = function (seq) foldl (function (x, y) [y x], [], seq);
