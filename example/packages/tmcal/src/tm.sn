module tm (now, resolution, is_eq:time_is_eq, is_gt, is_lt,
           is_gteq, is_lteq, difference, add_duration,
           subtract_duration, time_tai_to_utc, time_utc_to_tai,
           time_monotonic_to_utc, time_monotonic_to_tai,
           time_utc_to_monotonic, time_tai_to_monotonic,
           make_date, date_set_nanosecond, date_set_second,
           date_set_hour, date_set_minute, date_set_day,
           date_set_month, date_set_year, date_set_zone_offset)
{
  // Types of time
  let TIME_TAI = !time_tai;
  let TIME_UTC = !time_utc;
  let TIME_MONOTONIC = !time_monotonic;
  let TIME_PROCESS = !time_process;
  let TIME_DURATION = !time_duration;

  let nano = expt(10, 9);
  let sid = 86400;    // seconds in a day
  let sihd = 43200; // seconds in a half day
  let tai_epoch_in_jd = 4881175/2; // julian day number for 'the epoch'

  // Read and parse the file named `filename` into a table of leapseconds.
  // ftp://maia.usno.navy.mil/ser7/tai-utc.dat can be a valid and uptodate input.
  function read_tai_utc_data(filename)
    let (convjd = ^(jd) (exact(jd) - tai_epoch_in_jd) * sid
         convsec = ^(sec) exact(sec)
         input = file_reader(filename))
      let loop (line = read_line(input), table = [])
       if (is_eof_object(line)) table
       else let (data = read(string_reader(string_append("(", line, ")"))))
             let (year = first(data), jd = nth(4, data), secs = nth(6, data))
               loop(read_line(input), if (year >= 1972) (convjd(jd):convsec(secs)):table
                                      else table);

  // each entry is ( utc seconds since epoch . # seconds to add for tai )
  // note they go higher to lower, and end in 1972.
  // updated from ftp://maia.usno.navy.mil/ser7/tai-utc.dat in May-2016.
  let leap_second_table =
  [1435708800:36,
   1341100800:35,
   1230768000:34,
   1136073600:33,
   915148800:32,
   867715200:31,
   820454400:30,
   773020800:29,
   741484800:28,
   709948800:27,
   662688000:26,
   631152000:25,
   567993600:24,
   489024000:23,
   425865600:22,
   394329600:21,
   362793600:20,
   315532800:19,
   283996800:18,
   252460800:17,
   220924800:16,
   189302400:15,
   157766400:14,
   126230400:13,
   94694400:12,
   78796800:11,
   63072000:10];

  function update_leap_second_table(filename) leap_second_table = read_tai_utc_data(filename);

  let lsmin = (1972 - 1970) * 365 * sid;

  function leap_second_delta(utc_seconds)
   if (utc_seconds < lsmin) 0
   else tail(head(memp(^(lse) utc_seconds >= head(lse), leap_second_table)));

  // going from tai seconds to utc seconds ... 
  function leap_second_neg_delta(tai_seconds)
   if (tai_seconds < lsmin) 0
   else or(tail(head(memp(^(lse) (tail(lse) <= tai_seconds - head(lse)), leap_second_table))), 0);

  record ttime(type, nanosecond, second);
  let make_time = make_ttime;

  function copy_time(t)
   ttime(type = ttime_type(t),
         nanosecond = ttime_nanosecond(t),
         second = ttime_second(t));

  // These functions are used to decode the current system time encoded as a real number.
  function systime_nanosecs(t) floor((t - floor(t)) * nano);

  // Get the current system time encoded as a real number with second and nanosecond parts.
  // This value is retrieved by calling the  gambit functions `current-time` and `time->seconds`
  // and represents the UTC time. Return a pair of seconds and nanoseconds.
  function get_time_of_day()
   letseq (t = `time->seconds`(`current-time`())
           nsecs = systime_nanosecs(t))
    floor(t):nsecs;

  function get_process_time()
   letseq (t = f64array_at(`process-times`(), 2)
           nsecs = systime_nanosecs(t))
    floor(t):nsecs;

  function current_time_utc()
   let (t = get_time_of_day())
    make_time(TIME_UTC, cdr(t), car(t));

  function current_time_tai()
   letseq (t = get_time_of_day(), secs = car(t))
    make_time(TIME_TAI, cdr(t), secs + leap_second_delta(secs));

  // Uses `##get-monotonic-time!` from the gambit kernel to get the system specific
  // monotonic time in nanoseconds. This usually represents the total duration for which the
  // system was running. This value is converted to a ttime object and returned.
  function current_time_monotonic()
    let (v = #u64[0])
    { `##get-monotonic-time!`(v, 0);
      let (t = u64array_at(v, 0))
       make_time(TIME_MONOTONIC, 0, floor(t/nano)) };

  // Return the total time duration for which the current process was running.
  function current_time_process()
   let (t = f64array_at(`process-times`(), 2))
    make_time(TIME_PROCESS, systime_nanosecs(t), floor(t));

  function now(clock_type = TIME_UTC)
   if (is_eq(clock_type, TIME_UTC)) current_time_utc()
   else if (is_eq(clock_type, TIME_TAI)) current_time_tai()
   else if (is_eq(clock_type, TIME_MONOTONIC)) current_time_monotonic()
   else if (is_eq(clock_type, TIME_PROCESS)) current_time_process()
   else error(!invalid_clock_type, !current_time);

  // Right now the gambit kernel supports only checking the resolution
  // of the monotonic clock, we just return that.
  function resolution(clock_type = TIME_UTC)
   let (v = #u64[0])
   { `##get-monotonic-time-frequency!`(v, 0);
     u64array_at(v, 0) };

  // Time comparisons
  function check_time_compare(time1, time2, caller)
   if (is_ttime(time1) && is_ttime(time2)
       && is_eq(ttime_type(time1), ttime_type(time2))) true
   else error(!incompatible_time_types, caller);

  function time_to_nanos(t) ttime_second(t) * nano + ttime_nanosecond(t);
  function nanos_to_time(time_type, nanoseconds)
   make_time(time_type, remainder(nanoseconds, nanos), quotient(nanoseconds, nano));
   
  function time_cmpr(time1, time2, predic, caller)
  { check_time_compare(time1, time2, caller);
    predic(time_to_nanos(time1), time_to_nanos(time2)) };

  function time_is_eq(time1, time2) time_cmpr(time1, time2, `==`, !time_is_eq);
  function is_gt(time1, time2) time_cmpr(time1, time2, `>`, !time_is_gt);
  function is_lt(time1, time2) time_cmpr(time1, time2, `<`, !time_is_lt);
  function is_gteq(time1, time2) time_cmpr(time1, time2, `>=`, !time_is_gteq);
  function is_lteq(time1, time2) time_cmpr(time1, time2, `<=`, !time_is_lteq);

// time arithmetic
  function difference(time1, time2)
  { check_time_compare(time1, time2, !difference);
    let (n1 = time_to_nanos(time1),
         n2 = time_to_nanos(time2))
     if (n1 == n2) make_time(TIME_DURATION, 0., 0.)    
     else let (n3 = n1 - n2)
           make_time(TIME_DURATION, remainder(n3, nano), quotient(n3, nano)) };

  function add_duration(time1, time_duration)
  { when (not(is_eq(ttime_type(time_duration), TIME_DURATION)))
     error(!invalid_duration, !add_duration);
    let (n1 = time_to_nanos(time1),
         n2 = time_to_nanos(time_duration))
     else let (n3 = n1 + n2)
           make_ttime(ttime_type(time1), remainder(n3, nano), quotient(n3, nano)) };

  function subtract_duration(time1, time_duration)
  { when (not(is_eq(ttime_type(time_duration), TIME_DURATION)))
     error(!invalid_duration, !add_duration);
    let (n1 = time_to_nanos(time1),
         n2 = time_to_nanos(time_duration))
     else let (n3 = n1 - n2)
           make_ttime(ttime_type(time1), remainder(n3, nano), quotient(n3, nano)) };

// converters between time-types.

  function time_tai_to_utc(time_in)
    if (ttime_type(time_in) <> TIME_TAI)
     error(!incompatible_time_types, !time_tai_to_utc, time_in)
    else make_time(TIME_UTC, ttime_nanosecond(time_in),
                   leap_second_neg_delta(ttime_second(time_in)));

  function time_utc_to_tai(time_in)
    if (ttime_type(time_in) <> TIME_UTC)
     error(!incompatible_time_types, !time_utc_to_tai, time_in)
    else make_time(TIME_TAI, ttime_nanosecond(time_in),
                   let (s = ttime_second(time_in))
                    s + leap_second_delta(s));

  function time_monotonic_to_utc(time_in)
    if (ttime_type(time_in) <> TIME_MONOTONIC)
     error(!incompatible_time_types, !time_monotonic_to_utc, time_in)
    else let (t = copy_time(time_in))
    { ttime_set_type(t, TIME_TAI);
      time_tai_to_utc(t) };

  function time_monotonic_to_tai(time_in)
    if (ttime_type(time_in) <> TIME_MONOTONIC)
     error(!incompatible_time_types, !time_monotonic_to_tai, time_in)
    else let (t = copy_time(time_in))
    { ttime_set_type(t, TIME_TAI); t };

  function time_utc_to_monotonic(time_in)
    if (ttime_type(time_in) <> TIME_UTC)
     error(!incompatible_time_types, !time_utc_to_monotonic, time_in)
    else let (ntime = time_utc_to_tai(time_in))
    { ttime_set_type(ntime, TIME_MONOTONIC); ntime };

  function time_tai_to_monotonic(time_in)
    if (ttime_type(time_in) <> TIME_TAI)
     error(!incompatible_time_types, !time_tai_to_monotonic, time_in)
    else let (ntime = copy_time(time_in))
    { ttime_set_type(ntime, TIME_MONOTONIC); ntime };

  // date

  record date(nanosecond, second, minute, hour, day, month, year, zone_offset);

  // gives the julian day which starts at noon.
  function encode_julian_day_number(day, month, year)
   letseq (a = quotient(14 - month, 12),
           y = (year + 4800 - a) - if (is_negative(year)) -1 else 0,
           m = (month + 12 * a) - 3)
    add(day, quotient(153 * m + 2, 5), 365 * y, quotient(y, 4),
        -(quotient(y, 100)), quotient(y, 400), -32045);

  // gives the seconds/date/month/year
  function decode_julian_day_number(jdn)
   letseq (days = truncate(jdn),
           a = days + 32044,
    	   b = quotient(4 * a + 3, 146097),
           c = a - quotient(146097 * b, 4),
           d = quotient(4 * c + 3, 1461),
           e = c - quotient(1461 * d, 4),
           m = quotient(5 * e + 2, 153),
           y = add(100 * b, d, -4800, quotient(m, 10)))
     #{'seconds: (jdn - days) * sid,
       'date: quotient(2 + 153 * m, 5) - 1,
       'month: add(m, 3, -12 * quotient(m, 10)),
       'year: if (0 >= y) y - 1 else y};


;; relies on the fact that we named our time zone accessor
;; differently from MzScheme's....
;; This should be written to be OS specific.

(define (tm:local-tz-offset)
  (date-time-zone-offset (seconds->date (current-seconds))))

;; special thing -- ignores nanos
(define (tm:time->julian-day-number seconds tz-offset)
  (+ (/ (+ seconds
	   tz-offset
	   tm:sihd)
	tm:sid)
     tm:tai-epoch-in-jd))

(define (tm:find proc l)
  (if (null? l)
      #f
      (if (proc (car l))
	  #t
	  (tm:find proc (cdr l)))))

(define (tm:tai-before-leap-second? second)
  (tm:find (lambda (x)
	     (= second (- (+ (car x) (cdr x)) 1)))
	   tm:leap-second-table))

(define (tm:time->date time tz-offset ttype)
  (if (not (eq? (time-type time) ttype))
      (tm:time-error 'time->date 'incompatible-time-types  time))
  (let* ( (offset (:optional tz-offset (tm:local-tz-offset))) )
    (receive (secs date month year)
	     (tm:decode-julian-day-number
	      (tm:time->julian-day-number (time-second time) offset))
	     (let* ( (hours    (quotient secs (* 60 60)))
		     (rem      (remainder secs (* 60 60)))
		     (minutes  (quotient rem 60))
		     (seconds  (remainder rem 60)) )
	       (make-date (time-nanosecond time)
			  seconds
			  minutes
			  hours
			  date
			  month
			  year
			  offset)))))

(define (time-tai->date time . tz-offset)
  (if (tm:tai-before-leap-second? (time-second time))
      ;; if it's *right* before the leap, we need to pretend to subtract a second ...
      (let ((d (tm:time->date (subtract-duration! (time-tai->time-utc time) (make-time time-duration 0 1)) tz-offset time-utc)))
	(tm:set-date-second! d 60)
	d)
      (tm:time->date (time-tai->time-utc time) tz-offset time-utc)))

(define (time-utc->date time . tz-offset)
  (tm:time->date time tz-offset time-utc))

;; again, time-monotonic is the same as time tai
(define (time-monotonic->date time . tz-offset)
  (tm:time->date time tz-offset time-monotonic))

(define (date->time-utc date)
  (let ( (nanosecond (date-nanosecond date))
	 (second (date-second date))
	 (minute (date-minute date))
	 (hour (date-hour date))
	 (day (date-day date))
	 (month (date-month date))
	 (year (date-year date))
	 (offset (date-zone-offset date)) )
    (let ( (jdays (- (tm:encode-julian-day-number day month year)
		     tm:tai-epoch-in-jd)) )
      (make-time 
       time-utc
       nanosecond
       (+ (* (- jdays 1/2) 24 60 60)
	  (* hour 60 60)
	  (* minute 60)
	  second
	  (- offset))
       ))))

(define (date->time-tai d)
  (if (= (date-second d) 60)
      (subtract-duration! (time-utc->time-tai! (date->time-utc d)) (make-time time-duration 0 1))
      (time-utc->time-tai! (date->time-utc d))))

(define (date->time-monotonic date)
  (time-utc->time-monotonic! (date->time-utc date)))


(define (tm:leap-year? year)
  (or (= (modulo year 400) 0)
      (and (= (modulo year 4) 0) (not (= (modulo year 100) 0)))))

(define (leap-year? date)
  (tm:leap-year? (date-year date)))

;; tm:year-day fixed: adding wrong number of days.
(define  tm:month-assoc '((0 . 0) (1 . 31)  (2 . 59)   (3 . 90)   (4 . 120) 
			  (5 . 151) (6 . 181)  (7 . 212)  (8 . 243)
			  (9 . 273) (10 . 304) (11 . 334)))

(define (tm:year-day day month year)
  (let ((days-pr (assoc (- month 1) tm:month-assoc)))
    (if (not days-pr)
	(tm:time-error 'date-year-day 'invalid-month-specification month))
    (if (and (tm:leap-year? year) (> month 2))
	(+ day (cdr days-pr) 1)
	(+ day (cdr days-pr)))))

(define (date-year-day date)
  (tm:year-day (date-day date) (date-month date) (date-year date)))

;; from calendar faq 
(define (tm:week-day day month year)
  (let* ((a (quotient (- 14 month) 12))
	 (y (- year a))
	 (m (+ month (* 12 a) -2)))
    (modulo (+ day y (quotient y 4) (- (quotient y 100))
	       (quotient y 400) (quotient (* 31 m) 12))
	    7)))

(define (date-week-day date)
  (tm:week-day (date-day date) (date-month date) (date-year date)))

(define (tm:days-before-first-week date day-of-week-starting-week)
  (let* ( (first-day (make-date 0 0 0 0
                                1
                                1
                                (date-year date)
                                #f))
          (fdweek-day (date-week-day first-day))  )
    (modulo (- day-of-week-starting-week fdweek-day)
            7)))

(define (date-week-number date day-of-week-starting-week)
  (quotient (- (date-year-day date)
	       (tm:days-before-first-week  date day-of-week-starting-week))
	    7))

(define (current-date . tz-offset) 
  (time-utc->date (current-time time-utc)
		  (:optional tz-offset (tm:local-tz-offset))))

;; given a 'two digit' number, find the year within 50 years +/-
(define (tm:natural-year n)
  (let* ( (current-year (date-year (current-date)))
	  (current-century (* (quotient current-year 100) 100)) )
    (cond
      ((>= n 100) n)
      ((<  n 0) n)
      ((<=  (- (+ current-century n) current-year) 50)
       (+ current-century n))
      (else
       (+ (- current-century 100) n)))))

(define (date->julian-day date)
  (let ( (nanosecond (date-nanosecond date))
	 (second (date-second date))
	 (minute (date-minute date))
	 (hour (date-hour date))
	 (day (date-day date))
	 (month (date-month date))
	 (year (date-year date))
	 (offset (date-zone-offset date)) )
    (+ (tm:encode-julian-day-number day month year)
       (- 1/2)
       (+ (/ (/ (+ (* hour 60 60)
		   (* minute 60) second (/ nanosecond tm:nano)) tm:sid)
	     (- offset))))))

(define (date->modified-julian-day date)
  (- (date->julian-day date)
     4800001/2))


(define (time-utc->julian-day time)
  (if (not (eq? (time-type time) time-utc))
      (tm:time-error 'time-utc->julian-day 'incompatible-time-types  time))
  (+ (/ (+ (time-second time) (/ (time-nanosecond time) tm:nano))
	tm:sid)
     tm:tai-epoch-in-jd))

(define (time-utc->modified-julian-day time)
  (- (time-utc->julian-day time)
     4800001/2))

(define (time-tai->julian-day time)
  (if (not (eq? (time-type time) time-tai))
      (tm:time-error 'time-tai->julian-day 'incompatible-time-types  time))
  (+ (/ (+ (- (time-second time) 
	      (tm:leap-second-delta (time-second time)))
	   (/ (time-nanosecond time) tm:nano))
	tm:sid)
     tm:tai-epoch-in-jd))

(define (time-tai->modified-julian-day time)
  (- (time-tai->julian-day time)
     4800001/2))

;; this is the same as time-tai->julian-day
(define (time-monotonic->julian-day time)
  (if (not (eq? (time-type time) time-monotonic))
      (tm:time-error 'time-monotonic->julian-day 'incompatible-time-types  time))
  (+ (/ (+ (- (time-second time) 
	      (tm:leap-second-delta (time-second time)))
	   (/ (time-nanosecond time) tm:nano))
	tm:sid)
     tm:tai-epoch-in-jd))


(define (time-monotonic->modified-julian-day time)
  (- (time-monotonic->julian-day time)
     4800001/2))


(define (julian-day->time-utc jdn)
  (let ( (nanosecs (* tm:nano tm:sid (- jdn tm:tai-epoch-in-jd))) )
    (make-time time-utc
	       (remainder nanosecs tm:nano)
	       (floor (/ nanosecs tm:nano)))))

(define (julian-day->time-tai jdn)
  (time-utc->time-tai! (julian-day->time-utc jdn)))

(define (julian-day->time-monotonic jdn)
  (time-utc->time-monotonic! (julian-day->time-utc jdn)))

(define (julian-day->date jdn . tz-offset)
  (let ((offset (:optional tz-offset (tm:local-tz-offset))))
    (time-utc->date (julian-day->time-utc jdn) offset)))

(define (modified-julian-day->date jdn . tz-offset)
  (let ((offset (:optional tz-offset (tm:local-tz-offset))))
    (julian-day->date (+ jdn 4800001/2) offset)))

(define (modified-julian-day->time-utc jdn)
  (julian-day->time-utc (+ jdn 4800001/2)))

(define (modified-julian-day->time-tai jdn)
  (julian-day->time-tai (+ jdn 4800001/2)))

(define (modified-julian-day->time-monotonic jdn)
  (julian-day->time-monotonic (+ jdn 4800001/2)))

(define (current-julian-day)
  (time-utc->julian-day (current-time time-utc)))

(define (current-modified-julian-day)
  (time-utc->modified-julian-day (current-time time-utc)))

};
