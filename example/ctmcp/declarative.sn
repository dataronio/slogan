// Examples of declarative programming. 

// A declarative program is one that is stateless and deterministic, i.e when called with the
// same input it always give the same output. Declarative programs are compositional and easy
// to reason about.

// Let us start with a simple program that demonstrates two declarative programming techniques
// - using functions as the sole building blocks of a program and iteration. The program defines
// a function that finds the square root of a number using Newton's method: 

function sqrt(x)
{ function improve(guess) (guess + x/guess) / 2.0;
  function is_good_enough(guess) abs(x-guess*guess)/x < 0.00001;
  function sqrt_iter(guess) if (is_good_enough(guess)) guess else sqrt_iter(improve(guess));
  sqrt_iter(1.0) };


// Another technique is higher-order programming where functions are passed as arguments to
// functions. This allows us to build powerful abstractions that separates the general
// control flow of a program from each particular use of it. In the next example we abstract away
// the iteration using this technique:

function iterate(s, is_done, transform) 
    if (is_done(s)) s
    else iterate(transform(s), is_done, transform);

// We can now re-write `sqrt` more concisely using the `iterate` abstraction:

function sqrt(x) iterate(1.0, fn (g) abs(x-g*g)/x<0.00001, fn (g) (g+x/g)/2.0);

// Recursion is more general than iteration in that a recursive call can occur anywhere
// in the function body. One consequence of this is that recursion can lead to a growing
// stack in proportion to the input. An important technique in declarative programming is
// to control the growing stack size whenever possible. As an example, we show the `factorial`
// function. First the normal definition that grows the stack in proportion to the function's
// argument:

function factorial(n) 
    if (n == 0) 1
    else if (n > 0) n * factorial(n - 1)
    else error("factorial - n must be positive.");

// We can convert the recursion to iteration by adding an accumulator argument that keeps track of
// the numbers multiplied so far and by pushing the recursive call to the tail-position of the
// function:

function factorial(n)
{ function fact_iter(n, a) 
    if (n == 0) a
    else if (n > 0) fact_iter(n - 1, n * a)
    else error("factorial - n must be positive.");
  
  fact_iter(n, 1) };

