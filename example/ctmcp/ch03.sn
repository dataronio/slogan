reload("../util");

function sqrt(x)
{ function improve(guess) (guess + x/guess) / 2.0;
  function is_good_enough(guess) abs(x-guess*guess)/x < 0.00001;
  function sqrt_iter(guess) if (is_good_enough(guess)) guess else sqrt_iter(improve(guess));
  sqrt_iter(1.0) };

assert(floor(sqrt(10)), 3.);

function iterate(s, is_done, transform) 
  if (is_done(s)) s
  else iterate(transform(s), is_done, transform);

function sqrt(x) iterate(1.0, fn (g) abs(x-g*g)/x<0.00001, fn (g) (g+x/g)/2.0);

assert(floor(sqrt(10)), 3.);

function factorial(n) 
  if (n == 0) 1
  else if (n > 0) n * factorial(n - 1)
  else error("factorial - n must be positive.");

assert(factorial(10), 3628800);
assert(try factorial(-1) catch (e) false, false);

function factorial(n)
{ function fact_iter(n, a) 
    if (n == 0) a
    else if (n > 0) fact_iter(n - 1, n * a)
    else error("factorial - n must be positive.");
  
  fact_iter(n, 1) };

assert(factorial(10), 3628800);
assert(try factorial(-1) catch (e) false, false);

function merge(xs, ys) 
  match(xs:ys) 
   []:ys         -> ys,
   xs:[]         -> xs,
   (x:xr):(y:yr) -> 
   if (x < y) x:merge(xr, ys)
   else y:merge(xs, yr);

function split(xs) 
{ function iter(xs, xrs, yrs) 
    match(xs) 
     []       -> xrs:yrs,
     [x]      -> (x:xrs):yrs,
     x1:x2:xr -> iter(xr, x1:xrs, x2:yrs);
   iter(xs, [], []) };

function mergesort(xs) 
  match(xs) 
   []  -> [],
   [x] -> [x],
   _   -> let (parts = split(xs)) 
           merge(mergesort(head(parts)),
                 mergesort(tail(parts)));

assert(mergesort([3 1 0 2]), [0 1 2 3]);

// Amortized constant-time ephemeral queue
function make_queue() []:[];

function check_queue(q)
  match(q)
   []:r -> reverse(r):[],
    _ -> q;

function insert_queue(q, x) match(q) f:r -> check_queue(f:(x:r));
function delete_queue(q) match(q) f:r -> check_queue(tail(f):r);
function is_empty_queue(q) match(q) f:r -> is_empty(f);

// Ordered binary trees
record leaf();
define default_leaf = leaf();
record tree(key, value, left = default_leaf, right = default_leaf);

function lookup(k, tree)
  match(tree)
   leaf() -> !notfound,
   tree(key, value, left, right) -> 
          if (k < key) lookup(k, left)
          else if (k > key) lookup(k, right)
          else value;

// There is an alternative way to write `lookup` using `where` guards.
// This is more declarative and makes it easy to verify that no cases
// are overlooked.
function lookup_2(k, tree) 
  match(tree) 
   leaf() -> !notfound,
   tree(key, value, _, _) where key == k -> value,
   tree(key, _, left, _) where k < key -> lookup_2(k, left),
   tree(key, _, _, right) where k > key -> lookup_2(k, right);

function insert(k, v, t)
  match(t)
   leaf() -> tree(key = k, value = v),
   tree(key, value, left, right) where key == k -> make_tree(k, v, left, right),
   tree(key, value, left, right) where k < key -> make_tree(key, value, insert(k, v, left), right),
   tree(key, value, left, right) where k > key -> make_tree(key, value, left, insert(k, v, right));

function delete(x, tree)
  match(tree)
   leaf() -> default_leaf,
   tree(key, value, left, right) where key == x ->
   { match(remove_smallest(right))
      [] -> left,
      yp:vp:tp -> make_tree(yp, vp, left, tp) },
   tree(key, value, left, right) where x < key -> make_tree(key, value, delete(x, left), right),
   tree(key, value, left, right) where x > key -> make_tree(key, value, left, delete(x, right));

function remove_smallest(tree)
  match(tree)
   leaf() -> [],
   tree(key, value, left, right) ->
   { match(remove_smallest(left))
      [] -> key:value:right,
   yp:vp:tp -> yp:vp:make_tree(key, value, tp, right) };

