reload("../util");

function sqrt(x)
{ function improve(guess) (guess + x/guess) / 2.0;
  function is_good_enough(guess) abs(x-guess*guess)/x < 0.00001;
  function sqrt_iter(guess) if (is_good_enough(guess)) guess else sqrt_iter(improve(guess));
  sqrt_iter(1.0) };

assert(floor(sqrt(10)), 3.);

function iterate(s, is_done, transform) 
  if (is_done(s)) s
  else iterate(transform(s), is_done, transform);

function sqrt(x) iterate(1.0, fn (g) abs(x-g*g)/x<0.00001, fn (g) (g+x/g)/2.0);

assert(floor(sqrt(10)), 3.);

function factorial(n) 
  if (n == 0) 1
  else if (n > 0) n * factorial(n - 1)
  else error("factorial - n must be positive.");

assert(factorial(10), 3628800);
assert(try factorial(-1) catch (e) false, false);

function factorial(n)
{ function fact_iter(n, a) 
    if (n == 0) a
    else if (n > 0) fact_iter(n - 1, n * a)
    else error("factorial - n must be positive.");
  
  fact_iter(n, 1) };

assert(factorial(10), 3628800);
assert(try factorial(-1) catch (e) false, false);

function merge(xs, ys) 
  match(xs:ys) 
   []:ys         -> ys,
   xs:[]         -> xs,
   (x:xr):(y:yr) -> 
   if (x < y) x:merge(xr, ys)
   else y:merge(xs, yr);

function split(xs) 
{ function iter(xs, xrs, yrs) 
    match(xs) 
     []       -> xrs:yrs,
     [x]      -> (x:xrs):yrs,
     x1:x2:xr -> iter(xr, x1:xrs, x2:yrs);
   iter(xs, [], []) };

function mergesort(xs) 
  match(xs) 
   []  -> [],
   [x] -> [x],
   _   -> let (parts = split(xs)) 
           merge(mergesort(head(parts)),
                 mergesort(tail(parts)));

assert(mergesort([3 1 0 2]), [0 1 2 3]);

// Amortized constant-time ephemeral queue
function make_queue() []:[];

function check_queue(q)
  match(q)
   []:r -> reverse(r):[],
    _ -> q;

function insert_queue(q, x) match(q) f:r -> check_queue(f:(x:r));
function delete_queue(q) match(q) f:r -> check_queue(tail(f):r);
function is_empty_queue(q) match(q) f:r -> is_empty(f);

// Ordered binary trees
record leaf();
define default_leaf = leaf();
record tree(key, value, left = default_leaf, right = default_leaf);

function lookup(k, tree)
  match(tree)
   leaf() -> !notfound,
   tree(key, value, left, right) -> 
          if (k < key) lookup(k, left)
          else if (k > key) lookup(k, right)
          else value;

// There is an alternative way to write `lookup` using `where` guards.
// This is more declarative and makes it easy to verify that no cases
// are overlooked.
function lookup_2(k, tree) 
  match(tree) 
   leaf() -> !notfound,
   tree(key, value, _, _) where key == k -> value,
   tree(key, _, left, _) where k < key -> lookup_2(k, left),
   tree(key, _, _, right) where k > key -> lookup_2(k, right);

function insert(k, v, t)
  match(t)
   leaf() -> tree(key = k, value = v),
   tree(key, value, left, right) where key == k -> make_tree(k, v, left, right),
   tree(key, value, left, right) where k < key -> make_tree(key, value, insert(k, v, left), right),
   tree(key, value, left, right) where k > key -> make_tree(key, value, left, insert(k, v, right));

function delete(x, tree)
  match(tree)
   leaf() -> default_leaf,
   tree(key, value, left, right) where key == x ->
   { match(remove_smallest(right))
      [] -> left,
      yp:vp:tp -> make_tree(yp, vp, left, tp) },
   tree(key, value, left, right) where x < key -> make_tree(key, value, delete(x, left), right),
   tree(key, value, left, right) where x > key -> make_tree(key, value, left, delete(x, right));

function remove_smallest(tree)
  match(tree)
   leaf() -> [],
   tree(key, value, left, right) ->
   { match(remove_smallest(left))
      [] -> key:value:right,
   yp:vp:tp -> yp:vp:make_tree(key, value, tp, right) };

// An integer loop:
function for(start, end, step, func)
{ function loop(c, cmpr)
   when (cmpr(c, end))
   { func(c);
     loop(c + step, cmpr) };

  if (is_positive(step)) loop(start, `<=`)
  else loop(start, `>=`) };

define x = 0;
for(0, 10, 1, fn(i) x = i);
assert(x, 10);
for(10, 1, -2, fn(i) x = i);
assert(x, 2);

// Accumulator loops:
function for_acc(start, end, step, func, init)
{ let (cmpr = if (is_positive(step)) `<=` else `>=`)
   let loop (c = start, r = init)
    if (cmpr(c, end)) loop(c + step, func(r, c))
    else r };

assert(for_acc(0, 5, 1, fn(a, c) c + a, 0), 15);
assert(for_acc(10, 0, -2, fn(a, c) c + a, 2), 32);

function for_all_acc(xs, func, init)
  let loop (xs = xs, r = init)
   if (is_empty(xs)) r
   else loop(rest(xs), func(r, first(xs)));

assert(for_all_acc([1 2 3 4 5], fn(a, c) a + c, 0), 15);

// List based dictionary:
function new_dictionary() [];

function put(ds, key, value)
  match (ds)
   [] -> [key:value],
   (k:v):dr where k == key -> (key:value):dr,
   (k:v):dr where k > key -> (key:value):(k:v):dr,
   (k:v):dr where k < key -> (k:v):put(dr, key, value);

function cond_get(ds, key, default)
  match (ds)
   [] -> default,
   (k:v):dr where k == key -> v,
   (k:v):dr where k > key -> default,
   (k:v):dr where k < key -> cond_get(dr, key, default);

function domain(ds) map(first, ds);

define dict = put(put(put(new_dictionary(), 1, 100), 10, 1000), 5, 500);
assert(cond_get(dict, 1, 0), 100);
assert(cond_get(dict, 10, 0), 1000);
assert(cond_get(dict, 5, 0), 500);
assert(cond_get(dict, 2, 0), 0);
assert(sort(domain(dict)), [1 5 10]);

// Tree based dictionary:
function new_dictionary() default_leaf;

function put(ds, key, value) insert(key, value, ds);

function cond_get(ds, key, default)
  let (r = lookup_2(key, ds))
   if (r == !notfound) default
   else r;

function domain(ds)
{ function domain_helper(ds, d)
    match (ds)
     leaf() -> d,
     tree(key, _ , left, right) -> key:domain_helper(left, domain_helper(right, d));
  domain_helper(ds, []) };
  
dict = put(put(put(new_dictionary(), 1, 100), 10, 1000), 5, 500);
assert(cond_get(dict, 1, 0), 100);
assert(cond_get(dict, 10, 0), 1000);
assert(cond_get(dict, 5, 0), 500);
assert(cond_get(dict, 2, 0), 0);
assert(sort(domain(dict)), [1 5 10]);

