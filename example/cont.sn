load "util";

// Using continutaion to short-circuit evaluation:
function product(xs) 
    callcc(fn(return) {
        fn loop(xs, n)
            match (xs : n) 
                [] : n -> n,
                (0:_) : _ -> return(0),
                (i:r) : n -> loop(r, i * n);
        loop(xs, 1)
    });

assert(product([1 2 3]), 6);
assert(product([]), 1);
assert(product([2]), 2);

//
// Multitasking.
//

// Coroutines:
define rdy_q = []; // really a stack!

function dispatch() 
    let (t = first(rdy_q)) 
        if (not(is_empty(t))) {
            rdy_q = rest(rdy_q);
            t();
        } else raise(!no_more_threads_to_run);

function yield() callcc(fn(k) { rdy_q = k : rdy_q; dispatch() });

function terminate() dispatch();

function fork(f) 
    callcc(fn(parent_k) {
        rdy_q = parent_k : rdy_q;
        f();
        terminate();
    });

// We need queues for message passing, sychronization and stuff:
function make_queue() [] : []; 

function qcheck(q) 
    match (q) 
      [] : r -> reverse(r) : [], 
      else -> q; 

function enqueue(q, x) 
    match (q) 
      f : r -> qcheck(f : x : r);

function dequeue(q) 
    match (q) 
      f : r -> qcheck(tail(f) : r);

function front(q) 
    match (q) 
      f : r -> head(f);


// Mutex implementation:
record mutex(locked, blocked_threads);

function mkmutex() mutex(locked = false, blocked_threads = make_queue());

function acquire(m) {
    showln("acquire:" mutex_locked(m), ", " mutex_blocked_threads(m));
    match(m) 
        mutex(locked, blocked_threads) ->
            if (not(locked))
                callcc(fn(k) {
                    mutex_set_blocked_threads(m, enqueue(blocked_threads, k));
                    dispatch()
                })
            else mutex_set_locked(m, true)
};

function release(m) {
    showln(mutex_locked(m), ", " mutex_blocked_threads(m));
    match(m) 
        mutex(locked, blocked_threads) ->
            if (is_empty(dequeue(blocked_threads)))
                mutex_set_locked(m, false)
            else callcc(fn(k) {
              rdy_q = k : rdy_q;
              let (f = front(blocked_threads)) {
                  mutex_set_blocked_threads(m, dequeue(blocked_threads));
                  f()
              }})
};

function with_lock(m f x) 
    try { acquire(m); f(x) } finally release(m);

