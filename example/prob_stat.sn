load("util");

function random_dataset(count, max_val)
 let loop (c = count, rs = [])
  if (c <= 0) rs
  else loop(c - 1, random_integer(max_val):rs);
  
define q10 = partial(quotient, 10);
define r10 = partial(remainder, 10);

function split_last_digit(xs)
{ function tabify(xss)
   let loop (xss = xss, tab = #{})
    if (is_empty(xss))
    { hashtable_for_each(fn(k, v) @(tab, k, value = sort(v)), tab);
      tab }
    else letseq (k = head(head(xss))
                 v = tail(head(xss))
                 ds = @(tab, k))
     { if (ds) @(tab, k, value = v:ds)
       else if (v) @(tab, k, value = [v])
       else @(tab, k, value = v);
       loop(tail(xss), tab) };
 tabify(map(fn (x) if (x < 10) 0:x else q10(x):r10(x), xs)) };

function stemplot(xs)
 let (table = split_last_digit(sort(xs)))
  hashtable_for_each(fn(k, v)
                     { show(k ":");
                       for_each(show, v);
                       newline() }
                     table);

function sum(xs) apply(`+`, xs);

function mean(xs)
 when (not(is_empty(xs)))
  sum(xs)/length(xs);

assert(mean([1 10 5 4 3.]), 4.6);
assert(mean([3]), 3);
assert(mean([]), false);

function median(xs)
 let (ln = length(xs))
  if (ln == 0) false
  else if (ln == 1) head(xs)
  else let (xs = sort(xs)
            m = dec(quotient(ln, 2)))
        if (is_even(ln))
         quotient((at(m, xs) + at(m + 1, xs)), 2)
        else
         at(m, xs);

assert(median([1 10 5 4 3]), 3);
assert(median([3]), 3);
assert(median([]), false);

function split_at_median(ys)
 let (m = median(ys))
  when (m)
   let loop (xs = sort(ys), ls = [], rs = [])
    if (is_empty(xs))
     if (memq(m, ys))
      (reverse(m:ls)):(append([m], reverse(rs)))
     else reverse(ls):reverse(rs)
    else let (x = head(xs))
          if (x < m) loop(rest(xs), x:ls, rs)
          else if (x > m) loop(rest(xs), ls, x:rs)
          else loop(rest(xs), ls, rs);
               
function interquartile_range(xs)
 let (parts = split_at_median(xs))
  when (parts)
   let (q1 = median(head(parts))
        q3 = median(tail(parts)))
    when (q1 && q3) q3 - q1;

assert(interquartile_range([1, 3, 4, 5, 5, 6, 7, 11]), 3);
assert(interquartile_range([1]), 0);
assert(interquartile_range([]), false);

function square(x) x * x;

function variance(xs)
 if (is_empty(xs)) false
 else if (is_empty(tail(xs))) head(xs)
 else let (m = mean(xs))
       when (m) sum(map(fn(x) square(x - m), xs))/dec(length(xs));

assert(variance([3 5 7 7 38]), 214);
assert(variance([1]), 1);
assert(variance([]), false);

function standard_deviation(xs)
 let (v = variance(xs))
  when (v) sqrt(v);

assert(standard_deviation([3 5 7 7 38]), 14.628738838327793);
assert(standard_deviation([1]), 1);
assert(standard_deviation([]), false);

function z_scores(xs)
 let (s = standard_deviation(xs)
      m = mean(xs))
  when (s && m) map(fn (x) (x - m)/s, xs);
  
// Probability of any one of the events e or f to occur:
function por(pe, pf, pe_and_f) pe + pf - pe_and_f;

// Probability of event e occuring given f has occured:
function condp(pe_and_f, pf) pe_and_f/pf;