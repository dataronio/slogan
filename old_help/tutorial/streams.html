<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Streams</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Streams</h2>
        <p>Streams are input/output devices that can read and write characters. Streams are created with any one of the
          three constructors: <code>stream</code>, <code>output_stream</code> and <code>input_stream</code>. 
          The functions <code>close_stream</code>, <code>close_input_stream</code> or <code>close_output_stream</code> 
          must be called on a stream to release all system resources held by it. The usual programming idiom to open, use and
          close a stream is: </p>
        <pre>
          var s = false;
          try { 
             s = stream (&lt;stream_type&gt;, &lt;stream_settings&gt;);
             /* read/write stream s. */ 
          } catch (stream_exception) { 
            /* handle stream_exception. */ 
          } finally {
            if s close_stream (s);
          }</pre>
        <p>The functions <code>with_stream</code>, <code>with_output_stream</code> and <code>with_input_stream</code> implements this
          idiom. The following sections briefly show how to use some of the most useful stream types provided by Slogan.</p>
        <h3>File streams</h3>
        <p>File streams are used to read and write data on files. This is how we write some text to a file:</p>
        <pre>
          > var f = output_stream (!file, "hello.txt");
          > println (to = f, "hello, world!");
          > close_stream (f);</pre>
        <p>Reading the text back is just as simple:</p>
        <pre>
          > f = input_stream (!file, "hello.txt");
          > read_line (f);
          => "hello, world!"
          > close_stream (f);</pre>
        <p>The code becomes even shorter if we use one of the <code>with_stream</code> functions:</p>
        <pre>
          > with_output_stream (!file, "hello.txt", function (s) { println (to = s, "hello, world!") });
          > with_input_stream (!file, "hello.txt", function (s) { read_line (s) });
          => "hello, world!"</pre>
        <p><code>read_line</code> reads characters from an input stream until a specific separator or the end-of-stream is encountered.
          The characters read are returned as a string. The separator can be specified as the second argument and it defaults to the
          <code>newline</code> character.</p>
        <p>To prevent new content from overwriting old content, the file has to be opened with the <code>append</code>
          flag turned on:</p>
        <pre>
          > with_output_stream (!file, [[!path "hello.txt"], [!append true]], function (s) { println (to = s, "this is some new text") });
          > with_input_stream (!file, "hello.txt", function (s) { println (read_line (s), read_line (s)) });
          hello, world!this is some new text</pre>
        <p>Settings accepted by the file stream constructor are:
          <ul>
            <li><code>!path:</code> The location of the file. This setting is required.</li>
            <li><code>!append:</code> A boolean value indicating whether to open the file in append mode or not.</li>
            <li><code>!create:</code> Can be a boolean value or the symbol <code>!maybe</code>. The value <code>true</code>
              will try to create the file and raises an exception if the file already exists. The value <code>false</code>
              requires that the file already exist. <code>!maybe</code> will try to create the file if it does not exist.
              The default value is <code>!maybe</code> for output streams and <code>false</code> for other streams.</li>
            <li><code>!permissions:</code> UNIX style file permissions, default is 0o666.</li>
            <li><code>!truncate:</code> <code>true</code> or <code>false</code>. Controls whether the file will be truncated
              upon opening. Default is <code>true</code> for output streams when append is <code>false</code> and <code>false</code>
              otherwise.</li>
          </ul>          
        </p>
        <p>These are in addition to the two settings that are common to all types of streams:
          <ul>
            <li><code>!direction:</code> Either <code>!output</code>, <code>!input</code> or <code>!input_output</code>.</li>
            <li><code>!buffering</code> Controls the buffering of the port. Should be one of <code>true</code> (for fully buffered IO), 
              <code>false</code> (for no buffering), or <code>!line</code>. In line-buffering an output buffer is flushed on a newline.</li>
            </ul>
          </p>
        <h3>Example: Copying files</h3>
        <p>This example shows a function that copies a file byte-by-byte. For this we make use of the stream functions that can read
          and write 8-bit unsigned values. </p>
        <pre>
var file_copy = function (src, dest) {
    with_stream (!file, [[!path dest], [!direction !output]], 
		 function (out_stream) {
		     with_stream (!file, [[!path src], [!direction !input], [!buffering true]],
				  function (in_stream) {
				      letrec loop = function () {
					  let buffer = byte_array (1024)
					  let r = read_bytes (buffer, 0, 1024, in_stream, 1024)
					  if r > 0 { write_bytes (buffer, 0, r, out_stream); loop () }
				      } loop()
				  })
		 })
};</pre>
        <p><code>read_bytes</code> fills its first argument, which must be a <code>byte_array</code>, with bytes from a stream.
          The second and third arguments are optional and specifies the range of indexes in the byte array that will get filled.
          If these values are omitted, they will default to 0 and the size of the array respectively. The third argument is the input stream.
          And the last argument specifies the number of bytes that needs to be read. <code>write_bytes</code> writes the content
          of a byte array starting and ending at the specified index range to an output stream.</p>
        <h2>String streams</h2>
        <p>String streams represent in-memory streams of characters: </p>
        <pre>
          > var name = "nook";
          > var age = 22;
          > with_output_stream (!string, "", function (s) { print (to = s, "name: ", name, ", age: ", age) });
          => "name: nook, age: 22"
          > with_input_stream (!string, "line 1\nline 2\n", function (s) { println (read_line (s)); println (read_line (s)) });
          line 1
          line 2</pre>
        <h2>Network streams</h2>
        <p>Tcp streams allow us to create network servers and clients that communicate over TCP. As an example, let us
          create an echo server and client. The echo server sends back whatever text the client sends it. First the server:</p>
        <pre>
          > var server = stream (!tcp_server, [[!port_number 5000]]);
          > var run_server = function () {
              let client = read (server) { 
                println (to = client, read_line (client));
                flush_output (client)
              };
              run_server ()
            };
          > run_server(); </pre>
        <p>The client connection is accepted by the <code>read</code> function. This is a rather low-level function that reads an 
          object in a host-environment specific format. In this case <code>read</code> returns a stream that can be used to
          read and write on a network connection. The server reads a line from the client, echoes it back and goes back to
          process the next client. Once you call <code>run_server</code> the REPL will hang as the call to <code>read</code>
          waits for the client connection to arrive.</p>
        <p>Now we need a client that can talk to the server. In a new REPL, enter the following code:</p>
        <pre>
          > var client = stream (!tcp_client, [[!server_address "localhost"], [!port_number 5000]]);
          > println (to = client, "hello");
          > flush_output (client);
          > println (read_line (client));
          hello
          > close_stream (close_stream);</pre>
        <p>Now you should see the client and server saying "hello" to each other.</p>
        <h2>Tokenizing streams</h2>
        <p>It is possible to break an input stream into a series of tokens based on a single character or a list of character delimiters. 
          For example, let us see how to read comma-separated values from a stream:</p>
        <pre>
          > var s = input_stream (!string, "hello, world");
          > var tokenizer = stream_tokenizer (s, delimiters = ',');
          > read_token (tokenizer);
          => "hello"
          > read_token (tokenizer);
          => " world"
          > read_token (tokenizer);
          => !end-of-stream</pre>
        <p>A stream of Slogan program statements can be tokenized into tokens of the language: </p>
        <pre>
          > var s = input_stream (!string, "var x = 10; x + 100");
          > var tokenizer = stream_tokenizer (s, program = true);
          > read_token (tokenizer);
          => var
          > read_token (tokenizer);
          => x
          > read_token (tokenizer);
          => *assignment*
          > read_token (tokenizer);
          => 10
          > read_token (tokenizer);
          => *semicolon*
          > read_token (tokenizer);
          => x
          > read_token (tokenizer);
          => *plus*
          > read_token (tokenizer);
          => 100</pre>
        <p>It is also possible to read, compile and execute programs directly from a stream: </p>
        <pre>
          > var s = input_stream (!string, "{ var x = 10; x + 100 }");
          > var tokenizer = stream_tokenizer (s, program = true);
          > eval (slogan (tokenizer));
          => 110</pre>
      </div>
    </div>
  </body>
</html>
