<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Arrays, Byte arrays, Bit arrays and Tables</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Arrays, Byte arrays, Bit arrays and Tables</h2>
        
        <h3>Arrays</h3>
        <p>Arrays are heterogeneous structures whose elements are indexed by integers. An array typically occupies less space 
          than a list of the same length, and the average time required to access a randomly chosen element is typically less 
          for the array than for the list. Arrays can have multiple dimensions. Array literals are enclosed in a <code>#[ ]</code>.</p>

        <h5>array (dim, @key fill)</h5>
        <p>Creates a new array of dimension <code>dim</code> with all elements initialized to <code>fill</code>.
          The dimension can be an integer or a list of integers.
          If it is an integer a single-dimensional array is returned, otherwise a multi-dimensional array is returned.
          There are no implicit limits to the number of dimensions, except for available memory.
          <code>fill</code> defaults to <code>false</code>. If <code>fill</code> is a procedure it is called for each
          slot in the array and the slot is filled-up with the result.</p>

        <pre>
          > array (10);
          => #[false, false, false, false, false, false, false, false, false, false]
          > array (10, fill = 'a');
          #['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
          > array ([2, 4], fill = 0); // as array of two rows and four columns.
          #[#[0, 0, 0, 0], #[0, 0, 0, 0]]</pre>

        <h5>is_array (obj)</h5>
        <p>Return <code>true</code> if <code>obj</code> is an array.</p>

        <h5>array_length (a)</h5>
        <p>Returns the number of elements in the array <code>a</code>.</p>

        <h5>array_at (a, i)</h5>
        <p>Returns the element in array <code>a</code> at index <code>i</code></p>
        
        <h5>array_set (a, i, obj)</h5>
        <p>Sets the element in array <code>a</code> at index <code>i</code> to <code>obj</code>.</p>

        <pre>
          > var a = array ([2, 4]);
          > a;
          => #[#[false, false, false, false], #[false, false, false, false]]
          > array_set (array_at (a, 1), 0, "hello");
          > a;
          => #[#[false, false, false, false], #["hello", false, false, false]]</pre>

        <h5>array_to_list (a)</h5>
        <p>Returns a new list with the elements in the array as its members.</p>

        <h5>array_copy (a)</h5>
        <p>Returns a newly allocated array with the same content as the array <code>a</code>. 
          Note that the elements are not recursively copied.</p>
        
        <h5>subarray (a, start, end)</h5>
        <p>This function is the array analog of the <code>substring</code> function. It returns a newly allocated array 
          formed from the elements of the array <code>a</code> beginning with index <code>start</code> (inclusive) and 
          ending with index <code>end</code> (exclusive).</p>        

        <h5>array_append (a1, a2, ..., aN)</h5>
        <p>This function is the array analog of the <code>string_append</code> function. It returns a newly allocated array 
          whose elements form the concatenation of the given arrays.</p>
        
        <h5>array_fill (a, fill)</h5>
        <p>Stores <code>fill</code> in every element of the array <code>a</code>.</p>

        <h5>subarray_fill (a, start, end, fill)</h5>
        <p>This function is like <code>array_fill</code>, but fills a selected part of the given array. It sets the elements 
          of the array <code>a</code>, beginning with index <code>start</code> (inclusive) and ending with index <code>end</code> 
          (exclusive) to <code>fill</code>.</p>

        <h5>subarray_move (src_a, src_start, src_end, dst_a, dst_start)</h5>
        <p>This function replaces part of the contents of array  <code>dst_a</code> with part of the contents of array
          <code>src_a</code>. It copies elements from <code>src_a</code>, beginning with index <code>src_start</code> (inclusive) 
          and ending with index <code>src_end </code>(exclusive) to <code>dst_a</code> beginning with index <code>dst_start</code>
          (inclusive). </p>

        <h5>array_shrink (a, k)</h5>
        <p>Shortens the array <code>a</code> so that its new size is <code>k</code>.</p>

        <h5>array_sort (a, @key test, type)</h5>
        <p>Sorts the array <code>a</code> by using <code>test</code> as the comparison predicate. 
          <code>test</code> defaults to <code>number_is_lt</code>.
          <code>type</code> specifies the sorting algorithm to use. An implementation is free to use any sorting algorithm. This implementation
          support quicksort and mergesort. So <code>type</code> can be either <code>!quick</code> or <code>!merge</code> and it defaults to
          <code>!quick</code>.</p>

        <h5>array_map (fn, a)</h5>
        <p>Applies the function <code>fn</code> to each element of the array <code>a</code>. Returns a new array that contains the
          results of calling <code>fn</code>.</p>

        <pre>
          > array_map (function (x) x * x, #[1, 2, 3, 4, 5]);
          => #[1, 4, 9, 16, 25]</pre>

        <h5>array_for_each (fn, a)</h5>
        <p>Similar to <code>array_map</code> but calls <code>fn</code> for its side-effect. Returns <code>void</code>.</p>

        <h5>array_reduce (a, fn, @key initial_value, start, end)</h5>
        <p>Compresses or folds the array <code>a</code> into a single value by recursively applying <code>fn</code> to 
          each element and the compressed result computed so far. If <code>initial_value</code> is not specified, 
          the first element of the array is treated as initial_value. The range of values that is folded can be limited by
          specifying the <code>start</code> and <code>end</code> indexes. They default to <code>0</code> and the length of the
          array respectively.</p>
        
        <h5>array_index_of (a, obj, @key test)</h5>
        <p>Returns the index of the element <code>obj</code> in the array <code>a</code>. <code>test</code> should be a
          equality predicate and it defaults to <code>is_eqv</code>. Returns -1 if <code>obj</code> is not present in the array.</p>

        <h3>Byte arrays</h3>
        <p>Byte arrays are homogeneous arrays containing only byte values. A byte value is in the range 0-255.
          A byte array literal is enclosed in a <code>#b[ ]</code>. Byte arrays are always single dimensional.</p>
        
        <h5>byte_array (size, @key fill)</h5>
        <p>Returns a byte array of size <code>size</code> and all elements initialized to <code>fill</code> which defaults to <code>0</code>.
          <code>fill</code> must be an integer in the range 0-255.</p>
        
        <h5>is_byte_array (obj)</h5>
        <p>Returns <code>true</code> is <code>obj</code> is a byte array.</p>

        <h5>byte_array_length (a)</h5>
        <p>Returns the number of bytes in the byte array <code>a</code>.</p>
        
        <h5>byte_array_at (a, i)</h5>
        <p>Returns the byte at index <code>i</code>.</p>
        
        <h5>byte_array_set (a, i, b)</h5>
        <p>Sets the byte at index <code>i</code> to <code>b</code>.</p>
        
        <h5>byte_array_to_list (a)</h5>
        <p>Returns a new list that contains the same elements as the byte array <code>a</code>.</p>

        <h5>list_to_byte_array (lst)</h5>
        <p>Returns a new byte array initialized with the same elements as the list <code>lst</code>.</p>
        
        <h5>byte_array_fill (a, fill)</h5>
        <p>Sets all elements of the byte array <code>a</code> to the value of <code>fill</code>.</p>
        
        <h5>byte_subarray_fill (a, start, end, fill)</h5>
        <p>Same as <code>byte_array_fill</code> but fills the starting from the index <code>start</code> (inclusive) to the index
          <code>end</code> (exclusive).</p>
        
        <h5>byte_array_append (a1, a2, ..., a3)</h5>
        <p>Returns a new byte array created by appending the given byte arrays.</p>

        <h5>byte_array_copy (a)</h5>
        <p>Returns a new byte arrays with elements copied from the byte array <code>a</code>.</p>

        <h5>byte_subarray (a, start, end)</h5>
        <p>Returns a new byte array with the elements taken from <code>a</code> starting at index <code>start</code> (inclusive)
          up to the index <code>end</code> (exclusive).</p>
        
        <h5>byte_subarray_move (src-a src-start src-end dst-a dst-start)</h5>
        <p>This function replaces part of the contents of the byte array  <code>dst_a</code> with part of the contents of byte array
          <code>src_a</code>. It copies elements from <code>src_a</code>, beginning with index <code>src_start</code> (inclusive) 
          and ending with index <code>src_end</code>(exclusive) to <code>dst_a</code> beginning with index <code>dst_start</code>
          (inclusive).</p>
                
        <h5>byte_array_shrink (a, k)</h5>
        <p>Shortens the byte array <code>a</code> so that its new size is <code>k</code>.</p>

        <h3>Bit arrays</h3>
        <p>Bit arrays are homogeneous arrays containing only bits. A bit array has no literal representation.</p>

        <h5>bit_array (n)</h5>
        <p>Returns a new bit array with all bits set to <code>0</code>.</p>

        <h5>is_bit_array (obj)</h5>
        <p>Returns <code>true</code> if <code>obj</code> is a bit array. </p>
        <pre>
          > var a = bit_array (100);
          > is_bit_array (a);
          => true</pre>

        <h5>bit_array_set (a, i)</h5>
        <p>Turns on the bit at index <code>i</code>.</p>

        <h5>bit_array_is_set (a, i)</h5>
        <p>Returns <code>true</code> if the bit at index <code>i</code> is on.</p>
        <pre>
          > bit_array_is_set (a, 10);
          => false
          > bit_array_set (a, 10);
          > bit_array_is_set (a, 10);
          => true</pre>

        <h5>bit_array_clear (a, i)</h5>
        <p>Turns off the bit at index <code>i</code>.</p>
        <pre>
          > bit_array_clear (a, 10);
          > bit_array_is_set (a, 10);
          => false</pre>

        <h5>bit_array_set_all (a)</h5>
        <p>Turns on all bits in the array.</p>
        
        <h5>bit_array_clear_all (a)</h5>
        <p>Turns off all bits in the array.</p>
        <pre>
        > bit_array_set_all (a);
        > bit_array_is_set (a, 10);
        => true
        > bit_array_is_set (a, 11);
        => true
        > bit_array_clear_all (a);
        > bit_array_is_set (a, 11);
        => false
        > bit_array_is_set (a, 10);
        => false
        > bit_array_is_set (a, 99);
        => false</pre>

        <h5>bit_array_length (a)</h5>
        <p>Returns the number of bits in the array.</p>

        <h5>bit_array_map (fn, a)</h5>
        <p>Applies the function <code>fn</code> to all elements of the bit array <code>a</code>.
          <code>fn</code> must return either 1 or 0. A new bit array is returned which contains these values.</p>
        <pre>
          > var a = bit_array (100);
          > bit_array_set (a, 10);
          > bit_array_set (a, 20);
          > bit_array_set (a, 30);
          > bit_array_is_set (a, 10);
          => true
          > bit_array_is_set (a, 20);
          => true
          > bit_array_is_set (a, 30);
          => true

          // map over the bit array and invert each bit:
          > var a_inverse = bit_array_map (function (flag) if flag == 1 0 else 1, a);
          > bit_array_is_set (a_inverse, 10);
          => false
          > bit_array_is_set (a_inverse, 11);
          => true
          > bit_array_is_set (a_inverse, 20);
          => false
          > bit_array_is_set (a_inverse, 19);
          => true
          > bit_array_is_set (a_inverse, 21);
          => true</pre>

        <h5>bit_array_for_each (fn, a)</h5>
        <p>Similar to <code>bit_array_map</code> but <code>fn</code> is called for its side-effect.</p>
        <pre>
          > var c = 0;
          > bit_array_for_each (function (flag) if flag == 1 { c = c + 1 }, a);
          > c; // number of on bits in the array.
          => 3</pre>

          <h5>bit_array_is_all_set (a)</h5>
          <p>Returns <code>true</code> if all bits are on in <code>a</code>.</p>

        <h5>bit_array_is_any_set (a)</h5>
          <p>Returns <code>true</code> if at least one bit is on in <code>a</code>.</p>

        <h5>bit_array_to_list (a)</h5>
        <p>Returns a new list of integers (with values 1 or 0) initialized from the bits in <code>a</code>.</p>

        <h5>list_to_bit_array (lst)</h5>
        <p>Returns a new bit array initialized from a list of integer 1 and 0.</p>

        <h5>bit_array_to_string (a)</h5>
        <p>Returns a string of characters '1' and '0' initialized from the bits in <code>a</code>.</p>
        <pre>
          > var a = bit_array (3);
          > bit_array_set (a, 1);
          > bit_array_to_string (a);
          => "010"</pre>

        <h5>string_to_bit_array (s)</h5>
        <p>Returns a new bit array initialized from a string of '0's and '1's.</p>
        <pre>
          > a = string_to_bit_array ("0000111");
          > bit_array_to_string (a);
          => "0000111"</pre>

        <h5>bit_array_is_eq (a, b)</h5>
        <p>Returns <code>true</code> if the two bit arrays have the same bit patterns.</p>

        <h5>bit_array_blit (a, start, dest, dest_start, n)</h5>
        <p>Compares bits in <code>a</code> with those in <code>dest</code> starting at the index <code>start</code>.
          <code>dest_start</code> is the index in <code>dest</code> where the comparison should start.
          If a bit is on in <code>a</code> the same bit is turned on in <code>dest</code>.
          If a bit is off in <code>a</code> the same bit is turned on in <code>dest</code>.
          <code>n</code> bits are compared.</p>

        <pre>
          > var a = string_to_bit_array ("0000011111000");
          > var b = string_to_bit_array ("1111111111111");
          > bit_array_to_string (b);
          => "0000011111011"</pre>

        <h5>bit_array_reduce (a, fn, @key initial_value, from_right)</h5>
        <p>Compresses <code>a</code> to a single bit by repeatedly applying <code>fn</code> to each bit and the result
          computed so far. By default, <code>initial_value</code> is 0 and <code>from_right</code> is <code>false</code>.</p>
        
        <h5>bit_array_append (a, b)</h5>
        <h5>bit_array_concat (lst)</h5>
        <p><code>bit_array_append</code> returns a new bit array created by appending <code>b</code> to <code>a</code>.</p>
        <p><code>bit_array_concat</code> takes a list of bit arrays as argument and returns a single bit array which is a 
          concatenation of all of them.</p>

        <h5>bit_subarray (a, start, end)</h5>
        <p>Returns a new bit array constructed from the bits in <code>a</code> starting at the index <code>start</code> (inclusive)
          up to the index <code>end</code> (exclusive).</p>

        <h3><div id="tables">Tables</div></h3>
        <p>Tables are heterogeneous structures whose elements are indexed by keys which are arbitrary objects. 
          Tables are similar to association lists but are abstract and the access time for large tables is typically smaller.
          Each key contained in the table is bound to a value. The length of the table is the number of key/value bindings 
          it contains. New key/value bindings can be added to a table, the value bound to a key can be changed, and existing 
          key/value bindings can be removed.</p>
        <p>The references to the keys can either be all strong or all table-weak and the references to the values 
          can either be all strong or all table-weak. The garbage collector removes key/value bindings from a table when 
          <ol>
          <li>the key is a table-weak reference and the key is unreachable or only reachable using paths from the roots
            that traverse at least one table-weak reference, or </li>
          <li>the value is a table-weak reference and the value is unreachable or only reachable using paths from the roots 
            that traverse at least one table-weak reference. Key/value bindings that are removed by the garbage collector are 
            reclaimed immediately.</li>
          </ol></p>
        <p>This implementation of Slogan implements tables using hashing with open-addressing. This is space efficient and 
          provides constant-time access. Hash tables are automatically re-sized to maintain the load within specified bounds. 
          The load is the number of active entries (the length of the table) divided by the total number of entries in the hash table.</p>
        <h5>table (@key size, init, weak_keys, weak_values, test, hash, min_load, max_load)</h5>
        <p>Returns a new table. The optional keyword parameters specify various parameters of the table.</p>
        <p><ul>
            <li><code>size</code> - a non-negative integer indicating the expected length of the table. The system uses 
              size to choose an appropriate initial size of the hash table so that it does not need to be re-sized too often.</li>
            <li><code>init</code> - indicates a value that is associated to keys that are not in the table. When not specified, 
              the boolean value <code>false</code> is associated to keys that are not in the table.</li>
            <li><code>weak_keys</code> and <code>weak_values</code> - booleans indicating respectively whether the keys and values 
              are table-weak references (<code>true</code>) or strong references (<code>false</code>). 
              By default the keys and values are strong references. An implementation is free to ignore these parameters.</li>
            <li><code>test</code> -  indicates the key comparison procedure. The default key comparison procedure is <code>is_equal</code>. 
              The key comparison procedures <code>is_eq</code>, <code>is_eqv</code>, <code>is_equal</code>, <code>string_is_eq</code>
              and <code>string_ci_is_eq</code> are special because the system will use a reasonably good hash procedure when none is 
              specified.</li>
            <li><code>hash</code> - indicates the hash procedure. This procedure must accept a single key parameter, 
              return a fixnum, and be consistent with the key comparison procedure. When hash is not specified, 
              a default hash procedure is used.</li>
            <li><code>min_load</code> and <code>max_load</code> parameters are real numbers that indicate the minimum and maximum 
              load of the table respectively. The table is re-sized when adding or deleting a key/value binding would bring the table's 
              load outside of this range. The min_load parameter must be no less than 0.05 and the max_load parameter must be no 
              greater than 0.95. Moreover the difference between min_load and max_load must be at least 0.20. When min_load is not 
              specified, the value 0.45 is used. When max_load is not specified, the value 0.90 is used.</li>
          </ul></p>

        <h5>is_table (obj)</h5>
        <p>Returns <code>true</code> if <code>obj</code> is a table.</p>
        
        <h5>table_length (table)</h5>
        <p>Returns the number of key-value pairs in the table.</p>
        
        <h5>table_at (table, key, @optional default)</h5>
        <p>Returns the value mapped to <code>key</code> in the table. If the value is not found, <code>default</code> is returned.
          If <code>default</code> is not specified, the "Unbound table key" error is raised.</p>

        <h5>table_set (table, key, @optional value)</h5>
        <p>Maps <code>key</code> to <code>value</code> in the table.</p>
        
        <h5>table_search (fn, table)</h5>
          <p>Searches the table table for a key/value binding for which the two parameter function <code>fn</code> returns a non 
            false result. For each key/value binding visited by <code>table_search</code> the function <code>fn</code> is called with 
            the key as the first parameter and the value as the second parameter. <code>table_search</code> returns the first non 
            false value returned by <code>fn</code>, or <code>false</code> if <code>fn</code> returned <code>false</code> for
            all key/value bindings in table.</p>

          <p>The order in which the key/value bindings are visited is unspecified and may vary from one call of 
            <code>table_search</code> to the next. While a call to <code>table_search</code> is being performed on table, 
            it is an error to call any of the following procedures on table: <code>table_at</code>, <code>table_set</code>, 
            <code>table_search</code>, <code>table_for_each</code>, <code>table_copy</code>, <code>table_merge_in_place</code>, 
            <code>table_merge</code> and <code>table_to_list</code>. It is also an error to compare with <code>is_equal</code>
            (directly or indirectly with <code>member</code>, <code>table_at</code> etc.) an object that contains <code>table</code>. 
            All these functions may cause <code>table</code> to be reordered and re-sized. This restriction allows a more efficient 
            iteration over the key/value bindings.</p>

        <h5>table_for_each (fn, table)</h5>
          <p>Calls the two parameter functions <code>fn</code> for each key/value binding in the table <code>table</code>. 
            The <code>fn</code> is called with the key as the first parameter and the value as the second parameter. The restrictions
            applicable for <code>table_search</code> is also valid for <code>table_for_each</code>.</p>
        
        <h5>table_to_list (table)</h5>
        <p>Returns an association list containing the key/value bindings in the table <code>table</code>. 
          The order of the bindings in the list is unspecified. (Also see <code>list_to_table</code> in the <a href="pairs.html">
            lists</a> documentation).</p>

        <h5>table_copy (table)</h5>
          <p>Returns a new table containing the same key/value bindings as <code>table</code> and the same table parameters.</p>

        <h5>table_merge_in_place (table1, table2, @optional table2_first)</h5> 
          <p>Returns <code>table1</code> after the key/value bindings contained in <code>table2</code> have been added to it. 
            When a key exists both in <code>table1</code> and <code>table2</code>, then the parameter <code>table2_first</code> 
            indicates which binding will be kept (the one in <code>table1</code> if <code>table2_first</code> is <code>false</code>, 
            and the one in <code>table2</code> otherwise). <code>table2_first</code> defaults to <code>false</code>.</p>

        <h5>table_merge (table1, table2, @optional table2_first)</h5> 
        <p>Same as <code>table_merge_in_place</code> but instead of modifying <code>table1</code> in-place, 
          returns a copy of <code>table1</code> after the key/value bindings contained in <code>table2</code> have been added to it.</p>
      </div>
    </div>
  </body>
</html>
