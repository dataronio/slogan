<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Arrays, Byte arrays, Bit arrays and Tables</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Arrays, Byte arrays, Bit arrays and Tables</h2>
        
        <h3>Arrays</h3>
        <p>Arrays are heterogenous structures whose elements are indexed by integers. An array typically occupies less space 
          than a list of the same length, and the average time required to access a randomly chosen element is typically less 
          for the array than for the list. Arrays can have multiple dimensions. Array literals are encolsed in a <code>#[ ]</code>.</p>

        <h5>array (dim, @key fill)</h5>
        <p>Creates a new array of dimension <code>dim</code> with all elements initialized to <code>fill</code>.
          The dimension can be an integer or a list of integers.
          If it is an integer a single-dimensional array is returned, otherwise a multi-dimensional array is returned.
          There are no implicit limits to the number of dimensions, except for available memory.
          <code>fill</code> defaults to <code>false</code>. If <code>fill</code> is a procedure it is called for each
          slot in the array and the slot is filled-up with the result.</p>

        <pre>
          > array (10);
          => #[false, false, false, false, false, false, false, false, false, false]
          > array (10, fill = 'a');
          #['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
          > array ([2, 4], fill = 0); // as array of two rows and four columns.
          #[#[0, 0, 0, 0], #[0, 0, 0, 0]]</pre>

        <h5>is_array (obj)</h5>
        <p>Return <code>true</code> if <code>obj</code> is an array.</p>

        <h5>array_length (a)</h5>
        <p>Returns the number of elements in the array <code>a</code>.</p>

        <h5>array_at (a, i)</h5>
        <p>Returns the element in array <code>a</code> at index <code>i</code></p>
        
        <h5>array_set (a, i, obj)</h5>
        <p>Sets the element in array <code>a</code> at index <code>i</code> to <code>obj</code>.</p>

        <pre>
          > var a = array ([2, 4]);
          > a;
          => #[#[false, false, false, false], #[false, false, false, false]]
          > array_set (array_at (a, 1), 0, "hello");
          > a;
          => #[#[false, false, false, false], #["hello", false, false, false]]</pre>

        <h5>array_to_list (a)</h5>
        <p>Retruns a new list with the elements in the array as its members.</p>

        <h5>array_copy (a)</h5>
        <p>Returns a newly allocated array with the same content as the array <code>a</code>. 
          Note that the elements are not recursively copied.</p>
        
        <h5>subarray (a, start, end)</h5>
        <p>This function is the array analog of the <code>substring</code> function. It returns a newly allocated array 
          formed from the elements of the array <code>a</code> beginning with index <code>start</code> (inclusive) and 
          ending with index <code>end</code> (exclusive).</p>        

        <h5>array_append (a1, a2, ..., aN)</h5>
        <p>This function is the array analog of the <code>string_append</code> function. It returns a newly allocated array 
          whose elements form the concatenation of the given arrays.</p>
        
        <h5>array_fill (a, fill)</h5>
        <p>Stores <code>fill</code> in every element of the array <code>a</code>.</p>

        <h5>subarray_fill (a, start, end, fill)</h5>
        <p>This function is like <code>array_fill</code>, but fills a selected part of the given array. It sets the elements 
          of the array <code>a</code>, beginning with index <code>start</code> (inclusive) and ending with index <code>end</code> 
          (exclusive) to <code>fill</code>.</p>

        <h5>subarray_move (src_a, src_start, src_end, dst_a, dst_start)</h5>
        <p>This function replaces part of the contents of array  <code>dst_a</code> with part of the contents of array
          <code>src_a</code>. It copies elements from <code>src_a</code>, beginning with index <code>src_start</code> (inclusive) 
          and ending with index <code>src_end </code>(exclusive) to <code>dst_a</code> beginning with index <code>dst_start</code>
          (inclusive). </p>

        <h5>array_shrink (a, k)</h5>
        <p>Sortens the array <code>a</code> so that its new size is <code>k</code>.</p>

        <h5>array_sort (a, @key test, type)</h5>
        <p>Sorts the array <code>a</code> by using <code>test</code> as the comparison predicate. 
          <code>test</code> defaults to <code>number_is_lt</code>.
          <code>type</code> specifies the sorting algorithm to use. An implementation is free to use any sorting algorithm. This implementation
          support quicksort and mergesort. So <code>type</code> can be either <code>!quick</code> or <code>!merge</code> and it defaults to
          <code>!quick</code>.</p>

        <h5>array_map (fn, a)</h5>
        <p>Applies the function <code>fn</code> to each element of the array <code>a</code>. Returns a new array that contains the
          results of calling <code>fn</code>.</p>

        <pre>
          > array_map (function (x) x * x, #[1, 2, 3, 4, 5]);
          => #[1, 4, 9, 16, 25]</pre>

        <h5>array_for_each (fn, a)</h5>
        <p>Similar to <code>array_map</code> but calls <code>fn</code> for its side-effect. Returns <code>void</code>.</p>

        <h5>array_reduce (a, fn, @key initial_value)</h5>
        <p>Compresses or folds the array <code>a</code> into a single value by recursively applying <code>fn</code> to 
          each element and the compressed result computed so far. If <code>initial_value</code> is not specified, 
          the first element of the array is treated as initial_value.</p>
        
        <h5>array_index_of (a, obj, @key test)</h5>
        <p>Returns the index of the element <code>obj</code> in the array <code>a</code>. <code>test</code> should be a
          equality predicate and it defaults to <code>is_eqv</code>. Returns -1 if <code>obj</code> is not present in the array.</p>

        <h3>Byte arrays</h3>
        <p>Byte arrays are homogeneous arrays containing only byte values. A byte value is in the range 0-255.
          A byte array literal is enclosed in a <code>#b[</code> and a <code>]</code>. Byte arrays are single dimensional.</p>
        
        <h5>byte_array (dim, @key fill)</h5>
        
        <h5>is_byte_array (obj)</h5>

        <h5>byte_array_length (a)</h5>
        
        <h5>byte_array_at (a, i)</h5>
        
        <h5>byte_array_set (a, i, b)</h5>
        
        <h5>byte_array_to_list (a)</h5>

        <h5>list_to_byte_array (lst)</h5>
        
        <h5>byte_array_fill (a, fill)</h5>
        
        <h5>byte_subarray_fill (a, start, end, fill)</h5>
        
        <h5>byte_array_append (a1, a2, ..., a3)</h5>

        <h5>byte_array_copy (a)</h5>

        <h5>byte_subarray (a, start, end)</h5>
        
        <h5>byte_subarray_move (src-a src-start src-end dst-a dst-start)</h5>
        
        <h5>byte_array_shrink (a, k)</h5>

        <h3>Bit arrays</h3>
        <p>Bit arrays are homogeneous arrays containing only bits.</p>

        <h5>bit_array (n)</h5>

        <h5>is_bit_array (obj)</h5>

        <h5>bit_array_set (a, i)</h5>

        <h5>bit_array_is_set (a, i)</h5>

        <h5>bit_array_clear (a, i)</h5>

        <h5>bit_array_set_all (a)</h5>
        <h5>bit_array_clear_all (a)</h5>

        <h5>bit_array_length (a)</h5>

        <h5>bit_array_map (fn, a)</h5>

        <h5>bit_array_for_each (fn, a)</h5>

        <h5>bit_array_is_all_set (a)</h5>

        <h5>bit_array_is_any_set (a)</h5>

        <h5>bit_array_to_list (a)</h5>

        <h5>list_to_bit_array (lst)</h5>

        <h5>bit_array_to_string (a)</h5>

        <h5>string_to_bit_array (s)</h5>

        <h5>bit_array_is_eq (a, b)</h5>

        <h5>bit_array_blit (a, start, dest, dest-start, n)</h5>

        <h5>bit_array_reduce (a, fn, @key initial_value, from_right)</h5>
        
        <h5>bit_array_append (a, b)</h5>
        <h5>bit_array_concat (lst)</h5>

        <h5>bit_subarray (a, start, end)</h5>

        <h3>Tables</h3>
        <p>Tables are heterogenous structures whose elements are indexed by keys which are arbitrary objects. 
          Tables are similar to association lists but are abstract and the access time for large tables is typically smaller.
          Each key contained in the table is bound to a value. The length of the table is the number of key/value bindings 
          it contains. New key/value bindings can be added to a table, the value bound to a key can be changed, and existing 
          key/value bindings can be removed.</p>
        <p>The references to the keys can either be all strong or all table-weak and the references to the values 
          can either be all strong or all table-weak. The garbage collector removes key/value bindings from a table when 
          <ol>
          <li>the key is a table-weak reference and the key is unreachable or only reachable using paths from the roots
            that traverse at least one table-weak reference, or </li>
          <li>the value is a table-weak reference and the value is unreachable or only reachable using paths from the roots 
            that traverse at least one table-weak reference. Key/value bindings that are removed by the garbage collector are 
            reclaimed immediately.</li>
          </ol></p>
        <p>This implementation of Slogan implements tables using hashing with open-addressing. This is space efficient and 
          provides constant-time access. Hash tables are automatically resized to maintain the load within specified bounds. 
          The load is the number of active entries (the length of the table) divided by the total number of entries in the hash table.</p>
        <h5>table (@key size, init, weak_keys, weak_values, test, hash, min_load, max_load)</h5>
        <p>Returns a new table. The optional keyword parameters specify various parameters of the table.</p>
        <p><ul>
            <li><code>size</code> - a nonnegative integer indicating the expected length of the table. The system uses 
              size to choose an appropriate initial size of the hash table so that it does not need to be resized too often.</li>
            <li><code>init</code> - indicates a value that is associated to keys that are not in the table. When not specified, 
              the boolean value <code>false</code> is associated to keys that are not in the table.</li>
            <li><code>weak_keys</code> and <code>weak_values</code> - booleans indicating respectively whether the keys and values 
              are table-weak references (<code>true</code>) or strong references (<code>false</code>). 
              By default the keys and values are strong references. An implementation is free to ignore these parameters.</li>
            <li><code>test</code> -  indicates the key comparison procedure. The default key comparison procedure is <code>is_equal</code>. 
              The key comparison procedures <code>is_eq</code>, <code>is_eqv</code>, <code>is_equal</code>, <code>string_is_eq</code>
              and <code>string_ci_is_eq</code> are special because the system will use a reasonably good hash procedure when none is 
              specified.</li>
            <li><code>hash</code> - indicates the hash procedure. This procedure must accept a single key parameter, 
              return a fixnum, and be consistent with the key comparison procedure. When hash is not specified, 
              a default hash procedure is used.</li>
            <li><code>min_load</code> and <code>max_load</code> parameters are real numbers that indicate the minimum and maximum 
              load of the table respectively. The table is resized when adding or deleting a key/value binding would bring the table's 
              load outside of this range. The min_load parameter must be no less than 0.05 and the max_load parameter must be no 
              greater than 0.95. Moreover the difference between min_load and max_load must be at least 0.20. When min_load is not 
              specified, the value 0.45 is used. When max_load is not specified, the value 0.90 is used.</li>
          </ul></p>

        <h5>is_table (obj)</h5>
        
        <h5>table_length (table)</h5>
        
        <h5>table_at (table, key, @optional default)</h5>

        <h5>table_set (table, key, @optional value)</h5>
        
        <h5>table_search (fn, table)</h5>

        <h5>table_for_each (fn, table)</h5>
        
        <h5>table_to_list (table)</h5>

        <h5>list_to_table (lst)</h5>

        <h5>table_copy (table)</h5>

      </div>
    </div>
  </body>
</html>
