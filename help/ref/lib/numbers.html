<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Numbers</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Numbers</h2>
	<p>Numerical operations are fundamental to most computational work. Slogan abstracts the representation of numbers
	  while trying to keep numerical functions as efficient as possible. A Slogan number is either an <em>integer</em>,
	  a <em>real</em> or a <em>complex</em>. An implementation of Slogan should support these three basic number types. 
	  Integers should be of arbitrary precision.
	  For the real type, an implementation is free to choose the exactness with which they are represented. There are no restrictions on the
	  internal representation of numbers. An implementation may choose to use the machine dependent integer and real number representation
	  wherever possible. In such cases, the <em>fixnum</em> and <em>flonum</em> functions allow the direct manipulation of machine dependent integer
	  and real values respectively.</p>

	<h3>Syntax of numerical constants</h3>
	<p>Digits in the range <code>0-9</code> makes up an integer. The following are all valid integer constants:</p>
	<pre>
	10;
	3499090190;
	323921345749875598743958743598734593475934759345;</pre>	
	<p>A number may be written in binary, octal, decimal, or hexadecimal by the use of a radix prefix. The radix prefixes are
	  <code>0b</code> (binary), <code>0o</code> (octal), <code>0d</code> (decimal) and <code>0x</code> (hexadecimal). Here is the
	  number <code>15</code> written using the different radix prefixes:</p>
	<pre>
	  > 0d15;
	  => 15
	  > 0b1111;
	  => 15
	  > 0o17;
	  => 15
	  > 0xf;
	  => 15 </pre>
	<p>Floating-point constants are usually written in decimal notation. Scientific notation may be used by adding 
	  e or E followed by a decimal exponent:</p>
	<pre>
	  > 1.23
	  => 1.23
	  > 1.23e2
	  => 123.</pre>
	<p>The following real constants represent values significant for IEEE floating point conformant arithmetic:</p>
	<p><ul>
	    <li><code>+inf.0</code> - positive infinity.</li>
	    <li><code>-inf.0</code> - negative infinity.</li>
	    <li><code>+nan.0</code> - not-a-number.</li>
	    <li><code>-0.</code> - negative zero (<code>0.</code> is the positive zero).</li>
	  </ul></p>
	<p>A complex number is written with the real part and the imaginary part separated by a <code>#</code> symbol:</p>
	<pre>
	  > 3#4;
	  => 3#4
	  > real_part (3#4);
	  => 3
	  > imag_part (3#4);
	  => 4</pre>

	<h3>Predicates</h3>

	<h5>is_number (obj)</h5>
	<h5>is_integer (obj)</h5>
	<h5>is_real (obj)</h5>
	<h5>is_complex (obj)</h5>

	<p>These predicates can be applied to any object. They return <code>true</code> if the object is a numeric value of
	  the named type.</p>

	<pre>
	  > is_number (10#45);
	  => true
	  > is_integer (10#45);
	  => false
	  > is_real (10#45);
	  => false
	  > is_real (10.45);
	  => true
	  > is_complex (10#45);
	  => true
	  > is_complex (10.45); // complex is more generic than real.
	  => true</pre>

	<h5>is_number_eq (n1, n2, ..., nN)</h5>
	<h5>is_number_lt (n1, n2, ..., nN)</h5>
	<h5>is_number_gt (n1, n2, ..., nN)</h5>
	<h5>is_number_lteq (n1, n2, ..., nN)</h5>
	<h5>is_number_gteq (n1, n2, ..., nN</h5>

	<p>These functions return <code>true</code> if their arguments are (respectively): equal, monotonically increasing, 
	  monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing. The implementation dependent
	  exactness of numeric representation can influence the result of these functions. The operators <code>==</code>,
	  <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> produce the same results as these 
	  functions when called with two arguments.</p>

	<pre>
	  > is_number_eq (10, 10);
	  => true
	  > is_number_eq (10, 10.0);
	  => true
	  > is_number_eq (10, 10.01);
	  => false
	  > is_number_lt (10, 10.01, 10.001);
	  => false
	  > is_number_lt (10, 10.01, 10.02);
	  => true
	  > is_number_lt (10, 10.01, 10.02, 10.003);
	  => false</pre>

	<h5>is_zero (n)</h5>
	<h5>is_positive (n)</h5>
	<h5>is_negative (n)</h5>
	<h5>is_odd (n)</h5>
	<h5>is_even (n)</h5>
	<h5>is_nan (n)</h5>
	<h5>is_positive_infinity (n)</h5>
	<h5>is_negative_infinity (n)</h5>
        <h5>is_fixnum</h5>
        <h5>is_flonum</h5>

	<p>These functions check a number for a particular property identified by the function name.</p>

        <h3>Arithmetic and related functions</h3>

        <h5>max (n1, n2, ..., nN)</h5>
        <h5>min (n1, n2, ..., nN)</h5>

        <p>These functions return the maximum or minimum of their arguments.</p>

        <pre>
          > max (1, 2, 5, 3);
          => 5
          > min (1.001, 1.01, 1.00001);
          => 1.00001</pre>

        <h5>add (n1, n2, ..., nN)</h5>
        <h5>mult (n1, n2, ..., nN)</h5>

        <p>These functions return the sum or product of their arguments.</p>

        <pre>
          > add (3, 4, 5);
          => 12
          > add (3);
          => 3
          > mult (3, 4, 5);
          => 60
          > mult ();
          => 1
          > add();
          => 0</pre>
        
        <h5>sub (n1, n2, ..., nN)</h5>
        <h5>div (n1, n2, ..., nN)</h5>
        
        <p>With two or more arguments, these procedures return the difference or quotient of their arguments, associating to the left. 
          With one argument, however, they return the additive or multiplicative inverse of their argument.</p>

        <pre>
          > sub (3, 4, 5);
          => -6
          > sub (3);
          => -3
          > div (3, 4, 5);
          => .15
          > div (3);
          => .3333333333333333</pre>
        
        <h5>abs (n)</h5>
        <p><code>abs</code> returns the absolute value of its argument.</p>
        <pre>
          > abs (-7);
          => 7</pre>
        
        <h5>quotient (n1, n2)</h5>
        <h5>remainder (n1, n2)</h5>
        <h5>modulo (n1, n2)</h5>
        <p>These procedures implement number-theoretic (integer) division. <code>n2</code> should be non-zero. 
          All three procedures return integers. If <code>n1 / n2</code> is an integer:</p>
        <pre>
          quotient (n1, n2)  ==> n1 / n2
          remainder (n1, n2) ==> 0
          modulo (n1, n2)    ==> 0</pre>

        <p>If <code>n1 / n2</code> is not an integer:</p>

        <pre>
          quotient (n1, n2)  ==> nq
          remainder (n1, n2) ==> nr
          modulo (n1, n2)    ==> nm</pre>

        <p>where <code>nq</code> is <code>n1 / n2</code> rounded towards zero, <code>0 &lt; |nr| &lt; |n2|</code>, 
          <code>0 &lt; |nm| &lt; |n2|</code>, <code>nr</code> and <code>nm</code> differ from <code>n1</code> by a multiple of <code>n2</code>, 
          <code>nr</code> has the same sign as <code>n1</code>, and <code>nm</code> has the same sign as <code>n2</code>.</p>

        <p>From this we can conclude that for integers <code>n1</code> and <code>n2</code> with <code>n2</code> not equal to <code>0</code>,</p>
        
        <pre>
          n1 == (remainder (n1, n2) + n2 * quotient (n1, n2)) ==> true</pre>
        <pre>
          > modulo (13, 4);
          => 1
          > remainder (13, 4);
          => 1
          > modulo (-13, 4);
          => 3
          > remainder (-13, 4);
          => -1
          > -13 == (remainder (-13, 4) + 4 * quotient (-13, 4));
          => true</pre>
        <h5>gcd (n1, n2, ..., nN)</h5>
        <h5>lcm (n1, n2, ..., nN)</h5>
        <p>These functions return the greatest common divisor or least common multiple of their arguments. The result is always non-negative.</p>
        <pre>
          > gcd (32, 36);
          => 4
          > gcd();
          => 0
          > lcm (32, 36);
          => 288
          > lcm();
          => 1
          > lcm (32.0, -36);
          => 288.</pre>
        <h5>numerator (q)</h5>
        <h5>denominator (q)</h5>
        <p>These functions return the numerator or denominator of their argument; the result is computed as if the argument was 
          represented as a fraction in lowest terms. The denominator is always positive. The denominator of <code>0</code> is 
          defined to be <code>1</code>.</p>
        <pre>
          > numerator (6/4);
          => 3
          > denominator (6/4);
          => 2</pre>

        <h5>floor (x)</h5>
        <h5>ceiling (x)</h5>
        <h5>truncate (x)</h5>
        <h5>round (x)</h5>
        <p>These procedures return integers. <code>floor</code> returns the largest integer not larger than <code>x</code>. 
          <code>ceiling</code> returns the smallest integer not smaller than <code>x</code>. 
          <code>truncate</code> returns the integer closest to <code>x</code> whose absolute value is not larger than the absolute 
          value of <code>x</code>. <code>round</code> returns the closest integer to <code>x</code>, rounding to even when 
          <code>x</code> is halfway between two integers. <code>round</code> rounds to even for consistency with the default rounding 
          mode specified by the IEEE floating point standard.</p> 
        <pre>
          > floor (3.5);
          => 3.
          > ceiling (3.5);
          => 4.
          > truncate (3.5);
          => 3.
          > round (3.5);
          => 4.</pre>

        <h5>rationalize (x, y)</h5>
        <p><code>rationalize</code> returns the simplest rational number differing from <code>x</code> by no more than <code>y</code>.</p>
        <pre>
          > rationalize (.3, 1 / 10);
          => .3333333333333333</pre>

        <h5>exp (z)</h5>
        <h5>log (z)</h5>
        <h5>sin (z)</h5>
        <h5>cos (z)</h5>
        <h5>tan (z)</h5> 
        <h5>asin (z)</h5>
        <h5>acos (z)</h5>
        <h5>atan (z)</h5>
        <h5>atan (y, x)</h5> 
        <p>These functions compute the usual transcendental functions. <code>log</code> computes the natural logarithm of <code>z</code> 
          (not the base ten logarithm). <code>asin</code>, <code>acos</code>, and <code>atan</code> compute 
          arcsine (<code>sin</code><sup>-1</sup>), arccosine (<code>cos</code><sup>-1</sup>), and arctangent (<code>tan</code><sup>-1</sup>), 
          respectively. The two-argument variant of <code>atan</code> computes 
          <code>angle (rectangular (x, y))</code> (see below), even in implementations that don't support general complex numbers.</p>
        
        <h5>rectangular (x1, x2)</h5>
        <h5>polar (x3, x4)</h5>
        <h5>real_part (z)</h5>
        <h5>imag_part (z)</h5>
        <h5>magnitude (z)</h5>
        <h5>angle (z)</h5>
        <p>These functions are part of every implementation that supports general complex numbers. <code>magnitude</code> is the same 
          as <code>abs</code> for a real argument, but <code>abs</code> must be present in all implementations, whereas 
          <code>magnitude</code> need only be present in implementations that support general complex numbers.</p>

        <h5>sqrt (z)</h5>
        <p>Returns the principal square root of <code>z</code>. The result will have either positive real part, 
          or zero real part and non-negative imaginary part.</p>

        <h5>integer_sqrt (n)</h5>
        <p>Returns the integer part of the square root of the nonnegative exact integer <code>n</code>.</p>

        <h5>integer_nth_root (n1, n2)</h5>
        <p>Returns the integer part of <code>n1</code> raised to the power <code>1/n2</code>, where <code>n1</code> is a 
          nonnegative exact integer and <code>n2</code> is a positive exact integer.</p>

        <h5>expt (z1, z2)</h5>
        <p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
        
        <h3>Conversions</h3>

        <h5>number_to_string (z, @optional radix)</h5>
        <h5>string_to_number (z, @optional radix)</h5>
        <p>These functions converts a number to its string representation and vice versa. Radix must be an exact integer, 
          either 2, 8, 10, or 16. If omitted, <code>radix</code> defaults to 10.</p>

        <h5>char_to_integer (c)</h5>
        <h5>integer_to_char (n)</h5>
        <p><code>char_to_integer</code> returns the unicode encoding of a character. <code>integer_to_char</code> returns the character
          whose unicode encoding is the exact integer <code>n</code>.</p>

        <h5>real_to_integer (r)</h5>
        <h5>integer_to_real (n)</h5>
        <p>These functions converts between integers and reals.</p>

        <h3>Pseudo random numbers</h3>

        <h5>random_integer (n)</h5>
        <p>Returns a pseudo random exact integer in the range 0 to n-1. </p>
        <pre>
          > random_integer (10);
          => 8
          > random_integer (10);
          => 2</pre>

        <h5>random_real (r)</h5>
        <p>Returns a pseudo random real between, but not including, 0 and 1.</p>
        <pre>
          > random_real ();
          => .7342236104231586
          > random_real ();
          => .8162050798467028</pre>

        <h5>random_byte_array (n)</h5>
        <p>Returns a byte array of length <code>n</code> containing pseudo random exact integers in the range 0 to 255. </p>
        <pre>
          > random_byte_array (10);
          => #b[200, 53, 29, 202, 3, 85, 208, 187, 73, 219]
          > random_byte_array (10);
          => #b[113, 8, 182, 120, 138, 103, 53, 192, 40, 176]</pre>

        <h3>Fixnum and Flonum operations</h3>
      </div>
    </div>
  </body>
</html>
