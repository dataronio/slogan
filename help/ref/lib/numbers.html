<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Numbers</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Numbers</h2>
	<p>Numerical operations are fundamental to most computational work. Slogan abstracts the representation of numbers
	  while trying to keep numerical functions as efficient as possible. A Slogan number is either an <em>integer</em>,
	  a <em>real</em> or a <em>complex</em>. An implementation of Slogan should support these three basic number types. 
	  Integers should be of arbitrary precision.
	  For the real type, an implementation is free to choose the exactness with which they are represented. There are no restrictions on the
	  internal representation of numbers. An implementation may choose to use the machine dependent integer and real number representation
	  wherever possible. In such cases, the <em>fixnum</em> and <em>flonum</em> functions allow the direct manipulation of machine dependent integer
	  and real values respectively.</p>

	<h3>Syntax of numerical constants</h3>
	<p>Digits in the range <code>0-9</code> makes up an integer. The following are all valid integer constants:</p>
	<pre>
	10;
	3499090190;
	323921345749875598743958743598734593475934759345;</pre>	
	<p>A number may be written in binary, octal, decimal, or hexadecimal by the use of a radix prefix. The radix prefixes are
	  <code>0b</code> (binary), <code>0o</code> (octal), <code>0d</code> (decimal) and <code>0x</code> (hexadecimal). Here is the
	  number <code>15</code> written using the different radix prefixes:</p>
	<pre>
	  > 0d15;
	  => 15
	  > 0b1111;
	  => 15
	  > 0o17;
	  => 15
	  > 0xf;
	  => 15 </pre>
	<p>Floating-point constants are usually written in decimal notation. Scientific notation may be used by adding 
	  e or E followed by a decimal exponent:</p>
	<pre>
	  > 1.23
	  => 1.23
	  > 1.23e2
	  => 123.</pre>
	<p>The following real constants represent values significant for IEEE floating point conformant arithmetic:</p>
	<p><ul>
	    <li><code>+inf.0</code> - positive infinity.</li>
	    <li><code>-inf.0</code> - negative infinity.</li>
	    <li><code>+nan.0</code> - not-a-number.</li>
	    <li><code>-0.</code> - negative zero (<code>0.</code> is the positive zero).</li>
	  </ul></p>
	<p>A complex number is written with the real part and the imaginary part separated by a <code>#</code> symbol:</p>
	<pre>
	  > 3#4;
	  => 3#4
	  > real_part (3#4);
	  => 3
	  > imag_part (3#4);
	  => 4</pre>

	<h3>Predicates</h3>

	<h5>is_number (obj)</h5>
	<h5>is_integer (obj)</h5>
	<h5>is_real (obj)</h5>
	<h5>is_complex (obj)</h5>

	<p>These predicates can be applied to any object. They return <code>true</code> if the object is a numeric value of
	  the named type.</p>

	<pre>
	  > is_number (10#45);
	  => true
	  > is_integer (10#45);
	  => false
	  > is_real (10#45);
	  => false
	  > is_real (10.45);
	  => true
	  > is_complex (10#45);
	  => true
	  > is_complex (10.45); // complex is more generic than real.
	  => true</pre>

	<h5>number_is_eq (n1, n2, ..., nN)</h5>
	<h5>number_is_lt (n1, n2, ..., nN)</h5>
	<h5>number_is_gt (n1, n2, ..., nN)</h5>
	<h5>number_is_lteq (n1, n2, ..., nN)</h5>
	<h5>number_is_gteq (n1, n2, ..., nN</h5>

	<p>These functions return <code>true</code> if their arguments are (respectively): equal, monotonically increasing, 
	  monotonically decreasing, monotonically non-decreasing, or monotonically non-increasing. The implementation dependent
	  exactness of numeric representation can influence the result of these functions. The operators <code>==</code>,
	  <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> produce the same results as these 
	  functions when called with two arguments.</p>

	<pre>
	  > number_is_eq (10, 10);
	  => true
	  > number_is_eq (10, 10.0);
	  => true
	  > number_is_eq (10, 10.01);
	  => false
	  > number_is_lt (10, 10.01, 10.001);
	  => false
	  > number_is_lt (10, 10.01, 10.02);
	  => true
	  > number_is_lt (10, 10.01, 10.02, 10.003);
	  => false</pre>

	<h5>is_zero (n)</h5>
	<h5>is_positive (n)</h5>
	<h5>is_negative (n)</h5>
	<h5>is_odd (n)</h5>
	<h5>is_even (n)</h5>
	<h5>is_nan (n)</h5>
	<h5>is_positive_infinity (n)</h5>
	<h5>is_negative_infinity (n)</h5>
        <h5>is_fixnum</h5>
        <h5>is_flonum</h5>

	<p>These functions check a number for a particular property identified by the function name.</p>

        <h3>Arithmetic and related functions</h3>

        <h5>max (n1, n2, ..., nN)</h5>
        <h5>min (n1, n2, ..., nN)</h5>

        <p>These functions return the maximum or minimum of their arguments.</p>

        <pre>
          > max (1, 2, 5, 3);
          => 5
          > min (1.001, 1.01, 1.00001);
          => 1.00001</pre>

        <h5>add (n1, n2, ..., nN)</h5>
        <h5>mult (n1, n2, ..., nN)</h5>

        <p>These functions return the sum or product of their arguments.</p>

        <pre>
          > add (3, 4, 5);
          => 12
          > add (3);
          => 3
          > mult (3, 4, 5);
          => 60
          > mult ();
          => 1
          > add();
          => 0</pre>
        
        <h5>sub (n1, n2, ..., nN)</h5>
        <h5>div (n1, n2, ..., nN)</h5>
        
        <p>With two or more arguments, these functions return the difference or quotient of their arguments, associating to the left. 
          With one argument, however, they return the additive or multiplicative inverse of their argument.</p>

        <pre>
          > sub (3, 4, 5);
          => -6
          > sub (3);
          => -3
          > div (3, 4, 5);
          => .15
          > div (3);
          => .3333333333333333</pre>
        
        <h5>abs (n)</h5>
        <p><code>abs</code> returns the absolute value of its argument.</p>
        <pre>
          > abs (-7);
          => 7</pre>
        
        <h5>quotient (n1, n2)</h5>
        <h5>remainder (n1, n2)</h5>
        <h5>modulo (n1, n2)</h5>
        <p>These functions implement number-theoretic (integer) division. <code>n2</code> should be non-zero. 
          All three functions return integers. If <code>n1 / n2</code> is an integer:</p>
        <pre>
          quotient (n1, n2)  ==> n1 / n2
          remainder (n1, n2) ==> 0
          modulo (n1, n2)    ==> 0</pre>

        <p>If <code>n1 / n2</code> is not an integer:</p>

        <pre>
          quotient (n1, n2)  ==> nq
          remainder (n1, n2) ==> nr
          modulo (n1, n2)    ==> nm</pre>

        <p>where <code>nq</code> is <code>n1 / n2</code> rounded towards zero, <code>0 &lt; |nr| &lt; |n2|</code>, 
          <code>0 &lt; |nm| &lt; |n2|</code>, <code>nr</code> and <code>nm</code> differ from <code>n1</code> by a multiple of <code>n2</code>, 
          <code>nr</code> has the same sign as <code>n1</code>, and <code>nm</code> has the same sign as <code>n2</code>.</p>

        <p>From this we can conclude that for integers <code>n1</code> and <code>n2</code> with <code>n2</code> not equal to <code>0</code>,</p>
        
        <pre>
          n1 == (remainder (n1, n2) + n2 * quotient (n1, n2)) ==> true</pre>
        <pre>
          > modulo (13, 4);
          => 1
          > remainder (13, 4);
          => 1
          > modulo (-13, 4);
          => 3
          > remainder (-13, 4);
          => -1
          > -13 == (remainder (-13, 4) + 4 * quotient (-13, 4));
          => true</pre>
        <h5>gcd (n1, n2, ..., nN)</h5>
        <h5>lcm (n1, n2, ..., nN)</h5>
        <p>These functions return the greatest common divisor or least common multiple of their arguments. The result is always non-negative.</p>
        <pre>
          > gcd (32, 36);
          => 4
          > gcd();
          => 0
          > lcm (32, 36);
          => 288
          > lcm();
          => 1
          > lcm (32.0, -36);
          => 288.</pre>
        <h5>numerator (q)</h5>
        <h5>denominator (q)</h5>
        <p>These functions return the numerator or denominator of their argument; the result is computed as if the argument was 
          represented as a fraction in lowest terms. The denominator is always positive. The denominator of <code>0</code> is 
          defined to be <code>1</code>.</p>
        <pre>
          > numerator (6/4);
          => 3
          > denominator (6/4);
          => 2</pre>

        <h5>floor (x)</h5>
        <h5>ceiling (x)</h5>
        <h5>truncate (x)</h5>
        <h5>round (x)</h5>
        <p>These functions return integers. <code>floor</code> returns the largest integer not larger than <code>x</code>. 
          <code>ceiling</code> returns the smallest integer not smaller than <code>x</code>. 
          <code>truncate</code> returns the integer closest to <code>x</code> whose absolute value is not larger than the absolute 
          value of <code>x</code>. <code>round</code> returns the closest integer to <code>x</code>, rounding to even when 
          <code>x</code> is halfway between two integers. <code>round</code> rounds to even for consistency with the default rounding 
          mode specified by the IEEE floating point standard.</p> 
        <pre>
          > floor (3.5);
          => 3.
          > ceiling (3.5);
          => 4.
          > truncate (3.5);
          => 3.
          > round (3.5);
          => 4.</pre>

        <h5>rationalize (x, y)</h5>
        <p><code>rationalize</code> returns the simplest rational number differing from <code>x</code> by no more than <code>y</code>.</p>
        <pre>
          > rationalize (.3, 1 / 10);
          => .3333333333333333</pre>

        <h5>exp (z)</h5>
        <h5>log (z)</h5>
        <h5>sin (z)</h5>
        <h5>cos (z)</h5>
        <h5>tan (z)</h5> 
        <h5>asin (z)</h5>
        <h5>acos (z)</h5>
        <h5>atan (z)</h5>
        <h5>atan (y, x)</h5> 
        <p>These functions compute the usual transcendental functions. <code>log</code> computes the natural logarithm of <code>z</code> 
          (not the base ten logarithm). <code>asin</code>, <code>acos</code>, and <code>atan</code> compute 
          arcsine (<code>sin</code><sup>-1</sup>), arccosine (<code>cos</code><sup>-1</sup>), and arctangent (<code>tan</code><sup>-1</sup>), 
          respectively. The two-argument variant of <code>atan</code> computes 
          <code>angle (rectangular (x, y))</code> (see below), even in implementations that don't support general complex numbers.</p>
        
        <h5>rectangular (x1, x2)</h5>
        <h5>polar (x3, x4)</h5>
        <h5>real_part (z)</h5>
        <h5>imag_part (z)</h5>
        <h5>magnitude (z)</h5>
        <h5>angle (z)</h5>
        <p>These functions are part of every implementation that supports general complex numbers. <code>magnitude</code> is the same 
          as <code>abs</code> for a real argument, but <code>abs</code> must be present in all implementations, whereas 
          <code>magnitude</code> need only be present in implementations that support general complex numbers.</p>

        <h5>sqrt (z)</h5>
        <p>Returns the principal square root of <code>z</code>. The result will have either positive real part, 
          or zero real part and non-negative imaginary part.</p>

        <h5>integer_sqrt (n)</h5>
        <p>Returns the integer part of the square root of the nonnegative exact integer <code>n</code>.</p>

        <h5>integer_nth_root (n1, n2)</h5>
        <p>Returns the integer part of <code>n1</code> raised to the power <code>1/n2</code>, where <code>n1</code> is a 
          nonnegative exact integer and <code>n2</code> is a positive exact integer.</p>

        <h5>expt (z1, z2)</h5>
        <p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
        
        <h3>Conversions</h3>

        <h5>number_to_string (z, @optional radix)</h5>
        <h5>string_to_number (z, @optional radix)</h5>
        <p>These functions converts a number to its string representation and vice versa. Radix must be an exact integer, 
          either 2, 8, 10, or 16. If omitted, <code>radix</code> defaults to 10.</p>

        <h5>char_to_integer (c)</h5>
        <h5>integer_to_char (n)</h5>
        <p><code>char_to_integer</code> returns the unicode encoding of a character. <code>integer_to_char</code> returns the character
          whose unicode encoding is the exact integer <code>n</code>.</p>

        <h5>real_to_integer (r)</h5>
        <h5>integer_to_real (n)</h5>
        <p>These functions converts between integers and reals.</p>

        <h3>Bitwise operations</h3>
        <p>Most functions in this section are specified in terms of the binary representation of integers. 
          The two's complement representation is assumed where an integer is composed of an infinite number of bits. 
          The upper section of an integer (the most significant bits) are either an infinite sequence of ones when the integer is negative, 
          or they are an infinite sequence of zeros when the integer is nonnegative.</p>

        <h5>arithmetic_shift (n1, n2)</h5>
        <p>Returns <code>n1</code> shifted to the left by <code>n2</code> bits.</p>

        <h5>bitwise_merge (n1, n2, n3)</h5>
        <p>Returns an integer whose bits combine the bits from <code>n2</code> and <code>n3</code> depending on <code>n1</code>. 
          The bit at index <code>i</code> of the result depends only on the bits at index <code>i</code> in <code>n1</code>, <code>n2</code> 
          and <code>n3</code>: it is equal to the bit in <code>n2</code> when the bit in <code>n1</code> is 0 and it is equal to the bit 
          in <code>n3</code> when the bit in <code>n1</code> is 1. </p>

        <h5>bitwise_and (n1, n2, ..., nN)</h5>
        <p>Returns the bitwise "and" of the arguments.</p>

        <h5>bitwise_ior (n1, n2, ..., nN)</h5>
        <p>Returns the bitwise "inclusive-or" of the arguments.</p>

        <h5>bitwise_xor (n1, n2, ..., nN)</h5>
        <p>Returns the bitwise "exclusive-or" of the arguments.</p>

        <h5>bitwise_not (n)</h5>
        <p>Returns the bitwise complement of <code>n</code>.</p>

        <h5>bit_count (n)</h5>
        <p>Returns the number of bits in <code>n</code>. . If <code>n</code> is nonnegative, the bit count is the number of 1 bits 
          in the two's complement representation of <code>n</code>. If <code>n</code> is negative, the bit count is the number of 0 bits 
          in the two's complement representation of <code>n</code>.</p>

        <h5>integer_length (n)</h5>
        <p>Returns the bit length of <code>n</code>. If <code>n</code> is a positive integer the bit length is one more than the index of 
          the highest 1 bit (the least significant bit is at index 0). If <code>n</code> is a negative integer the bit length is one more 
          than the index of the highest 0 bit. If <code>n</code> is zero, the bit length is 0.</p>

        <h5>is_bit_set (n1, n2)</h5>
        <p>Returns a boolean indicating if the bit at index <code>n1</code> of <code>n2</code> is set (i.e. equal to 1) or not. 
          <code>n1</code> must be nonnegative.</p>
        <pre>
          > map (function (i) is_bit_set (i, -23), [7, 6, 5, 4, 3, 2, 1, 0]);
          => [true, true, true, false, true, false, false, true]</pre>

        <h5>is_any_bits_set (n1, n2)</h5>
        <p>Returns a boolean indicating if the bitwise and of <code>n1</code> and <code>n2</code> is different from zero or not.</p>

        <h5>is_all_bits_set (n1, n2)</h5>
        <p>Returns a boolean indicating if the bitwise and of <code>n1</code> and <code>n2</code> is equal to <code>n1</code> or not.</p>

        <h5>first_bit_set (n)</h5>
        <p>Returns the bit index of the least significant bit of <code>n</code> equal to 1 (which is also the number of 0 bits 
          that are below the least significant 1 bit). This function returns -1 when <code>n</code> is zero.</p>

        <h5>extract_bit_field (n1, n2, n3)</h5>
        <h5>is_bit_field_set (n1, n2, n3)</h5>
        <h5>clear_bit_field (n1, n2, n3)</h5>
        <h5>replace_bit_field (n1, n2, n3, n4)</h5>
        <h5>copy_bit_field (n1, n2, n3, n4)</h5>
        <p>These functions operate on a bit-field which is <code>n1</code> bits wide starting at bit index <code>n2</code>. 
          <code>n1</code> and <code>n2</code> must be nonnegative.</p>

        <p><code>extract_bit_field</code> returns the bit-field of <code>n3</code> shifted to the right so that the least 
          significant bit of the bit-field is the least significant bit of the result.</p>

        <p><code>is_bit_field_set</code> returns <code>true</code> if any bit in the bit-field of <code>n3</code> is equal to 1.</p>

        <p><code>clear_bit_field</code> returns <code>n3</code> with all bits in the bit-field replaced with 0.</p>
        
        <p><code>replace_bit_field</code> returns <code>n4</code> with the bit-field replaced with the 
          least-significant <code>n1</code> bits of <code>n3</code>.</p>

        <p><code>copy_bit_field</code> returns <code>n4</code> with the bit-field replaced with the (same index and size) 
          bit-field in <code>n3</code>.</p>

        <h3>Pseudo random numbers</h3>

        <h5>random_integer (n)</h5>
        <p>Returns a pseudo random exact integer in the range 0 to n-1. </p>
        <pre>
          > random_integer (10);
          => 8
          > random_integer (10);
          => 2</pre>

        <h5>random_real (r)</h5>
        <p>Returns a pseudo random real between, but not including, 0 and 1.</p>
        <pre>
          > random_real ();
          => .7342236104231586
          > random_real ();
          => .8162050798467028</pre>

        <h5>random_byte_array (n)</h5>
        <p>Returns a byte array of length <code>n</code> containing pseudo random exact integers in the range 0 to 255. </p>
        <pre>
          > random_byte_array (10);
          => #b[200, 53, 29, 202, 3, 85, 208, 187, 73, 219]
          > random_byte_array (10);
          => #b[113, 8, 182, 120, 138, 103, 53, 192, 40, 176]</pre>
        
        <h5>default_random_source ()</h5>
        <p>Returns the global random source object which is used by the <code>random_integer</code>, <code>random_real</code>
          and <code>random_byte_array</code> functions.</p>
        
        <h5>set_default_random_source (s)</h5>
        <p>Sets the global random source to <code>s</code>.</p>

        <h5>random_source ()</h5>
        <p>This function returns a new random source object initialized to a predetermined state. 
          (To initialize to a pseudo random state the function <code>random_source_randomize</code> should be called).</p>

        <h5>is_random_source (obj)</h5>
        <p>Returns <code>true</code> if <code>obj</code> is a random source object.</p>
        
        <h5>random_source_state (s)</h5>
        <h5>random_source_set_state (s, state)</h5>
        <p><code>random_source_state</code> extracts the state of the random source object <code>s</code> and returns an array  
          containing the state.</p>
        <p><code>random_source_set_state</code> restores the state of the random source object <code>s</code> to state which must 
          be an array returned from a call to <code>random_source_state</code>.</p>
        
        <h5>random_source_randomize (s)</h5>
        <h5>random_source_pseudo_randomize (s, i, j)</h5>
        <p>These functions change the state of the random source object <code>s</code>. 
          <code>random_source_randomize</code> sets the random source object to a state that depends on the current time 
          (which for typical uses can be considered to randomly initialize the state). 
          <code>random_source_pseudo_randomize</code> sets the random source object to a state that is determined only 
          by the current state and the nonnegative integers <code>i</code> and <code>j</code>. 
          For both functions the value returned is unspecified.</p>
        
        <h5>random_source_for_integers (s)</h5>
        <p>This function returns a function for generating pseudo random exact integers using the random source object <code>s</code>. 
          The returned function accepts a single parameter <code>n</code>, a positive integer, and returns a pseudo random integer 
          in the range 0 to n-1.</p>

        <h5>random_source_for_reals (s, @optional precision)</h5>
        <p>This function returns a function for generating pseudo random inexact reals using the random source object <code>s</code>. 
          The returned function accepts no parameters and returns a pseudo random inexact real between, but not including, 0 and 1. 
          The optional parameter <code>precision</code> specifies an upper bound on the minimum amount by which two generated 
          pseudo-random numbers can be separated.</p>

        <h5>random_source_for_byte_arrays (s)</h5>
        <p>This function returns a function for generating pseudo random byte arrays using the random source object <code>s</code>. 
          The returned function accepts a single parameter <code>n</code>, a nonnegative integer, and returns a byte array of length 
          <code>n</code> containing pseudo random exact integers in the range 0 to 255.</p>

        <h3>Fixnum operations</h3>
        <p>Slogan has the following functions for working specifically with fixnums. All these functions are similar to their
          similarly named functions described above.</p>
        <h5>is_fixnum (obj)</h5>
        <h5>fxmult (n1, n2, ..., nN)</h5>
        <h5>fxadd (n1, n2, ..., nN)</h5>
        <h5>fxsub (n1, n2, ..., nN)</h5>
        <h5>fx_is_lt (n1, n2, ..., nN)</h5>
        <h5>fx_is_lteq (n1, n2, ..., nN)</h5>
        <h5>fx_is_eq (n1, n2, ..., nN)</h5>
        <h5>fx_is_gt (n1, n2, ..., nN)</h5>
        <h5>fx_is_gteq (n1, n2, ..., nN)</h5>
        <h5>fxabs (n)</h5>
        <h5>fxand (n1, n2, ..., nN)</h5>
        <h5>fxarithmetic_shift (n1, n2)</h5>
        <h5>fxarithmetic_shift_left (n1, n2)</h5>
        <h5>fxarithmetic_shift_right (n1, n2)</h5>
        <h5>fxbit_count (n)</h5>
        <h5>is_fxbit_set (n1, n2)</h5>
        <h5>is_fxeven (n)</h5>
        <h5>fxfirst_bit_set (n)</h5>
        <h5>fxif (n1, n2, n3)</h5>
        <h5>fxior (n1, n2, ..., nN)</h5>
        <h5>fxlength (n)</h5>
        <h5>fxmax (n1, n2, ..., nN)</h5>
        <h5>fxmin (n1, n2, ..., nN)</h5>
        <h5>fxmodulo (n1, n2)</h5>
        <h5>is_fxnegative (n)</h5>
        <h5>fxnot (n)</h5>
        <h5>is_fxodd (n)</h5>
        <h5>is_fxpositive (n)</h5>
        <h5>fxquotient (n1, n2)</h5>
        <h5>fxremainder (n1, n2)</h5>
        <h5>fxwrap_mult (n1, n2, ..., n3)</h5>
        <h5>fxwrap_add (n1, n2, ..., n3)</h5>
        <h5>fxwrap_sub (n1, n2, ..., nN)</h5>
        <h5>fxwrapabs (n)</h5>
        <h5>fxwraparithmetic_shift (n1, n2)</h5>
        <h5>fxwraparithmetic_shift_left (n1, n2)</h5>
        <h5>fxwraplogical_shift_right (n1, n2)</h5>
        <h5>fxwrapquotient (n1, n2)</h5>
        <h5>fxxor (n1, n2, ..., nN)</h5>
        <h5>is_fxzero (n)</h5>

        <h3>Flonum operations</h3>
        <p>The following functions works directly with machine dependent real value or flonums:</p>

        <h5>is_flonum (ob)</h5>
        <h5>fixnum_to_flonum (n)</h5>
        <h5>flmult (x1, x2, ..., x3)</h5>
        <h5>fladd (x1, x2, ..., x3)</h5>
        <h5>flsub (x1, x2, ..., x3)</h5>
        <h5>fldiv (x1, x2, ..., x3)</h5>
        <h5>fl_is_lt (x1, x2, ..., x3)</h5>
        <h5>fl_is_lteq (x1, x2, ..., x3)</h5>
        <h5>fl_is_eq (x1, x2, ..., x3)</h5>
        <h5>fl_is_gt (x1, x2, ..., x3)</h5>
        <h5>fl_is_gteq (x1, x2, ..., x3)</h5>
        <h5>flabs (x)</h5>
        <h5>flacos (x)</h5>
        <h5>flasin (x)</h5>
        <h5>flatan (x)</h5>
        <h5>flatan (y ,x)</h5>
        <h5>flceiling (x)</h5>
        <h5>flcos (x)</h5>
        <h5>fldenominator (x)</h5>
        <h5>is_fleven (x)</h5>
        <h5>flexp (x)</h5>
        <h5>flexpt (x, y)</h5>
        <h5>is_flfinite (x)</h5>
        <h5>flfloor (x)</h5>
        <h5>is_flinfinite (x)</h5>
        <h5>is_flinteger (x)</h5>
        <h5>fllog (x)</h5>
        <h5>flmax (x1, x2, ..., x3)</h5>
        <h5>flmin (x1, x2, ..., x3)</h5>
        <h5>is_flnan (x)</h5>
        <h5>is_flnegative (x)</h5>
        <h5>flnumerator (x)</h5>
        <h5>is_flodd (x)</h5>
        <h5>is_flpositive (x)</h5>
        <h5>flround (x)</h5>
        <h5>flsin (x)</h5>
        <h5>flsqrt (x)</h5>
        <h5>fltan (x)</h5>
        <h5>fltruncate (x)</h5>
        <h5>is_flzero (x)</h5>
      </div>
    </div>
  </body>
</html>
