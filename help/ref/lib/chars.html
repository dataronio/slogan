<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Symbols, Characters and Strings</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Symbols, Characters and Strings</h2>

        <h3>Symbols</h3>

        <p>Symbols are objects whose usefulness rests on the fact that two symbols are identical (in the sense of <code>is_eqv</code> or
          <code>==</code>) if and only if their names are spelled the same way. This is exactly the property needed to represent 
          identifiers in programs, and so Slogan use them internally for that purpose. Symbols are useful for many other applications; 
          for instance, they may be used the way enumerated values are used in C and Pascal.</p>

        <h5>is_symbol (obj)</h5>
        <p>Returns <code>true</code> if <code>obj</code> is a symbol, <code>false</code> otherwise.</p>

        <h5>symbol_to_string (s)</h5>
        <h5>string_to_symbol (s)</h5>
        <p>Perfomrs convertions between strings and symbols.</p>
        <pre>
          > symbol_to_string (!hello);
          => "hello"
          > string_to_symbol ("hello") == !hello;
          => true</pre>
        
        <h3>Characters</h3>
        <p>Characters are objects that represent printed characters such as letters and digits. A character is written by
          enclosing it within single-quotes. Slogan supports the Unicode character encoding standard. Slogan characters can be any of the 
          characters whose Unicode encoding is in the range 0 to #x10ffff (inclusive) but not in the range #xd800 to #xdfff. </p>

        <h5>is_char (obj)</h5>
        <p>Returns <code>true</code> is <code>obj</code> is a character.</p>
          
        <h5>char_is_eq (c1, c2, ..., cN)</h5>
        <h5>char_is_lt (c1, c2, ..., cN)</h5>
        <h5>char_is_gt (c1, c2, ..., cN)</h5>
        <h5>char_is_lteq (c1, c2, ..., cN)</h5>
        <h5>char_is_gteq (c1, c2, ..., cN)</h5>
        <h5>char_ci_is_eq (c1, c2, ..., cN)</h5>
        <h5>char_ci_is_lt (c1, c2, ..., cN)</h5>
        <h5>char_ci_is_gt (c1, c2, ..., cN)</h5>
        <h5>char_ci_is_lteq (c1, c2, ..., cN)</h5>
        <h5>char_is_ci_is_gteq (c1, c2, ..., cN)</h5>
        <p>The character comparison functions. Function prefixed with <code>char_ci_</code> does a case-ignorant comparison of the
          arguments.</p>
        <pre>
          > char_is_eq ('a', 'a');
          => true
          > char_is_eq ('a', 'A');
          => false
          > char_ci_is_eq ('a', 'A');
          => true
          > char_is_gt ('a', 'b', 'c', 'd');
          => false
          > char_is_lt ('a', 'b', 'c', 'd');
          => true</pre>

        <h5>char_is_alphabetic (c)</h5>
        <h5>char_is_numeric (c)</h5>
        <h5>char_is_whitespace (c)</h5>
        <h5>char_is_upper_case (c)</h5>
        <h5>char_is_lower_case (c)</h5>
        <p>These functions return <code>true</code> if their arguments are alphabetic, numeric, whitespace, upper case, or lower case 
          characters, respectively, otherwise they return <code>false</code>.</p>
        
        <h5>char_to_integer (c)</h5>
        <h5>integer_to_char (n)</h5>
        <p><code>char_to_integer</code> returns the unicode encoding of a character. <code>integer_to_char</code> returns the character
          whose unicode encoding is the exact integer <code>n</code>.</p>
        
        <h5>char_upcase (c)</h5>
        <h5>char_downcase (c)</h5>
        <p>Thes functions perform case conversions of the character <code>c</code>.</p>

        <h3>Strings</h3>
        <p>Strings are sequences of characters. Strings are written as sequences of characters enclosed within doublequotes (&quot;). 
          A doublequote can be written inside a string only by escaping it with a backslash (\), as in</p>
        
        <pre>"The word \"recursion\" has many meanings."</pre>
        
        <p>A backslash can be written inside a string only by escaping it with another backslash.</p>
        
        <h5>string (n, @optional char)</h5>
        <p>Returns a newly allocated string of length <code>n</code>. If <code>char</code> is given, then all elements of the 
          string are initialized to <code>char</code>. <code>char</code> defaults to the Unicode NULL character.</p>
        
        <h5>string_is_eq (s1, s2, ..., sN)</h5>
        <h5>string_is_lteq (s1, s2, ..., sN)</h5>
        <h5>string_is_gteq (s1, s2, ..., sN)</h5>
        <h5>string_is_lt (s1, s2, ..., sN)</h5>
        <h5>string_is_gt (s1, s2, ..., sN)</h5>
        <h5>string_ci_is_eq (s1, s2, ..., sN)</h5>
        <h5>string_ci_is_lteq (s1, s2, ..., sN)</h5>
        <h5>string_ci_is_gteq (s1, s2, ..., sN)</h5>
        <h5>string_ci_is_lt (s1, s2, ..., sN)</h5>
        <h5>string_ci_is_gt (s1, s2, ..., sN)</h5>
        <p>These predicates compare their string arguments based on the lexicographic ordering of their characters.</p>
        
        <h5>string_upcase (s)</h5>
        <p>Returns a new string with all characters of <code>s</code> turned up.</p>
        
        <h5>string_downcase (s)</h5>
        <p>Returns a new string with all characters of <code>s</code> turned down.</p>
        
        <h5>string_replace_all (s, fch, rch)</h5>
        <p>Returns a new string with all occurences of <code>fch</code> in <code>s</code> replaced with <code>rch</code>.</p>
        
        <h5>is_string (obj)</h5>
        <p>Returns <code>true</code> if <code>obj</code> is a string.</p>
        
        <h5>string_starts_with (s, suffix)</h5>
        <h5>string_ci_starts_with (s, suffix)</h5>
        <p>Returns <code>true</code> is <code>s</code> starts with the given suffix.</p>
        
        <pre>
          > string_starts_with ("hello, world", "hello");
          => true
          > string_starts_with ("hello, world", "Hello");
          => false
          > string_ci_starts_with ("hello, world", "Hello");
          => true</pre>
          
          <h5>string_ends_with (s, prefix)</h5>
          <h5>string_ci_ends_with (s, prefix)</h5>
        <p>Returns <code>true</code> is <code>s</code> ends with the given prefix.</p>

        <pre>
          > string_ends_with ("hello, world", "ld");
          => true
          > string_ends_with ("hello, world", "LD");
          => false
          > string_ci_ends_with ("hello, world", "LD");
          => true</pre>

          <h5>string_to_list (s)</h5>
          
          <h5>string_append (s1, s2, ..., s3)</h5>
          
          <h5>string_copy (s)</h5>

          <h5>string_fill (s, char)</h5>

          <h5>string_length (s)</h5>

          <h5>string_at (s, i)</h5>
          
          <h5>string_set (s, i, c)</h5>

          <h5>string_hash (s)</h5>

          <h5>string_indexof (s, c)</h5>
          
          <h5>string_rtrim (s)</h5>

          <h5>string_ltrim (s)</h5>

          <h5>string_trim (s)</h5>
          
          <h5>string_map (fn, s)</h5>
          
          <h5>string_for_each (fn, s)</h5>

          <h5>string_split (s, @optional delim)</h5>

          <h5>string_to_number (s, @optional radix 10)</h5>
      </div>
    </div>
  </body>
</html>
