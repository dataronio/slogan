<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Pairs and Lists</title>

    <link type="text/css" rel="stylesheet" href="../../style/style.css">
  </head>

  <body>

    <div id="page" class="wide">
      <div class="container">

	<h2>Pairs and Lists</h2>
        <p>A pair is a structure formed by two parts - a <em>head</em> and a <em>tail</em>. Slogan uses pairs to construct lists. 
          A list is defined recursively as either the empty list or a pair whose tail is a list. </p>

        <h5>is_pair (obj)</h5>
        <p>Returns <code>true</code> is <code>obj</code> is a pair.</p>

        <h5>pair (obj1, obj2)</h5>
        <p>Returns a newly allocated pair whose head is <code>obj1</code> and whose tail is <code>obj2</code>. 
          The pair is guaranteed to be different (in the sense of <code>is_eqv</code> and <code>==</code>) from every existing object.</p>
        <pre>
          > var a = pair (10, 20);
          > var b = pair (10, 20);
          > a;
          => [10 20]
          > b;
          => [10 20]
          > a == b;
          => false
          > is_eqv (a, b);
          => false
          > is_equal (a, b);
          => true</pre>

        <h5>head (p)</h5>
        <h5>tail (p)</h5>
        <h5>set_head (p, obj)</h5>
        <h5>set_tail (p, obj)</h5>
        <p>These functions are used to access and modify the parts if a pair.</p>
        <pre>
          > head (a);
          => 10
          > tail (a);
          => 20
          > set_head (a, 100);
          > set_tail (a, 200);
          > a;
          => [100 200]</pre>

        <h5>is_list (obj)</h5>
        <p>Returns <code>true</code> is the object is a list.</p>
        <pre>
          > is_list (a);
          => false
          > is_list (pair (10, pair (20, 30)));
          => false
          > is_list (pair (10, pair (20, [])));
          => true</pre>
        
        <h5>is_empty (obj)</h5>
        <p>Returns <code>true</code> if the list is empty.</p>

        <h5>list (obj1, obj2, ..., objN)</h5>
        <p>Returns a newly allocated list of its arguments.</p>
        <pre>
          > var s = list (1, 2, 3, "hello");
          > s;
          => [1, 2, 3, "hello"]
          > is_list (s);
          => true
          > head (s);
          => 1
          > tail (s);
          [2, 3, "hello"]</pre>
        
        <h5>length (list)</h5>
        <p>Returns the number of elements in the list.</p>
        
        <h5>append (list, ...)</h5>
        <p>Returns a list consisting of the elements of the first list followed by the elements of the other lists.</p>

        <h5>reverse (list)</h5>
        <p>Returns a newly allocated list consisting of the elements of list in reverse order.</p>

        <h5>nth_tail (list, n)</h5>
        <p>Returns the sublist of list obtained by omitting the first <code>n</code> elements. If <code>n</code> is negative
          the list is reversed before applying the function. If there are not enough elements in the list, <code>false</code>
          is returned.</p>

        <pre>
          > nth_tail ([1,2,3,4,5], 3);
          => [4, 5]
          > nth_tail ([1,2,3,4,5], 2);
          => [3, 4, 5]
          > nth_tail ([1,2,3,4,5], -3);
          => [1, 2]
          > nth_tail ([1,2,3,4,5], -10);
          => false</pre>

        <h5>at (list, i)</h5>
        <p>Returns the <code>i</code><sup>th</sup> element of the list.</p>

        <h5>memq (obj, list)</h5>
        <h5>memv (obj, list)</h5>
        <h5>member (obj, list)</h5>
        <p>These functions return the first sublist of list whose head is <code>obj</code>, where the sublists of list are the non-empty 
          lists returned by <code>nth_tail (list, n)</code> for <code>n</code> less than the length of list. If <code>obj</code> 
          does not occur in list, then <code>false</code> is returned. <code>memq</code> uses <code>is_eq</code> to compare <code>obj</code> 
          with the elements of list, while <code>memv</code> uses <code>is_eqv</code> and <code>member</code> uses <code>is_equal</code>.</p>
        <pre>
          > memq (!a, [!a, !b, !c]);
          => [a, b, c]
          > memv ('c', ['a', 'b', 'c']);
          => ['c']
          > memv ('d', ['a', 'b', 'c']);
          => false
          > memv ("hello", [1, "hello", 2, 3]);
          => false
          > member ("hello", [1, "hello", 2, 3]);
          => ["hello", 2, 3]</pre>

        <h5>assoc_get (alist, key, @key test, default_value)</h5>
        <h5>assoc_put (alist, key, value)</h5>
        <h5>assoc_set (alist, key, value, @key test)</h5>
        <p>These functions manipulate an <em>association list</em>, i.e a list of key-value pairs. The head of each pair
          is treated as the key and its tail is treated as the associated value.</p>
        <p><code>assoc_get</code> returns the value mapped to <code>key</code> in <code>alist</code>. 
          <code>test</code> is the predicate used to compare <code>key</code> to the head of each pair. 
          If the head of a pair returns <code>true</code> for the comparison, its tail is returned, otherwise <code>default_value</code>
          is returned. If <code>default_value</code> is not specified, <code>false</code> is returned.</p>

        <p><code>assoc_put</code> returns a new association list obtained after adding the mapping from <code>key</code> to <code>value</code>
          to <code>alist</code>.</p>

        <p><code>assoc_set</code> updates the value mapped to <code>key</code> in <code>alist</code>. This is a destructive function
          that modifies <code>alist</code> in-place.</p>

        <pre>
          > var a = [[!class "Sport bike"], [!engine "1352cc"], [!transmission "6-speed"]];
          > a;
          => [[class "Sport bike"], [engine "1352cc"], [transmission "6-speed"]]
          > assoc_get (a, !class);
          => [class "Sport bike"]
          > assoc_get (a, !engine);
          => [engine "1352cc"]
          > assoc_get (a, !manufacturer);
          => false
          > assoc_get (a, !manufacturer, default_value = "Yamaha");
          => "Yamaha"
          > assoc_put (a, !manufacturer, "Yamaha");
          => [[manufacturer "Yamaha"], [class "Sport bike"], [engine "1352cc"], [transmission "6-speed"]]
          > a;
          => [[class "Sport bike"], [engine "1352cc"], [transmission "6-speed"]] // assoc_put do not touch the original list.
          > a = assoc_put (a, !manufacturer, "Yamaha");
          > a;
          => [[manufacturer "Yamaha"], [class "Sport bike"], [engine "1352cc"], [transmission "6-speed"]]
          > assoc_set (a, !manufacturer, "Kawasaki");
          => [manufacturer "Kawasaki"]
          > a;
          => [[manufacturer "Kawasaki"], [class "Sport bike"], [engine "1352cc"], [transmission "6-speed"]]</pre>

        <h5>map (fn, list1, list2, ..., listN)</h5>
        <p>The lists must be lists, and <code>fn</code> must be a function taking as many arguments as there are lists and 
          returning a single value. If more than one list is given, then they must all be the same length. <code>map</code> applies 
          <code>fn</code> element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in 
          which <code>fn</code> is applied to the elements of the lists is unspecified.</p>

        <pre>
          > map (add, [1, 2, 3], [4, 5, 6]);
          => [5, 7, 9]</pre>
        
        <h5>for_each (fn, list1, list2, ..., listN)</h5>
        <p>The arguments to <code>for_each</code> are like the arguments to <code>map</code>, but <code>for_each</code> calls <code>fn</code>
          for its side effects rather than for its values. Unlike <code>map</code>, <code>for_each</code> is guaranteed to call <code>fn</code>
          on the elements of the lists in order from the first element(s) to the last, and the value returned by <code>for_each</code>
          is unspecified. In this implementation of Slogan, <code>for_each</code> returns the special value <code>void</code>. </p>
        <pre>
          > var a = #[1, 2, 3];
          > for_each (function (i) array_set (a, i, expt (array_at (a, i), 10)), [0, 1, 2]);
          > a;
          => #[1, 1024, 59049]</pre>

        <h5>list_to_string (list)</h5>
        <h5>list_to_array (list)</h5>
        <h5>list_to_table (list, @key size, init, weak_keys, weak_values, test, hash, min_load, max_load)</h5>
        <p><code>list_to_string</code> converts a list of characters into a new string.</p>
        <p><code>list_to_array</code> creates a new single dimensional array from the elements of the list.</p>
        <p><code>list_to_table</code> creates a new table from an association list. (See the constructor of
          <a href="arrays.html#tables">tables</a> for more information on the optional keyword parameters).</p>
        <pre>
          > list_to_string (['h', 'e', 'l', 'l', 'o']);
          => "hello"
          > list_to_array (['h', 'e', 'l', 'l', 'o']);
          => #['h', 'e', 'l', 'l', 'o']
          > var a = list_to_table ([[!class "Sport bike"], [!engine "1352cc"], [!transmission "6-speed"]]);
          > table_at (a, !class);
          => "Sport bike"</pre>

        <h5>filter (list, predic)</h5>
        <p>Creates a new list by removing all elements that return <code>false</code> for the predicate <code>predic</code>
          from <code>list</code>.</p>
        <pre>
          > filter ([1, 2, 3, 4, 5], is_odd);
          => [1, 3, 5]
          > filter ([1, 2, 3, 4, 5], is_even);
          => [2, 4]</pre>

        <h5>find (list, test, @key default)</h5>
        <p>Returns the first element from the list that returns <code>true</code> for the predicate <code>test</code>.
          If the element is not found, <code>default</code>, which defaults to <code>false</code>, is returned.</p>
        <pre>
          > find ([1, 2, 3, 4, 5], is_odd);
          => 1
          > find ([1, 2, 3, 4, 5], is_even);
          => 2
          > find ([1, 2, 3, 4, 5], is_string);
          => false
          > find ([1, 2, 3, 4, 5], is_string, default = "None");
          => "None"</pre>

        <h5>is_member (list, e, @key test)</h5>
        <p>Returns <code>true</code> is the element <code>e</code> is found in the list. The elements are compared using the
          predicate <code>test</code> which defaults to <code>is_eqv</code>.</p>

        <h5>remove (list, e, @key test, all)</h5>
        <p>Returns a new list with the first element that returns <code>true</code> for the comparison predicate <code>test</code>
          removed. If <code>all</code> is <code>true</code> all elements that returns <code>true</code> for <code>test</code>
          is removed. <code>test</code> defaults to <code>is_eqv</code>.</p>

        <pre>
          > remove ([1, 2, 3, 4, 3], 3);
          => [1, 2, 4, 3]
          > remove ([1, 2, 3, 4, 3], 3, all = true);
          => [1, 2, 4]
          > remove (["a", "b", "c", "b", "d"], "b", test = string_is_eq, all = true);
          => ["a", "c", "d"]</pre>

        <h5>remove_duplicates (list, e, @key test)</h5>
        <p>This function has the same effect as calling <code>remove</code> with <code>all</code> set to <code>true</code>.</p>

        <h5>remove_if (list, predic)</h5>
        <p>This is the inverse function of <code>filter</code>. While <code>filter</code> preserves the elements that satisfy
          the predicate, <code>remove_if</code> removes them.</p>
        
        <pre>
          > filter ([1, 2, 3, 4, 5], is_odd);
          => [1, 3, 5]
          > remove_if ([1, 2, 3, 4, 5], is_odd);
          => [2, 4]</pre>
        
        <h5>reduce (list, fn, @key initial_value)</h5>
        <p>Compresses or folds the list into a single value by recursively applying <code>fn</code> to each element and the compressed
          result computed so far. If <code>initial_value</code> is not specified, the first element of the list is treated
          as initial_value.</p>

        <pre>
          > reduce ([1, 2, 3, 4, 5], mult);
          => 120
          > reduce ([1, 2, 3, 4, 5], mult, initial_value = 100);
          => 12000</pre>

        <h5>sort (list, @key test, type)</h5>
        <p>Sorts the list by using <code>test</code> as the comparison predicate. <code>test</code> defaults to <code>number_is_lt</code>.
          <code>type</code> specifies the sorting algorithm to use. An implementation is free to use any sorting algorithm. This implementation
          support quicksort and mergesort. So <code>type</code> can be either <code>!quick</code> or <code>!merge</code> and it defaults to
          <code>!quick</code>.</p>

        <h5>copy_list (list)</h5>
        <p>Returns a new list which is an exact copy of the argument.</p>

        <h5>replace (list, a, b, @key test, transform, drill)</h5>
        <p>Returns a new list with all elements that are equal to <code>a</code>, as per the comparison predicate <code>test</code>,
          with <code>b</code>. <code>test</code> defaults to <code>is_eqv</code>. If <code>transform</code> is specified,
          it should be a function that accepts two arguments and return a single value. If <code>transform</code> is specified,
          it is applied with the element being replaced and <code>b</code> as arguments and the result is used as replacement value.
          <code>replace</code> applies itself recursively to any element that itself is a list. To prevent this behavior, pass
          <code>false</code> to the <code>drill</code> parameter.</p>
        
        <pre>
          > replace ([1, 2, 3, 4, 3], 3, 100);
          => [1, 2, 100, 4, 100]
          > replace ([1, 2, 3, 4, 3], 3, 100, transform = function (a, b) a * b);
          => [1, 2, 300, 4, 300]
          > replace ([1, 2, 3, [4, 3]], 3, 100);
          => [1, 2, 100, [4, 100]]
          > replace ([1, 2, 3, [4, 3]], 3, 100, drill = false);
          => [1, 2, 100, [4, 3]]</pre>

        <h5>replace_all (list, a, b, @key test, transform, drill)</h5>
        <p>This is similar to <code>replace</code> except that <code>a</code> and <code>b</code> are lists and all elements in
          <code>a</code> are replaced with the elements is <code>b</code>.</p>
        <pre>
          > replace_all ([1, 2, 3, 4, 3, 2], [3, 2], [100, 400]);
          => [1, 400, 100, 4, 100, 400]
          > replace_all ([1, 2, 3, 4, [3, 2]], [3, 2], [100, 400]);
          => [1, 400, 100, 4, [100, 400]]</pre>

        <h5>is_all (list, predic)</h5>
        <h5>is_any (list, predic)</h5>
        <p><code>is_all</code> returns <code>true</code> if <code>predic</code> returns <code>true</code> for all elements of <code>list</code>.
        <code>is_any</code> returns <code>true</code> if <code>predic</code> returns <code>true</code> for at least one element of 
        <code>list</code>.</p>
        <pre>
          > is_all ([1, 2, 3, 4, 5], is_odd);
          => false
          > is_all (filter ([1, 2, 3, 4, 5], is_odd), is_odd);
          => true
          > is_any ([1, 2, 3, 4, 5], is_odd);
          => true
          > is_any (filter ([1, 2, 3, 4, 5], is_even), is_odd);
          false</pre>
      </div>
    </div>
  </body>
</html>
