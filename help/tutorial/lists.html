<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Lists</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Lists</h2>
        <p>In the <a href="./intro.html">introduction</a> we met <code>pair</code>, <code>head</code> and <code>tail</code> - 
          the basic list manipulation functions. <code>pair</code> combines two objects. The two halves of a pair can point to
          any objects, including other pairs. It is by taking advantage of this fact that we use pairs to build lists.
          A list is a pair whose tail points to another pair. This tutorial already showed you how to create lists using
          literal expressions and the functions <code>pair</code> and <code>list</code>. Another function that can build new
          lists is <code>copy_list</code>. It takes a list and returns a copy of it. The following session makes clear the difference
          between simply assigning a list to a variable and actually copying it:</p>
        <pre>
          > var a = [1,2,3];
          > var b = a;
          > set_head (b, 100);
          > b;
          => [100, 2, 3]
          > a;
          => [100, 2, 3]</pre>
        <p>The destructive function <code>set_head</code> changes both <code>a</code> and <code>b</code> because the assignment
          operation simply points <code>b</code> to the same memory location as <code>a</code>. To actually copy the contents of
          the list to a new memory location and point <code>b</code> to that, we can use <code>copy_list</code>:</p>
        <pre>
          > a = [1, 2, 3];
          > b = copy_list (a);
          > a;
          => [1, 2, 3]
          > b;
          => [1, 2, 3]
          > set_head (b, 100);
          > a;
          => [1, 2, 3]
          > b;
          => [100, 2, 3]</pre>
        <p>Another function useful for building new lists is <code>append</code>. It returns the concatenation of 
          all the lists passed to it as arguments:</p>
        <pre>
          > append ([1, 2], ["hello", "there"], [3, 4, [!good !bye]]);
          => [1, 2, "hello", "there", 3, 4, [!good !bye]]</pre>
        <h4>Example: Compression</h4>
        <p>The functions and language facilities that we learned so far is enough to write programs that does something useful,
          for instance, a utility that compresses a list. The compression algorithm used itself can be very simple - 
          replace repeated occurrences of an element with a pair that contains the number of occurrences and the element itself. 
          For example, the list <code>[1, 1, 1, 2]</code> will be compressed as <code>[[3 1], 2]</code>. Here is the definition
          of our <code>compress</code> function:</p>
        <pre>
var compress = 
    function (lst) {
        letrec ne_pair = 
            function (e, n) {
                if n > 1 pair (n, e) 
                else e
            },
        compr = 
            function (e, n, lst) {
                if is_empty (lst) list (ne_pair (e, n))
                else let next = head (lst) {
                    if next == e compr (e, n + 1, tail (lst))
                    else pair (ne_pair (e, n), compr (next, 1, tail (lst)))
                }
            }
        {
            if is_pair (lst) compr (head (lst), 1, tail (lst))
            else lst
        }
};</pre>
        <p>As this a rather large piece of code, you might want to type it into a text editor and import the file into the
          Slogan REPL. Files of Slogan scripts usually has the extension <code>.sn</code>. So you can save this file as
          <code>compress.sn</code>. To make the function definition available in the REPL, you import the script using the
          <code>import</code> statement. You don't have to provide the extension while importing the script. Once the script
          is imported its global definitions can be accessed from the REPL:</p>
        <pre>
          > import "/path/to/my/scripts/compress";
          > compress ([1, 1, 1, 2]);
          => [[3 1], 2]
          > compress ([1, 1, 1, 2, 0, 2, 2]);
          => [[3 1], 2, 0, [2 2]]</pre>
        <p>Now some explanation on the implementation. <code>compress</code> makes use of two internal functions - <code>ne_pair</code>
          and <code>compr</code>. They are introduced using a <code>letrec</code> (let-recursive) expression
          because the <code>compr</code> makes recursive calls to itself and <code>ne_pair</code>. (More on <code>letrec</code> later).
          <code>ne_pair</code> is called to pack an element and its number of occurrences in the list to a pair. For each subsequent
          occurrence of the same element in the list, <code>compr</code> calls itself. On finding a new element or at the end of the
          list <code>compr</code> call <code>ne_pair</code> to get the compressed representation.</p>
        <p>We need a function to recreate compressed lists:</p>
        <pre>
var uncompress =
  function (lst) {
    if is_empty (lst) lst
    else let e = head (lst),
    rest = uncompress (tail (lst)) {
       if is_pair (e) append (list_of (head (e), tail (e)), rest)
       else pair (e, rest)
    }
};</pre>
        <p>The <code>uncompress</code> function makes use of the built-in function <code>list_of</code> to expand a pair into a list.
          The first argument of <code>list_of</code> is the length of the new list and the optional second argument is the initial value
          to put in each slot.</p>
        <p>Our compression program has many limitations - it is slow, inefficient and will break for lists that contain other lists.
          But it does a good enough job at introducing the possibilities of the list data structure.</p>
        <p><div id="note">
            <em>Note:</em> The <code>example/tutorial/</code> directory contains the full source code of all example programs.
	    Refernces to the original source of the program, if any, can be found in header comments.</div> </p>
        <h4>Accessing elements</h4>
        <p>The function <code>at</code> allows list elements to be accessed based on their zero based indexed position:</p>
        <pre>
          > at ([10, 20, 30], 1);
          => 20</pre>
      <h4>Mapping functions</h4>
      <p>A mapping function abstracts the idea of applying some transformation to each element of a list. The most useful mapping
        function is <code>map</code> which takes a function (the transformer) and an arbitrary number of lists as its arguments. 
        The transformer must accept as many arguments as there are lists. <code>map</code> returns a list that contains the result
        of the transformations. Another mapping function is <code>for_each</code> which is similar to <code>map</code>. 
        The only difference is that, <code>for_each</code> is called for its side-effects rather than producing a value. 
        The following examples demonstrate <code>map</code> and <code>for_each</code>:</p>
      <pre>
        > map (function (x) { x * x}, [1, 2, 3, 4, 5]);
        => [1, 4, 9, 16, 25]
        > map (function (x, y) { x * y}, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]);
        => [10, 40, 90, 160, 250]
        > for_each (function (x, y) { println (x + y) }, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]);
        >> 11
           22
           33
           44
           55</pre>
      <p><code>reduce</code> combines the elements of a list using a binary function:</p>
      <pre>
        > reduce ([1, 2, 3, 4, 5], add);
        => 15
        > reduce ([1, 2, 3, 4, 5], add, initial_value = 100);
        => 115</pre>
        <p><code>apply</code> is used to invoke a function by using a list to provide its actual arguments:</p>
        <pre>
          > apply (add, [1,2,3,4,5]);
          => 15</pre>
      <h4>Searching, filtering, sorting etc</h4>
        <p>There are two functions that can be used to check a list for the existence of a particular element: <code>find</code>
          and <code>is_member</code>. <code>find</code> takes a predicate that takes a single argument and returns the first 
          element that makes it evaluate to <code>true</code>. While no element is found that satisfies this condition, <code>find</code>
          return <code>false</code>. This behaviour can be overridden by providing a value for the <code>default</code> parameter. </p>
        <pre>
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 2) == 0 });
          => 2
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 });
          => false
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 }, default = "not found");
          => "not found"
        </pre>
        <p><code>is_member</code> returns <code>true</code> if an element exists in the list. By default it uses the <code>==</code>
          operator to compare the values. This can be overridden by passing a comparison predicate to the <code>test</code> 
          keyword parameter:</p>
        <pre>
          > is_member ([1, 2, 3, 4, 5], 4);
          => true
          > is_member ([1, 2, 3, 4, 5], 7);
          => false
          > is_member (["a", "b", "c", "d", "e"], "b", test = string_is_eq);
          => true
          > is_member (["a", "b", "c", "d", "e"], "f", test = string_is_eq);
          => false</pre>
        <p>The <code>filter</code> function returns all elements that satisfies a predicate:</p>
        <pre>
          > filter ([1, 2, 3, 4, 5], function (x) { remainder (x, 2) == 0 });
          => [2, 4]
          > filter ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 });
          => []</pre>
        <p>To delete elements from a list, use <code>remove</code>. <code>remove_duplicates</code>
          removes all duplicate elements from the list. Both these function uses the <code>==</code> operator to
          compare elements. A comparison function can be provided using the <code>test</code> keyword parameter.</p>
        <pre>
          > remove ([1, 2, 3, 4, 5], 3);
          => [1, 2, 4, 5]
          > remove ([1, 2, 3, 4, 5, 3, 4, 5], 3);
          => [1, 2, 4, 5, 3, 4, 5]
          > remove ([1, 2, 3, 4, 5, 3, 4, 5], 3, all = true);
          => [1, 2, 4, 5, 4, 5]
          > remove (["a", "b", "a", "b"], "a", test = string_is_eq, all = true);
          => ["b", "b"]
          > remove_duplicates ([1, 2, 2, 3, 4, 4, 4, 5]);
          => [1, 2, 3, 4, 5]</pre>
        <p>Lists can be sorted in both ascending and descending order using the <code>sort</code> function. It takes two
          optional arguments - <code>test</code> and <code>type</code>. <code>test</code> is the predicate used to compare
          the elements, and it defaults to <code>&lt;</code>. <code>type</code> is a symbol that identifies the sorting algorithm 
          to use. The only algorithm currently supported is quick-sort identified by <code>!quick</code>.</p>
        <pre>
          > sort ([10, 0, 100, 1, -1]);
          => [-1, 0, 1, 10, 100]
          > sort ([10, 0, 100, 1, -1], test = is_number_gt);
          => [100, 10, 1, 0, -1]</pre>
        <p><code>is_number_gt</code> is a function that can stand-in for the numeric <code>&gt;</code> operator. It takes an
          arbitrary number of arguments. A predicate to check whether a list of integers is sorted can be defined by combining
          <code>apply</code> and <code>is_number_lt</code>:</p>
        <pre>
          > var is_sorted = function (lst) { apply (is_number_lt, lst) };
          > is_sorted (sort ([10, 0, 100, 1, -1]));
          => true</pre>
        <h4>Example: Sets</h4>
        <p>Lists are ideal for representing sets. In this section we will develop a few functions that let us build and manipulate
          sets. The built-in function <code>is_member</code> is enough to check for set membership:</p>
        <pre>
          > is_member ([1, 2, 3], 1);
          => true
          > is_member ([1, 2, 3], 0);
          => false</pre>
        <p>We need a function to build sets. The set constructor should add an element to the list only if it is not already
          a member. Let us call this function <code>adjoin</code>. <p>Here is the implementation of <code>adjoin</code> and the 
          three set operations: <code>union</code>, <code>intersection</code> and <code>difference</code>:</p>
        <pre>
var adjoin = function (element, set) {
    if not (is_member (set, element)) pair (element, set) else set
};

var union = function (a, b) {
    for_each (function (x) { b = adjoin (x, b) }, a);
    b
};

var intersection = function (a, b) {
    remove_duplicates (append (filter (a, function (x) { is_member (b, x) }),
                               filter (b, function (x) { is_member (a, x) })));
};

var difference = function (a, b) {
    remove_duplicates (append (filter (a, function (x) { not (is_member (b, x)) }),
                               filter (b, function (x) { not (is_member (a, x)) })));
};</pre>

        <p>Sample usage:</p>
        <pre>
          > var a = adjoin (1, (adjoin (2, adjoin (3, []))));
          > var b = adjoin (1, (adjoin (2, adjoin (4, (adjoin (5, []))))));
          > union (a, b);
          => [3, 1, 2, 4, 5]
          > difference (a, b);
          => [3, 4, 5]
          > intersection (a, b);
          => [1, 2]</pre>
        <h4>Lists as dictionaries</h4>
        <p>Lists can be used for associating data to values. Each entry in the dictionary is represented as a pair. 
          A list of pairs is known as an <em>association list</em>. There are three functions for working with association lists:
          <code>assoc_put</code>, <code>assoc_get</code> and <code>assoc_set</code>. <code>assoc_put</code> returns a new
          list that contains a mapping between a key and value. <code>assoc_get</code> returns the mapping for a given key
          and <code>assoc_set</code> updates an existing mapping, in-place. Both <code>assoc_get</code> and <code>assoc_set</code>
          accepts an optional <code>test</code> argument that can be used to customize the way keys are compared.</p>
        <pre>
          > var person = [[!name "jay"], [!age 10]];
          > assoc_get (person, !name);
          => [name "jay"]
          > assoc_get (person, !age);
          => [age 10]
          > assoc_get (person, !place);
          => false
          > assoc_get (person, !place, default_value = "not found");
          => "not found"
          > person = assoc_put (person, !place, "blr");
          > assoc_get (person, !place);
          => [place "blr"]
          > assoc_set (person, !age, 11);
          => [age 11]
          > assoc_get (person, !age);
          => [age 11]
          > person = [["name" "mary"], ["age" 5]];
          > assoc_get (person, "name", test = string_is_eq);
          => ["name" "mary"]
          > assoc_get (person, "name"); // default comparison operator will not work for string keys.
          => false
          > assoc_get (person, "age", test = string_is_eq);
          => ["age" 5]
          > person = assoc_put (person, !place, "ny");
          > assoc_get (person, !place);
          => [place "ny"]
          > assoc_get (person, "age", test = string_is_eq); // not a good idea to mix keys of types that cannot share the comparison predicate.
          (Argument 1) STRING expected</pre>
        </div>
      </div>
      
  </body>
</html>
