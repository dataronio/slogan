<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Data structures</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Data structures</h2>
        <h3>Pairs and Lists</h3>
        <p>In the <a href="./intro.html">introduction</a> we met <code>pair</code>, <code>head</code> and <code>tail</code>, 
          the basic list manipulation functions. <code>pair</code> combines two objects. The two halves of a pair can point to
          any objects, including other pairs. It is by taking advantage of this fact that we use pairs to build lists.
          A list is a pair whose tail points to another pair. This tutorial already showed you how to create lists using
          literal expressions and the functions <code>pair</code> and <code>list</code>. Another function that can build new
          lists is <code>copy_list</code>. It takes a list and returns a copy of it. The following session makes clear the difference
          between simply assigning a list to a variable and actually copying it:</p>
        <pre>
          > var a = [1,2,3];
          > var b = a;
          > set_head (b, 100);
          > b;
          => [100, 2, 3]
          > a;
          => [100, 2, 3]</pre>
        <p>The destructive function <code>set_head</code> changes both <code>a</code> and <code>b</code> because the assignment
          operation simply points <code>b</code> to the same memory location as <code>a</code>. To actually copy the contents of
          the list to a new memory location and point <code>b</code> to that, we can use <code>copy_list</code>:</p>
        <pre>
          > a = [1, 2, 3];
          > b = copy_list (a);
          > a;
          => [1, 2, 3]
          > b;
          => [1, 2, 3]
          > set_head (b, 100);
          > a;
          => [1, 2, 3]
          > b;
          => [100, 2, 3]</pre>
        <p>Another function useful for building new lists is <code>append</code>. It returns the concatenation any number of lists
          by copying all its arguments except the last.</p>
        <pre>
          > append ([1, 2], ["hello", "there"], [3, 4, [!good !bye]]);
          => [1, 2, "hello", "there", 3, 4, [!good !bye]]</pre>
        <p>The functions and language facilities that we learned so far is enough to write programs that does something useful,
          for instance, a utility that compresses a list. The compression algorithm used itself can be very simple - 
          replace repeated occurrences of an element with a pair that contains the number of occurrences and the element itself. 
          For example, the list <code>[1, 1, 1, 2]</code> will be compressed as <code>[[3 1], 2]</code>. Here is an initial
          version of our <code>compress</code> function:</p>
        <pre>
var compress = 
    function (lst) {
        letrec ne_pair = 
            function (e, n) {
                if n > 1 pair (n, e) 
                else e
            },
        compr = 
            function (e, n, lst) {
                if is_empty (lst) list (ne_pair (e, n))
                else let next = head (lst) {
                    if next == e compr (e, n + 1, tail (lst))
                    else pair (ne_pair (e, n), compr (next, 1, tail (lst)))
                }
            }
        {
            if is_pair (lst) compr (head (lst), 1, tail (lst))
            else lst
        }
};</pre>
        <p>As this a rather large piece of code, you might want to type it into a text editor and import the file into the
          Slogan REPL. Files of Slogan scripts usually has the extension <code>.sn</code>. So you can save this file as
          <code>compress.sn</code>. To make the function definition available in the REPL, you import the script using the
          <code>import</code> statement. You don't have to provide the extension while importing the script. Once the script
          is imported its global definitions can be accessed from the REPL:</p>
        <pre>
          > import "/path/to/my/scripts/compress";
          > compress ([1, 1, 1, 2]);
          => [[3 1], 2]
          > compress ([1, 1, 1, 2, 0, 2, 2]);
          => [[3 1], 2, 0, [2 2]]</pre>
        <p>Now some explanation on the implementation. <code>compress</code> makes use of two internal functions - <code>ne_pair</code>
          and <code>compr</code> to get the actual work done. They are introduced using a <code>letrec</code> (let-recursive) expression
          because the <code>compr</code> makes recursive calls to itself and <code>ne_pair</code>. (More on <code>letrec</code> later).
          <code>ne_pair</code> is called to pack an element and its number of occurrences in the list to a pair. For each subsequent
          occurrence of the same element in the list, <code>compr</code> calls itself. On finding a new element or at the end of the
          list <code>compr</code> call <code>ne_pair</code> to get the compressed representation.</p>
        <p>We need a function to recreate compressed lists:</p>
        <pre>
var uncompress =
  function (lst) {
    if is_empty (lst) lst
    else let e = head (lst),
    rest = uncompress (tail (lst)) {
       if is_pair (e) append (list_of (head (e), tail (e)), rest)
       else pair (e, rest)
    }
};</pre>
        <p>The <code>uncompress</code> function makes use of the built-in function <code>list_of</code> to expand a pair into a list.
          The first argument of <code>list_of</code> is the length of the new list and the optional second argument is the initial value
          to put in each slot.</p>
        <p>Our compression program has many limitations - it is slow, inefficient and will break for lists that contain other lists.
          In later sections of this tutorial, we will re-visit these functions and fix some of these issues.</p>
        <p><div id="note">
            <em>Note:</em> The compression sample, as most other samples in this tutorial, was adapted from 
            Paul Graham's ANSI Common Lisp.</p>
        <h4>Accessing elements</h4>
        <p>The function <code>at</code> allows list elements to be accessed based on their zero based indexed position:</p>
        <pre>
          > at ([10, 20, 30], 1);
          => 20</pre>
      <h4>Mapping functions</h4>
      <p>A mapping function abstracts the idea of applying some transformation to each element of a list. The most useful mapping
        function is <code>map</code> which takes a function (the transformer) and an abitrary number of lists as its arguments. 
        The transformer must accept as many arguments as there are lists. <code>map</code> returns a list that contains the result
        of the transformations. Another mapping function is <code>for_each</code> which is similar to <code>map</code>. 
        The only difference is that, <code>for_each</code> is called for its side-effects rather than producing a value. 
        The following examples demonstrate <code>map</code> and <code>for_each</code>:</p>
      <pre>
        > map (function (x) { x * x}, [1, 2, 3, 4, 5]);
        => [1, 4, 9, 16, 25]
        > map (function (x, y) { x * y}, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]);
        => [10, 40, 90, 160, 250]
        > for_each (function (x, y) { println (x + y) }, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50]);
        11
        22
        33
        44
        55</pre>
      <h4>Searching, filtering etc</h4>
        <p>There are two functions that can be used to check a list for the existence of a particular element: <code>find</code>
          and <code>is_member</code>. <code>find</code> takes a predicate that takes a single argument and returns the first 
          element that makes it evaluate to <code>true</code>. While no element is found that satisfies this condition, <code>find</code>
          return <code>false</code>. This behaviour can be overriden by providing a value for the <code>default</code> parameter. </p>
        <pre>
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 2) == 0 });
          => 2
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 });
          => false
          > find ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 }, default = "not found");
          => "not found"
        </pre>
        <p><code>is_member</code> returns <code>true</code> if an element exists in the list. By default it uses the <code>==</code>
          operator to compare the values. This can be overriden by passing a comparison predicate to the <code>test</code> argument.</p>
        <pre>
          > is_member ([1, 2, 3, 4, 5], 4);
          => true
          > is_member ([1, 2, 3, 4, 5], 7);
          => false
          > is_member (["a", "b", "c", "d", "e"], "b", test = string_is_eq);
          => true
          > is_member (["a", "b", "c", "d", "e"], "f", test = string_is_eq);
          =>false</pre>
        <p>Another function, similar to <code>find</code> is <code>filter</code>. It returns all elements that statisfies the predicate.</p>
        <pre>
          > filter ([1, 2, 3, 4, 5], function (x) { remainder (x, 2) == 0 });
          => [2, 4]
          > filter ([1, 2, 3, 4, 5], function (x) { remainder (x, 10) == 0 });
          => []</pre>
        </div>
      </div>

  </body>
</html>
