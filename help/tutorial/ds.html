<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Other data structures</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Other data structures</h2>
        <p>This chapter shows how to use data structures other than <a href="./lists.html">lists</a>: arrays, strings, tables and records.</p>
        <h3>Arrays</h3>
        <p><i>Arrays</i> are structures similar to lists but they occupy less space and the average time required to access a random
          element by index is typically less than that required for a list. The <code>array</code> function is used to create an array
          of a specified length. By default, all elements are initialized to <code>false</code>. This behaviour can be overriden by
          specifying a value for the <code>fill</code> keyword parameter. Array literals are enclosed in <code>#[]</code>.
          <code>array_at</code> and <code>array_set</code> are used to access and update elements by index. 
          Keep in mind that <code>array_set</code> is a destructive operation:</p>
        <pre>
          > var a = array (3);
          > a;
          => #[false, false, false]
          > a = array (3, fill = "hello");
          > a;
          => #["hello", "hello", "hello"]
          > array_at (a, 2);
          => "hello"
          > array_set (a, 2, !hi);
          > a;
          => #["hello", "hello", hi]
          > array_length (#[1, 2, 3, 4, 5]);
          => 5</pre>
        <h4>Example: Phone book</h4>
        <p>This example shows how to search for an object in a sorted array. Each entry in the array contains a pair representing
          the name and phone number of a person. First we will see how such an array can be sorted. The we will write a function
          that does a fast number lookup in the array, given the name of the contact person.<p>
        <p>Sorting the array is simple - just use the <code>array_sort</code> function with a custom <code>test</code> function
          that orders pairs based on their first element, which must be a string:</p>
        <pre>
          > var contacts = #[["sam" "98289182"], ["anna" "88499394"],
                 ["caroline" "993002993"], ["ankit" "38929839"],
                 ["paul" "322288348"], ["sean" "12122123"]];
          > array_sort (contacts, test = function (a, b) { string_is_gt (head (a), head (b)) });
          => #[["ankit" "38929839"], ["anna" "88499394"], ["caroline" "993002993"], 
               ["paul" "322288348"], ["sam" "98289182"], ["sean" "12122123"]]</pre>
        <p>Now that we have sorted the array, we can implement the <code>lookup</code> function. <code>lookup</code> does a binary search
          on the array. If the contact being searched for is at the middle of the array, its phone number is returned. If the mid-entrie's
          name is lexicographically less than the name searched for, the search continues with the left half of the array, otherwise the
          right half is searched. So on each iteration, the array is halved until either the name is found or the array is exhauseted, which
          will result in <code>false</code> being returned.</p>
        <pre>
        > var lookup = function (name, contacts) {
            let len = array_length (contacts)
            if len == 0 false
            else 
            let mid = floor (len / 2) // floor converts its argument to an integer.
              let entry = array_at (contacts, mid)
                if string_is_eq (name, head (entry)) tail (entry)
                else if string_is_lt (name, head (entry)) lookup (name, subarray (contacts, 0, mid))
                else lookup (name, subarray (contacts, mid + 1, array_length (contacts)))
          };

        > lookup ("anna", contacts);
        => "88499394"
        > lookup ("sean", contacts);
        => "12122123"
        > lookup ("vijay", contacts);
        => false</pre>
        <p><code>lookup</code> introduces a new function for manipulating arrays: <code>subarray (a, start, end)</code>.
          It creates a new array formed by the elements of <code>a</code> beginning with index <code>start</code>
          (inclusive) and ending with index <code>end</code> (exclusive).</p>
        <h4>Multi-dimensional arrays</h4>
        <p>Slogan provides multi-dimensional arrays, i.e an array of arrays or an array of arrays of arrays and so on.
          An array of multiple dimensions are created by calling the <code>array</code> function with a list of dimensions as the
          first argument: </p>
        <pre>
          > array ([2, 3]);
          => #[#[false, false, false], #[false, false, false]]
          > array ([2, 3], fill = !hi);
          => #[#[hi, hi, hi], #[hi, hi, hi]]</pre>
        <h4>Example: Date conversion</h4>
        <p>This sections shows the definition of two date conversion functions: <code>day_of_year</code> and <code>month_day</code>.
          <code>day_of_year</code> takes two arguments, <code>month</code> and <code>day</code>, and converts them into the day of the year.
          For example, the arguments <code>month = 3</code> (March) and <code>day = 1</code> will return <code>60</code> for a non-leap year.
          <code>month_day</code> will convert the day of the year into a pair of month and day. <code>month_day (year = 1987, day = 60)</code>
          will return <code>[3 1]</code>. Both these functions need access to a single table that contains number of days in each month
          for a leap year and a non-leap year. This table can be represented as a multi-dimensional array of two rows and thirteen columns:</p>
        <pre>
          > var day_table =  = #[ #[0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                                  #[0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ];</pre>
        <p>We also need to define a helper function <code>is_leap</code> to check if the given year is a leap year or not:</p>
        <pre>
          > var is_leap = 
              function (year) { 
                and (is_zero (remainder (year, 4)),
                     or (not (is_zero (remainder (year, 100))),
                         is_zero (remainder (year, 400))))
            };</pre>
        <p>Now we are ready to define the two date conversion functions:</p>
        <pre>
          > var day_of_year = 
              function (year, month, day) {
                array_reduce (array_at (day_table, if is_leap (year) 1 else 0),
                              add, start = 1, end = month, 
                              initial_value = day)
            };

          > var month_day = 
              function (year, yday) {
                letrec loop = function (month, yday, mdays) { 
                                let days_in_month = array_at (mdays, month)
                                  if yday > days_in_month loop (month + 1, yday - days_in_month, mdays)
                                  else [month yday]
                             }
                   loop (1, yday, array_at (day_table, if is_leap (year) 1 else 0))
            };</pre>
        <p><code>day_of_year</code> makes use of the array mapping function <code>array_reduce</code> which calls
          a function for each element of the array. Here we add the days of all months upto <code>month</code> to
          find the day of the year:</p>
        <pre>
          > day_of_year (2016, 3, 1);
          => 61
          > day_of_year (2015, 3, 1);
          => 60
          > day_of_year (2015, 12, 31);
          => 365</pre>
        <p><code>month_day</code> shows how a tail-recursive function could be used in place of a traditional loop. The <code>loop</code>
          function calls itself until the day of the year (<code>yday</code>) could fit into a month. That month and the remaining value of
          <code>yday</code> is returned as result:</p>
        <pre>
          > month_day (2016, 61);
          => [3 1]
          > month_day (2015, 60);
          => [3 1]
          > month_day (2015, 365);
          => [12 31]</pre>
        <h3>Strings and Characters</h3>
        <p>Slogan supports the Unicode character encoding standard. Slogan characters can be any of the characters whose Unicode 
          encoding is in the range 0 to #x10ffff (inclusive) but not in the range #xd800 to #xdfff. Individual characters are surrounded
          by single quotes and strings are surrounded in double quotes:</p>
        <pre>
          > is_char ('a');
          => true
          > is_char ("a");
          => false
          > is_string ("a");
          =>true</pre>
        <p><code>char_to_integer</code> returns the Unicode encoding of a character. <code>integer_to_char</code> returns the 
          character representation of a Unicode encoding.</p>
        <pre>
          > 
      </div>
    </div>
    
  </body>
</html>
