<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Other data structures</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Other data structures</h2>
        <p>In the <a href="./lists.html">last chapter</a> we saw how to use the list data structure. 
          In this chapter we will meet the other Slogan data structures: arrays, strings, tables and records.</p>
        <h3>Arrays</h3>
        <p><i>Arrays</i> are structures similar to lists but they occupy less space and the average time required to access a random
          element by index is typically less than that required for a list. The <code>array</code> function is used to create an array
          of a specified length. By default, all elements are initialized to <code>false</code>. This behaviour can be overridden by
          specifying a value for the <code>fill</code> keyword parameter. Array literals are enclosed in <code>#[]</code>.
          The functions <code>array_at</code> and <code>array_set</code> are used to access and update elements by index. 
          <code>array_set</code> is a destructive operation because it updates the array in-place:</p>
        <pre>
          > var a = array (3);
          > a;
          => #[false, false, false]
          > a = array (3, fill = "hello");
          > a;
          => #["hello", "hello", "hello"]
          > array_at (a, 2);
          => "hello"
          > array_set (a, 2, !hi);
          > a;
          => #["hello", "hello", hi]
          > array_length (#[1, 2, 3, 4, 5]);
          => 5</pre>
        <h4>Example: Phone book</h4>
        <p>This example shows how to search for an object in a sorted array. Each entry in the array contains a pair representing
          the name and phone number of a person. First we will see how such an array can be sorted. The we will write a function
          that does a fast number look-up in the array, given the name of the contact person. First let us define the array
          to hold our contacts:<p>
          <pre>
          > var contacts = #[["sam" "98289182"], ["anna" "88499394"],
                 ["caroline" "993002993"], ["ankit" "38929839"],
                 ["paul" "322288348"], ["sean" "12122123"]];</pre>

        <p>Sorting the array is simple - call <code>array_sort</code> with a function that orders pairs based on their first element
          which must be a string:</p>
        <pre>
          > array_sort (contacts, test = function (a, b) { string_is_gt (head (a), head (b)) });
          => #[["ankit" "38929839"], ["anna" "88499394"], ["caroline" "993002993"], 
               ["paul" "322288348"], ["sam" "98289182"], ["sean" "12122123"]]</pre>
        <p>Now that we have sorted the array, we can implement the <code>lookup</code> function. <code>lookup</code> does a binary search
          on the array. If the contact being searched for is at the middle of the array, its phone number is returned. If the mid-entry's
          name is lexicographically less than the name searched for, the search continues with the left half of the array, otherwise the
          right half is searched. So on each iteration, the array is halved until either the name is found or the array is exhausted, in which
          case <code>false</code> is returned.</p>
        <pre>
        > var lookup = function (name, contacts) {
            let len = array_length (contacts)
            if len == 0 false
            else 
            let mid = floor (len / 2) // floor converts its argument to an integer.
              let entry = array_at (contacts, mid)
                if string_is_eq (name, head (entry)) tail (entry)
                else if string_is_lt (name, head (entry)) lookup (name, subarray (contacts, 0, mid))
                else lookup (name, subarray (contacts, mid + 1, array_length (contacts)))
          };

        > lookup ("anna", contacts);
        => "88499394"
        > lookup ("sean", contacts);
        => "12122123"
        > lookup ("vijay", contacts);
        => false</pre>
        <p><code>lookup</code> introduces a new function for manipulating arrays: <code>subarray (a, start, end)</code>.
          It creates a new array formed by the elements of <code>a</code> beginning with index <code>start</code>
          (inclusive) and ending with index <code>end</code> (exclusive).</p>
        <h4>Multi-dimensional arrays</h4>
        <p>Slogan supports multi-dimensional arrays, i.e an array of arrays or an array of arrays of arrays and so on.
          An array of multiple dimensions are created by calling the <code>array</code> function with a list of dimensions as the
          first argument: </p>
        <pre>
          > array ([2, 3]);
          => #[#[false, false, false], #[false, false, false]]
          > array ([2, 3], fill = !hi);
          => #[#[hi, hi, hi], #[hi, hi, hi]]</pre>
        <h4>Example: Date conversion</h4>
        <p>This sections shows the definition of two date conversion functions: <code>day_of_year</code> and <code>month_day</code>.
          <code>day_of_year</code> takes two arguments - <code>month</code> and <code>day</code> - and converts them into the day of the year.
          For example, the arguments <code>month = 3</code> (March) and <code>day = 1</code> will return <code>60</code> for a non-leap year.
          <code>month_day</code> will convert the day of the year into a pair of month and day. <code>month_day (year = 1987, day = 60)</code>
          will return <code>[3 1]</code>. Both these functions need access to a single table that contains number of days in each month
          for a leap year and a non-leap year. This table can be represented as a multi-dimensional array of two rows and thirteen columns:</p>
        <pre>
          > var day_table =  #[ #[0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                                #[0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ];</pre>
        <p>We also need to define a helper function <code>is_leap</code> to check if the given year is a leap year or not:</p>
        <pre>
          > var is_leap = 
              function (year) { 
                and (is_zero (remainder (year, 4)),
                     or (not (is_zero (remainder (year, 100))),
                         is_zero (remainder (year, 400))))
            };</pre>
        <p>Now we are ready to define the two date conversion functions:</p>
        <pre>
          > var day_of_year = 
              function (year, month, day) {
                array_reduce (array_at (day_table, if is_leap (year) 1 else 0),
                              add, start = 1, end = month, 
                              initial_value = day)
            };

          > var month_day = 
              function (year, yday) {
                letrec loop = function (month, yday, mdays) { 
                                let days_in_month = array_at (mdays, month)
                                  if yday > days_in_month loop (month + 1, yday - days_in_month, mdays)
                                  else [month yday]
                             }
                   loop (1, yday, array_at (day_table, if is_leap (year) 1 else 0))
            };</pre>
        <p><code>day_of_year</code> makes use of the array mapping function <code>array_reduce</code> which calls
          a function for each element of the array. Here we add the days of all months up to <code>month</code> to
          find the day of the year:</p>
        <pre>
          > day_of_year (2016, 3, 1);
          => 61
          > day_of_year (2015, 3, 1);
          => 60
          > day_of_year (2015, 12, 31);
          => 365</pre>
        <p><code>month_day</code> shows how a tail-recursive function could be used in place of a traditional loop. The <code>loop</code>
          function calls itself until the day of the year (<code>yday</code>) could fit into a month. That month and the remaining value of
          <code>yday</code> is returned as result:</p>
        <pre>
          > month_day (2016, 61);
          => [3 1]
          > month_day (2015, 60);
          => [3 1]
          > month_day (2015, 365);
          => [12 31]</pre>
        <h3>Strings and Characters</h3>
        <p>Slogan supports the Unicode character encoding standard. Slogan characters can be any of the characters whose Unicode 
          encoding is in the range 0 to #x10ffff (inclusive) but not in the range #xd800 to #xdfff. Individual characters are surrounded
          by single quotes and strings are surrounded in double quotes:</p>
        <pre>
          > is_char ('a');
          => true
          > is_char ("a");
          => false
          > is_string ("a");
          =>true</pre>
        <p><code>char_to_integer</code> returns the Unicode encoding of a character. <code>integer_to_char</code> returns the 
          character representation of a Unicode encoding.</p>
        <pre>
          > char_to_integer ('A');
          => 65
          > integer_to_char (71);
          => 'G'</pre>
        <p>The character comparison functions are <code>char_is_eq</code>, <code>char_is_lt</code>, <code>char_is_gt</code>, 
          <code>char_is_lteq</code> and <code>char_is_gteq</code>. Similarly, string comparison functions are <code>string_is_eq</code>,
          <code>string_is_lt</code>, <code>string_is_gt</code>, <code>string_is_lteq</code> and <code>string_is_gteq</code>. The
          generic sequence equality predicate <code>is_equal</code> can be used instead of <code>string_is_eq</code>.</p>
        <pre>
          > char_is_eq ('a', 'A');
          => false
          > char_is_eq ('a', 'A', ignore_case = true);
          => true
          > char_is_eq ('a', 'B', ignore_case = true);
          => false
          > char_is_lt ('a', 'z');
          => true
          > char_is_lt ('a', 'A');
          => false
          > char_is_lt ('a', 'Z');
          => false
          > char_is_lt ('a', 'Z', ignore_case = true);
          => true
          > string_is_eq ("hello", "Hello");
          => false
          > string_is_eq ("hello", "Hello", ignore_case = true);
          => true</pre>
        <p>Other useful operations on a string are finding its length and accessing individual characters using their index:</p>
        <pre>
          > var s = "hello, world";
          > string_length (s);
          => 12
          > string_at (s, 5);
          => ','
          > string_set (s, 0, 'H');
          > string_set (s, 7, 'W');
          > s;
          => "Hello, World"</pre>
        <p>Just like lists and arrays, there are mapping functions for strings. <code>string_map</code> returns a new
          string where each character is the result of applying the function to each character of the original string.
        <code>string_for_each</code> is similar to <code>string_map</code> but is called for its side-effect:</p>
        <pre>
          > string_map ("hello", function (c) { char_upcase (c) });
          => "HELLO"
          > string_for_each ("hello", function (c) { print (c) });
          'h''e''l''l''o'</pre>
        <p>In addition to string literals, the functions <code>string</code>, <code>string_append</code> and <code>substring</code>
          can be used to create new strings: </p>
        <pre>
          > string (10);
          => "\0\0\0\0\0\0\0\0\0\0"
          > string (10, 'a');
          => "aaaaaaaaaa"
          > string_append ("hello, ", "world", "!");
          => "hello, world!"
          > substring ("hello, world!", 0, 5);
          => "hello"</pre>
        <h4>Example: Date parsing</h4>
        <p>Before we conclude the section on strings, we will write a simple function to parse dates in the format "DD MON YYYY"
          into a list of integers. For example, the input <code>"02 AUG 2012"</code> will be converted to
          <code>[2, 8, 2012]</code>. The main purpose of this sample is to introduce some more useful string functions.</p>
        <pre>
          > var months = #[!JAN, !FEB, !MAR,
                           !APR, !MAY, !JUN,
                           !JUL, !AUG, !SEP,
                           !OCT, !NOV, !DEC];

          > var parse_date = 
              function (str_date) {
                let parts = string_split (str_date)
                  if not (length (parts) == 3) {
                     println ("Date should be in DD MON YYYY format.");
                     false
                  } else {
                     let mon = array_index_of (months, string_to_symbol (at (parts, 1)))
                       if mon == -1 {
                         println ("Invalid month. ", at (parts, 1));
                         false
                       } else {
                         let year = string_to_number (at (parts, 2)), month = mon + 1
                           [validate_mday (month, year, string_to_number (at (parts, 0))),
                            month,
                           year]
                       }
                  }
               };

          > var validate_mday =
              function (month, year, mday) {
                 if (mday &gt; 0 && mday &lt;= (array_at (array_at (day_table, if is_leap (year) 1 else 0), month))) mday
                 else false
            };
          
          // Some tests:
          > parse_date ("02 AUG 2012");
          => [2, 8, 2012]
          > parse_date ("31 DEC 2014");
          => [31, 12, 2014]</pre>
        <p>The <code>parse_date</code> function introduces these new built-in functions: <code>string_split</code>,
          <code>array_index_of</code>, <code>string_to_symbol</code> and <code>string_to_number</code>. </p>
        <p><code>string_split</code> breaks up a string into a list of strings using a character or list of characters
          as delimiters. The delimiter character defaults to space:</p>
        <pre>
          > string_split ("hello, world");
          => ["hello,", "world"]
          > string_split ("hello, world", ',');
          => ["hello", " world"]
          > string_split ("hello, world", [',', 'o']);
          => ["hell", " w", "rld"]</pre>
        <p><code>string_to_symbol</code> and <code>string_to_number</code> does the obvious - they convert strings to symbols and
          numbers.</p>
        <p><code>array_index_of</code> returns the index of an element in the array. If the element is not found <code>-1</code> is returned.
          An optional comparison predicate can be passed as the <code>test</code> keyword parameter:</p>
        <pre>
          > array_index_of (#[1, 2, 3], 1);
          => 0
          > array_index_of (#[1, 2, 3], 10);
          => -1
          > array_index_of (#['a', 'b', 'c'], 'a');
          => 0
          > array_index_of (#["a", "b", "c"], "a");
          => -1
          > array_index_of (#["a", "b", "c"], "a", test = string_is_eq);
          => 0</pre>
        <p>The <code>parse_date</code> function does not do a lot of data validation. It just checks if the month is valid and the day
          falls within that month. As an extended exercise, you can add more validation code to <code>parse_date</code> and make 
          it robust. Instead of printing an error message, you may want to try the <code>error</code> function to raise
          exceptions. In a later chapter we will cover exceptions in more detail.</p>
        <h3>Tables</h3>
        <p>In the chapter on <a href="./lists.html">lists</a>, we saw how to use lists as tables of key-value pairs. We used the
          <code>assoc_***</code> functions to store and retrieve values from these structures. But lists can get inefficient for 
          large number of key-value pairs as it has to be sequentially scanned to access a particular entry. <em>Tables</em> are
          array-like structures whose elements are indexed by keys which are arbitrary objects. They typically has faster access times
          than association lists. The following REPL session demonstrates most of the useful table functions:</p>
        <pre>
          > var fruit_colors = table();
          > table_set (fruit_colors, !apricot, !yellow);
          > table_set (fruit_colors, !orange, !orange);
          > table_set (fruit_colors, !apple, !red);
          > table_at (fruit_colors, !apricot);
          => yellow
          > table_at (fruit_colors, !apple);
          => red
          > table_at (fruit_colors, !banana);
          => false
          > table_at (fruit_colors, !banana, !yellow);
          => yellow
          > table_set (fruit_colors, !apple, !green);
          > table_at (fruit_colors, !apple);
          => green
          > table_length (fruit_colors);
          => 3
          > table_for_each (function (key, value) { println (key, ": ", value) }, fruit_colors);
          >> orange": "orange
             apple": "green
             apricot": "yellow </pre>
        <p>The table uses a hash function to convert the key into an integer index into an array. The default hash function
          is good enough for almost all built-in types like lists, strings and arrays. If you want to customize the way
          key hashes are created, you can provide the table constructor with a hash function which takes a key
          object as parameter and returns an integer that uniquely identifies the key:</p>
        <pre>
          > var coords = table (hash = function (p) { real_to_integer (head (p) + tail (p) * 31) });
          > table_set (coords, [12.9667 77.5667], "Bangalore");
          > table_set (coords, [13.0839 80.2700], "Chennai");
          > table_at (coords, [13.0839 80.2700]);
          => "Chennai"
          > table_at (coords, [13.0839 80.27]);
          => "Chennai"
          > table_at (coords, [13.0839 80]);
          => false</pre>
        <h3>Records</h3>
        <p>A record is a collection of one or more variables collected together under a single name. Records are used to
          organize complicated data. A simple example of a record is one that represents a point in the cartesian coordinate
          system:</p>
        <pre>
          > record point (x , y);
          > var p = point (x = 10, y = 20);
          > is_point (p);
          => true
          > point_x (p);
          => 10
          > point_y (p);
          => 20
          > point_set_x (p, 100);
          > point_set_y (p, 200);
          > point_x (p);
          => 100
          > point_y (p);
          => 200</pre>
        <p>When we define a new record, Slogan automatically creates the following functions to 
          create and manipulate record objects:</p>
        <ol>
          <li>A constructor with the same name as the record.</li>
          <li>A predicate for checking if an object is an instance of the record.</li>
          <li>Accessors and modifiers for record members.</li>
        </ol>
        <p>Once defined, a record gets the same status as the built-in types of the language - it can be passed as arguments to
          functions and it can be returned as results of functions. For example, here is a function that adds two points together
          to create a new point:</p>
        <pre>
          > var add_points = 
              function (p1, p2) {
                point (x = point_x (p1) + point_x (p2), y = point_y (p1) + point_y (p2))
            };
          > add_points (point (x = 10, y = 20), point (x = 12, y = 15));
          => #&lt;point #3 x: 22 y: 35&gt;</pre>
      </div>
    </div>
    
  </body>
</html>
