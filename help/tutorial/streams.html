<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Streams</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Streams</h2>
        <p>Streams are input and output devices that can read and write characters. Slogan supports various types of streams:
          files, strings, byte arrays, network etc. All types of streams can be created with a single constructor 
          called <code>stream</code>. The first argument to this function identifies the type of the stream to create.
          This implementation of Slogan supports the following types of streams: <code>!file</code>, <code>!directory</code>, 
          <code>!string</code>, <code>!array</code>, <code>!byte_array</code>, <code>!tcp_client</code>, <code>!tcp_server</code>
          and <code>!process</code>. The second argument is an association list that map symbolic settings to values.
          All streams can have these two common settings: <code>!direction</code> and <code>!buffering</code>. Direction
          is one of three values: <code>!output</code>, <code>!input</code> and <code>!output_input</code>. Buffering
          cane be either <code>true</code>, <code>false</code> or <code>!line</code>.</p>
        <p>Streams like that connect to system resources like files and the network must be closed after use. Otherwise it may
          lead to a <em>resource leak</em>. The function <code>close_stream</code> is called to free the system resources 
          acquired by the stream. Given below is a programming idiom that will ensure that a stream is closed even in the case of an 
          exceptional event: </p>
        <pre>
          let s = stream (&lt;type&gt;, &lt;settings&gt;)
          try (function () { /* read/write the stream. */ },
               catch = function (exception) { /* handle exception. */ },
               finally = function () { if s close_stream (s) });</pre>
        <p>The streams library provides a convenience function that wraps over this idiom. It is called <code>with_stream</code>.
          It accepts a stream type, settings and a function of arity one. The stream is opened using the settings and the function
          is called with the opened stream as argument. If the function raises an exception, <code>with_stream</code> makes sure that
          the stream is closed and re-throws the exception. If no exception occurs the value of the function is returned after closing
          the port.</p>
        <p>The common functions used to read from an input stream are <code>read_char</code> and
          <code>read_expression</code>. <code>read_char</code> reads and returns a single character from the stream. 
          To check if a character is ready to be read from the stream you can use the <code>is_char_ready</code> predicate.
          <code>peek_char</code> returns the next character without actually removing it from the stream. 
          <code>read_expression</code> reads a whole Slogan expression from the stream. It means it can be used to read
          literals for strings, numbers, lists, functions and other Slogan data. The function <code>read_program</code>
          is used to read whole program statements from streams, including semicolon terminated variable declarations,
          assignments and record definitions.</p>
        <p>An attempt to read beyond the end of the stream will return a special object called the <code>end-of-stream</code>. 
          The predicate <code>is_eos</code> checks if an object represents the end-of-stream.</p>
        <p>Data is written to streams using the <code>print</code>, <code>println</code>, <code>write_char</code> and 
          <code>write_expression</code> functions. <code>print</code> can take an arbitrary number of Slogan data and output
          their human-readable representation. <code>println</code> is the same as <code>print</code> but it also emits a
          newline character after the data. This is achieved by calling the <code>newline</code> function. These two functions
          take an optional <code>to</code> keyword parameter that default to the value of <code>current_output_stream</code>.
          <code>write_char</code> writes an individual character to the stream and <code>write_expression</code> 
          writes a whole scheme expression.</p>
        <p>There are a few more stream input/output functions that we did not mention here. They will be introduced as we
          discuss specific stream types. In the following sections gives an overview of three stream types that are
          most often used - file, string and tcp-server/client.</p>
        <h3>File</h3>
        <p>File streams are used to read and write data on files. A file stream is opened by specifying the type as 
          <code>file</code> in the stream constructor. Type specific settings accepted by the constructor are: 
          <ul>
            <li><code>!path:</code> The location of the file. This setting is required.</li>
            <li><code>!append:</code> A boolean value indicating whether to open the file in append more or not.</li>
            <li><code>!create:</code> Can be a boolean value or the symbol <code>!maybe</code>. The value <code>true</code>
              will try to create the file and raises an exception if the file already exists. The value <code>false</code>
              requires that the file already exist. <code>!maybe</code> will try to create the file if it does not exist.
              The default value is <code>!maybe</code> for output streams and <code>false</code> for other streams.</li>
            <li><code>!permissions:</code> UNIX style file permissions, default is 0o666.</li>
            <li><code>!truncate:</code> <code>true</code> or <code>false</code>. Controls whether the file will be truncated
              upon opening. Default is <code>true</code> for output streams when append is <code>false</code> and <code>false</code>
              otherwise.</li>
          </ul>
        </p>
        <p>The following example shows how to open a file and write and read a line of text on it:</p>
        <pre>
          > var f = stream (!file, [[!path "hello.txt"], [!direction !output]]);
          > println (to = f, "hello, world!");
          > close_stream (f);

          > f = stream (!file, [[!path "hello.txt"], [!direction !input]]);
          > read_line (f);
          => "hello, world!"
          > close_stream (f);</pre>
        <p><code>read_line</code> reads characters from an input stream until a specific separator or the end-of-stream is encountered.
          The characters read are returned as a string. The separator can be specified as the second argument and it defaults to the
          <code>newline</code> character.</p>
        <p>The above example can be re-written using <code>with_stream</code> so that the task of closing the stream after use will
          be taken care for us:</p>
        <pre>
          > with_stream (!file, [[!path "hello.txt"], [!direction !output]],
                         function (f) { println (to = f, "hello, world!") });
          > with_stream (!file, [[!path "hello.txt"], [!direction !input]],
                         function (f) { read_line (f) });
          => "hello, world!"</pre>
        <h3>Example: Copying files</h3>
        <p>This example shows a function that copies a file byte-by-byte. For this we make use of the stream functions that can read
          and write 8-bit unsigned values. </p>
        <pre>
var file_copy = 
    function (src, dest) {
        with_stream (!file, [[!path dest], [!direction !output]],
                     function (out_stream) {
                         with_stream (!file, [[!path src], [!direction !input], [!buffering true]],
                                      function (in_stream) {
                                          letrec loop = function () {
                                              let buffer = byte_array (1024)
                                              let r = read_bytes (buffer, 0, 1024, in_stream, 1024)
                                              if r > 0 { write_bytes (buffer, 0, r, out_stream); loop () }
                                          } loop()
                                      })
                     })
    };</pre>
        <p><code>read_bytes</code> fills its first argument, which must be a <code>byte_array</code>, with bytes from a stream.
          The second and third arguments are optional and specifies the range of indices in the byet array that will get filled.
          If these values are ommited, they will default to 0 and the size of the array. The third argument is the input stream.
          And the last argument specifies the number of bytes that needs to be read. <code>write_bytes</code> writes the content
          of a byte array starting and ending at the specified index range to an output stream.</p>
        <h2>String</h2>
        <p>String streams represent in-memory streams of characters: </p>
        <pre>
          > var name = "nook";
          > var age = 22;
          > with_stream (!string, "", function (s) { print (to = s, "name: ", name, ", age: ", age); get_output_string (s) });
          "name: nook, age: 22"</pre>
      </div>
    </div>
  </body>
</html>
