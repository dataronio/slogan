<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Scope and Context</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Scope and Context</h2>
        <p>The scope a variable is the part of the program where the variable can be used. A variable declared with <code>var</code>
          is visible to the entire program. One way to limit the scope of a variable is to declare them within a function:</p>
        <pre>
          > function(x) { var y = 100; x * y };
          => [function]
          > x;
          error: unbound global x
          > y;
          error: unbound global y</pre>
        <p>The scope of <code>x</code> and <code>y</code> are limted to the body of the function. Variables of the same name 
          can be declared and used outside the function without causing any conflicts. It is not necessary to explicitly create
          a function just to limit the scope of some variables. This can be done with code blocks:</p>
        <pre>
          > { var x = 10; var y = 20; x * y };
          => 200
          > x;
          error: unbound global x
          > y;
          error: unbound global y</pre>
        <p>Another option is to use the <code>let*</code> family of expressions. They allows a more explicit introduction of 
          the variables to be used locally.</p>
        <h3>let, letseq and letrec</h3>
        <p>The three binding constructs that can be used to introduce local variables are <code>let</code>, <code>letseq</code>
          and <code>letrec</code>. All of them has the same structure - the <code>let*</code> keyword is followed by a
          sequence of comma separated variable declarations and then the body of code that makes use of those variables: </p>
        <pre>
          > let x = 1, y = 2, z = 3
            [x, y, z];
          => [1, 2, 3] </pre>
        <p>As with a function, the local definitions in a <code>let</code> will <em>shadow</em> any global defintiion with the
          same name:</p>
        <pre>
          > var x = 10;
          > let x = 100, y = 200 x + y;
          => 300
          > x;
          => 10
          > let x = x, y = 200 x + y;
          => 210 </pre>
        <p>In the last expression throws some light on how <code>let</code> initializes the variables. First, the initialization expression
          is evaluated with the variable bindings at the beginning of <code>let</code>. Here we have two expressions - <code>x</code> and
          <code>200</code>. <code>x</code> evaluates to <code>10</code> and <code>200</code> evaluates to itself. As the next step, a new
          <em>environment</em> of variable bindings is created for <code>let</code> and two slots named <code>x</code> and <code>y</code> are
          created there. <code>10</code> is assigned to <code>x</code> and <code>200</code> to <code>y</code>. The body of <code>let</code>
          always refers to its local enviroment when it has to find the value of a variable. Only if it cannot find the variable there it will
          refer to the environment in which <code>let</code> was evaluated. This behavior is what causes the <em>shadowing</em> that we
          observe.</p>
        <p><code>letseq</code> is similar to <code>let</code> but the definition and initialization of each local variable is done 
          sequentially. In our earlier example, this means that <code>y</code> is bound in an environment which already has a valid binding
          for <code>x</code>. So initialization expressions can refer to local variables bound previously:</p>
        <pre>
          > letseq a = 10, b = a * 100 a + b;
          => 1010</pre>
        <p><code>letrec</code> initializes all local bindings to empty slots in the new environment. This makes it possible for all
          initialization expressions to refer to other local variables despite of their position in the declaration sequence. <code>letrec</code>
          can be used for defining local functions that make recursive calls to each other: </p>
        <pre>
          > letrec is_even = function (n) { if is_zero (n) true else is_odd (n - 1) },
                   is_odd = function (n) { if is_zero (n) false else is_even (n - 1) }
            is_even (88);
          => true </pre>
        <h3>Conditionals</h3>
        <p>We have already encountered the <code>if</code> conditional expression. Unlike its counterparts in other languages <code>if</code>
          in Slogan is an expression in that it evaluates to a value. It has the following general form: </p>
        <code>&nbsp;&nbsp;&nbsp;&nbsp;if &lt;condition&gt; &lt;expression1&gt; else &lt;expression2&gt;</code>
        <p>If <code>condition</code> evaluates to <code>true</code> <code>expression1</code> is evaluated otherwise <code>expression2</code>
          is evaluated. The <code>else</code> part is optional. If <code>else</code> is not specified and <code>condition</code> evaluates
          to <code>false</code>, <code>if</code> returns the special <code>void</code> value. Multiple conditions are checked by 
          nesting more <code>if</code> expressions in the <code>else</code> clause:</p>
        <pre>
          > var x = 3;
          > var y = 2;
          > if x > y !greater
            else if y > x !less
            else !equal;
          => greater</pre>
        <p>The <code>case</code> expression is used to compare the value of an expression with a list of constants: </p>
        <pre>
          > var signal = function () { array_at (#[!red, !green, !ambre], random (3)) };
          > var check_signal = 
             function () {
               case signal () {
                 red: "Stop!"
                 green: "Go!"
                 ambre: "Watch!"
                 else: "Invalid signal!"
               }
            };
          > check_signal();
          => "Watch!"
          > check_signal();
          => "Stop!"</pre>
        <p><code>case</code> has the following syntax: </p>
        <pre>
          case &lt;expression&gt; {
              &lt;value1&gt;: &lt;result-expression1&gt;
              &lt;value2&gt;: &lt;result-expression2&gt;
              &lt;valueN&gt;: &lt;result-expressionN&gt;
              else: &lt;else-expression&gt;
          }</pre>
        <p>Case values can be of any type for which the euqlity operator (<code>==</code>) works.</p>
      </div>
    </div>
  </body>
</html>
