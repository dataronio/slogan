
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Scope and Control</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Scope and Control</h2>
        <p>The <em>scope</em> of a variable is that part of the program where the variable can be used. A variable declared with <code>var</code>
          is visible to the entire program. One way to limit the scope of a variable is to declare it within a function:</p>
        <pre>
          > function(x) { var y = 100; x * y };
          => [function]
          > x;
          >> error: Unbound variable: x
          > y;
          >> error: Unbound variable: y</pre>
        <p>The scope of <code>x</code> and <code>y</code> are limited to the body of the function. Variables of the same name 
          can be declared and used outside the function without causing any conflicts. It is not necessary to explicitly create
          a function just to limit the scope of some variables. This can be done with code blocks:</p>
        <pre>
          > { var x = 10; var y = 20; x * y };
          => 200
          > x;
          >> error: Unbound variable: x
          > y;
          >> error: Unbound variable: y</pre>
        <p>Another option is to use the <code>let*</code> family of expressions. They allows a more explicit introduction of 
          the variables to be used locally.</p>
        <h3>let, letseq and letrec</h3>
        <p>The three binding constructs that can be used to introduce local variables are <code>let</code>, <code>letseq</code>
          and <code>letrec</code>. All of them has the same structure - the <code>let*</code> keyword is followed by a
          sequence of comma separated variable declarations and then the body of code that makes use of those variables: </p>
        <pre>
          > let x = 1, y = 2, z = 3
            [x, y, z];
          => [1, 2, 3] </pre>
        <p>As with a function, the local definitions in a <code>let</code> will <em>shadow</em> any global definition with the
          same name:</p>
        <pre>
          > var x = 10;
          > let x = 100, y = 200 x + y;
          => 300
          > x;
          => 10
          > let x = x, y = 200 x + y;
          => 210 </pre>
        <p>The last expression throws some light on how <code>let</code> initializes the variables. First, the initialization expression
          is evaluated with the variable bindings at the beginning of <code>let</code>. Here we have two expressions - <code>x</code> and
          <code>200</code>. <code>x</code> evaluates to <code>10</code> and <code>200</code> evaluates to itself. As the next step, a new
          <em>environment</em> of variable bindings is created for <code>let</code> and two slots named <code>x</code> and <code>y</code> are
          created there. <code>10</code> is assigned to the <code>x</code> slot and <code>200</code> to the <code>y</code> slot. 
          The body of <code>let</code>
          always refers to its local environment when it has to find the value of a variable. Only if it cannot find the variable there it will
          refer to the environment in which <code>let</code> was evaluated. This behavior is what causes the <em>shadowing</em> that we
          observed.</p>
        <p><code>letseq</code> is similar to <code>let</code> but the definition and initialization of each local variable is done 
          sequentially. In our earlier example, this means that <code>y</code> is bound in an environment which already has a valid binding
          for <code>x</code>. So initialization expressions can refer to local variables bound previously:</p>
        <pre>
          > letseq x = 10, y = x * 100 x + y;
          => 1010</pre>
        <p><code>letrec</code> initializes all local bindings to empty slots in the new environment. This makes it possible for all
          initialization expressions to refer to other local variables despite of their position in the declaration sequence. <code>letrec</code>
          can be used for defining local functions that make recursive calls to each other: </p>
        <pre>
          > letrec is_even = function (n) if is_zero (n) true else is_odd (n - 1),
                   is_odd = function (n) if is_zero (n) false else is_even (n - 1)
            is_even (88);
          => true </pre>
        <h3>Conditionals</h3>
        <p>We have already encountered the <code>if</code> conditional expression. Unlike its counterparts in other languages, <code>if</code>
          in Slogan is an expression that evaluates to a value. It has the following general form: </p>
        <code>&nbsp;&nbsp;&nbsp;&nbsp;if &lt;condition&gt; &lt;expression1&gt; else &lt;expression2&gt;</code>
        <p>If <code>condition</code> evaluates to <code>true</code>, <code>expression1</code> is evaluated otherwise <code>expression2</code>
          is evaluated. The <code>else</code> part is optional. If <code>else</code> is not specified and <code>condition</code> evaluates
          to <code>false</code>, <code>if</code> returns the special <code>void</code> value. Multiple conditions are checked by 
          nesting more <code>if</code> expressions in the <code>else</code> clause:</p>
        <pre>
          > var x = 3;
          > var y = 2;
          > if x > y !greater
            else if y > x !less
            else !equal;
          => greater</pre>
        <p>The <code>case</code> expression is used to compare the value of an expression with a list of constants: </p>
        <pre>
          > var signal = function () array_at (#[!red, !green, !amber], random_integer (3));
          > var check_signal = 
             function ()
               case signal () {
                 red: "Stop!"
                 green: "Go!"
                 Amber: "Watch!"
                 else: "Invalid signal!"
               };

          > check_signal();
          => "Watch!"
          > check_signal();
          => "Stop!"</pre>
        <p><code>case</code> has the following syntax: </p>
        <pre>
          case &lt;expression&gt; {
              &lt;value1&gt;: &lt;result-expression1&gt;
              &lt;value2&gt;: &lt;result-expression2&gt;
              &lt;valueN&gt;: &lt;result-expressionN&gt;
              else: &lt;else-expression&gt;
          }</pre>
        <p>Case values can be of any type for which the equality operator (<code>==</code>) works.</p>
	<h4>When to use code blocks?</h4>
	<p>A code block becomes necessary in the body of a <code>let*</code> or an <code>if</code> when it contains more
	  than one expression. A code block is needed also when the body contain statements like a variable definition, assignment or a 
	  record definition. (The same rules apply to the body of a function definition as well).</p>
	<p>In the following <code>let</code>, the code block is necessary because of the definition of <code>y</code>: </p>
	<pre>
	  > let x = 10
	    { 
	      var y = 100;
	      x + y 
	    };
	  => 110</pre>
	<p>As functions are first-class objects in Slogan any expression can evaluate to a function. So if an expression is followed by
	  opening parenthesis, Slogan will try to interpret it as a list of arguments and apply it to the previous value. This makes
	  writing expressions like these possible:</p>
	<pre>
	  > (function (x) x * x) (100);
	  => 10000
	  > (function (x) function (y) x + y) (10)(20);
	  => 30</pre>
	<p>This feature also leads to the slight inconvenience that you can observe with the second <code>if</code> expression below:</p>
	<pre>
	  > if true 3 + 4 * 5;
	  => 23
	  > if true (3 + 4) * 5;
	  >> error: invalid literal expression: *semicolon*
	  > if true { (3 + 4) * 5 };
	  => 35</pre>
	<p>The problem could have been solved by adding one more keyword to <code>if</code> and <code>let</code> as follows:</p>
	  <pre>
	    let &lt;declarations&gt; in
	        &lt;body&gt;

	    if &lt;condition&gt; then
	       &lt;expression&gt;</pre>
	  <p>But to keep the number of reserved words to the minimum and because the problem
	    could be cleanly solved with code blocks, I resisted the temptation to extend the syntax of these constructs.</p>
        <h3><div id="except">Exceptions</id></h3>
        <p>Exceptions are events that change the normal flow of program execution. They are commonly used to raise a signal
          when things cannot proceed as expected. For example, a program to download some resource from a web server may raise
          an exception when a connection to the server cannot be established. An exception is raised by calling the <code>raise</code>
          function. Exceptions cause program control to break out of the current context and invoke a 
          special function called the <em>exception handler</em>. </p>
        <p>Another function for raising exceptions is <code>error</code>. It takes an error message as the first argument and an
          arbitrary number of optional arguments that will provide more information to the exception handler. The following session
          reviews all the concepts we have learned so far:</p>
        <pre>
          > raise ("oh!");
          >> error: This object was raised: "ho!"
          > error ("oh!", 1, 2, 3);
          >> error: oh! 1 2 3</pre>
        <p>The <code>try</code> expression lets us handle exceptions locally. The syntax of <code>try</code> is:</p>
        <pre>
          try &lt;expression&gt; 
          catch (&lt;exception&gt;) &lt;exception_handler&gt;</pre>
        <p>If code in the <code>try</code> block raises an exception, it is passed to the <code>catch</code> block
          where it is handled.</p>
        <pre>
          > try raise ("hello")
            catch (exception) println ("exception caught: ", exception);
          exception caught: hello</pre>
        <p>A <code>try</code> expression can also have a <code>finally</code> clause which is always executed, whether or not
          an exception is raised. So the full syntax of <code>try-catch</code> is:</p>
        <pre>
          try &lt;expression1&gt; 
          catch (&lt;exception&gt;) &lt;exception_handler&gt; 
          finally &lt;expression2&gt</pre>
        <p>A common usage scenario of <code>finally</code> is where we want to ensure that some "cleanup" happens, even if an exception
          is raised. If <code>finally</code> is specified, <code>catch</code> becomes optional. In this case the exception is 
          re-thrown after executing the <code>finally</code> clause:</p>
        <pre>
          > try raise ("oh!")
            finally println ("[[In finally]]");
            >> [[In finally]]
            >> error: This object was raised: "oh!"</pre>
        <h3>Continuations</h3>
        <p>The <em>current continuation</em> at any point in the execution of a program represents the <em>rest of the program</em>.
          Thus in the expression <code>1 + 2</code>, the continuation of <code>2</code> is <code>1 + []</code>. In other words,
          <code>1 + []</code> is waiting for the evaluation of the constant <code>2</code> to finish and fill the hole - [] - with a value
          so that the computation may continue.</p>
        <p>Slogan provides a special function called <code>callcc</code> for capturing the current continuation. <code>callcc</code>
          calls its argument, which must be a function of one parameter, with the current continuation wrapped up in a unary function object.
          Let us see how the continuation <code>1 + []</code> could be captured with <code>callcc</code> and the hole filled with a 
          value of our choice:</p>
        <pre>
          > 1 + callcc (function (k) { k (3); 2 });
          => 4</pre>
        <p>The continuation from the point of view of <code>callcc</code> is <code>1 + []</code>. When the continuation, represented
          by the function object <code>k</code> is invoked, the current computation (i,e. to evaluate <code>2</code>) is abandoned and 
          the argument passed to the continuation (here the constant <code>3</code>) replaces the hole in the continuation. So the
          continuation <code>1 + []</code> becomes <code>1 + 3</code> and it is evaluated to produce <code>4</code>.</p>
        <p>Continuations can also be used to return to a context that we already passed through. Let us capture our <code>1 + []</code>
          continuation in a variable and see if we can re-invoke it at later point in the program: </p>
        <pre>
          > var r = false;
          > 1 + callcc (function (k) { r = k; 2 });
          => 3
          > r (10);
          => 11
          > r (5);
          => 6
          > 3 + r (5);
          => 6</pre>
        <p>As you can see from the last expression, the continuations captured by <code>callcc</code> are <em>abortive</em> in that
          invoking them will always lead to abandoning the rest of the current computation. </p>
        <h4>Example: Restarting a function.</h4>
        <p>Continuations can be used to add sophisticated flow control to programs. Imagine that you want to write a function that
          saves a list of values to a database. The function needs to take care of the situation when a database write fails. 
          There are a couple of ways to approach this problem:</p>
        <p><ul>
          <li>Do nothing. This will propagate the exception up the caller stack and hope it will be handled somewhere up there.</li>
          <li>Catch the exception locally, log it and return from the function.</li>
          <li>Catch the exception locally, log and then re-throw it - giving the caller an opportunity to handle it further.</li>
          <li>Catch the exception locally, log it and continue processing the rest of the list.</li>
        </ul>
        <p>In most languages that has an exception handling mechanism (e.g. Java, C++, Python), we are pretty much limited to the above options.
          The decision on whether to terminate processing the list or to continue with the rest of the items lies completely with
          the function itself. There is no way to propagate that decision making power to the caller of the function.
          Continuations make this possible. With continuations we can add one more item to the above list: </p>
        <ul>
          <li>Catch the exception locally, log it and re-throw it along with a function that allows the user to restart
            the processing from where it had been interrupted by the exception.</li>
        </ul>
        <p>Now the caller can inspect the error, rectify the problem that caused it (if that is possible) and continue 
          processing the rest of the list. (If he wishes to!).
          The following code demonstrates the whole idea of <em>restartable</em> functions: </p>
        <pre>
// A generic function that applies `fn' to each element in
// `lst'. If an exception happens in the call to `fn' that exception
// is re-thrown along with the current continuation. The caller
// can use this continuation to restart the function from the next item
// in the list. 
// Returns a list of booleans that indicates the items that 
// were successfully processed (true) and those which have failed (false).
var process_list = function (lst, fn) {
    let mapper_with_restart = function (e) {
        println ("processing item ", e);
        callcc (function (k) { 
            try fn (e) 
            catch (ex) { 
                println (ex); 
                raise ([e k]) 
            };
            true
        });
    }
    map (mapper_with_restart, lst)
};

// Saves a list of values to a database.
// This function can raise a DB error at any time!
var save_to_db = function (e) {
    println ("saving item to db ", e);
    if is_zero (random_integer (2)) raise ("DB error!")
};

// Test:
// Call save_to_db on a list of numbers. On error, restart processing.
// Output will vary across invocations of process_list.
try process_list ([1, 2, 3, 4, 5], save_to_db)
catch (e) {
    println ("failed to save ", head (e));
    println ("restarting process_list ...");
    (tail (e)) (false);
};

>> processing item 1
saving item to db 1
processing item 2
saving item to db 2
DB error!
failed to save 2
restarting process_list ...
processing item 3
saving item to db 3
processing item 4
saving item to db 4
processing item 5
saving item to db 5
DB error!
failed to save 5
restarting process_list ...
[true, false, true, true, false]</pre>

      </div>
    </div>
  </body>
</html>
