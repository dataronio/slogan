<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Compilation and FFI</title>

    <link type="text/css" rel="stylesheet" href="../style/style.css">
  </head>

  <body>
    <div id="page" class="wide">
      <div class="container">
        <h2>Compilation and FFI</h2>
        <p>This chapter is about using Slogan to write high-performance applications that integrates well with the host operating system.</p>
        <h3>Compilation</h3>
        <p>The <code>compile</code> function translates a slogan script into machine code. For example, here is a simple script
          that we will convert to a system executable:</p>
        <pre>
          // hello.sn
          println ("hello, world!"); </pre>
        <p>This script can be compiled from the REPL as: </p>
        <pre>
          > compile ("hello", exe = true); </pre>
        <p>The <code>exe</code> keyword parameter instructs the compiler to assemble a standalone executable. This executable is
          created as "hello.run" and can be ran from the command line just like you run any other program.</p>
        <h3>FFI</h3>
        <p>The Foreign Function Interface (FFI) is a set of functions that allows a Slogan script to load a shared library (or DLL)
          and call the functions exported by it. Here is a simple shared library written in C and the Slogan function call
          that invokes the functions in it:</p>
        <pre>/* mylib.c */
#include <stdio.h>
#include "slogan.h"
 
void c_hello (void)
{
  printf ("hello from C!\n");
}

int c_add_two_ints (___slogan_obj i, ___slogan_obj j)
{
  return ___int (i) + ___int (j);
}</pre>
        <p>On a platform with the GCC compiler suite installed, a dynamically loadable library is created using these commands:</p>
        <pre>
          $ export SLOGAN_ROOT=/home/me/slogan
          $ gcc -c -I${SLOGAN_ROOT}/platform/gsc/include -I${SLOGAN_ROOT}/src/include -fpic mylib.c 
          $ gcc -shared -o libmylib.so mylib.o</pre>
        <p>The following sessions shows how to load the library and call the C functions:</p>
        <pre>
          > var mylib = ffi_open ("./libmylib.so");
          > ffi_call_void_0 (mylib, "c_hello");
          hello from C!
          > ffi_call_int_2 (mylib, "c_add_two_ints", 10, 20);
          => 30
          > ffi_close (mylib);</pre>
        <p>Functions for calling into dynamic libraries all start with the prefix <code>ffi_call_***</code>. The next part of the
          name identifies the return type of the C function and the number of arguments it takes. For example, <code>ffi_call_void_0</code>
          calls a C function that take no argument and returns nothing. <code>ffi_call_int_2</code> calls a C function that takes
          two arguments and returns an <code>int</code>. The C functions must accept arguments of type <code>___slogan_obj</code> which
          can represent a Slogan object of any type. There are C macros and functions declared in <code>slogan.h</code> for
          converting a ___slogan_obj to an equivalent C object and vice versa. C functions that takes a single <code>void *</code> can also
          be called from Slogan. The functions <code>ffi_call_with_void_pointer_1</code> and <code>ffi_call_void_pointer_with_void_pointer_1</code>
          are used for this. A C library function to be called using the FFI should not have more that 8 parameters. For passing more
          values from Slogan to C, we can make use of Lists and Arrays. </p>
        <p>For more usage scenarios of FFI, see the samples <code>./example/tutorial/egdlib.c</code> and 
          <code>./example/tutorial/ffi.sn</code>.</p>
      </div>
    </div>
  </body>
</html>
