;; Copyright (c) 2013-2016 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define-structure record-pattern name members)

(define (normalize-list-for-matching lst)
  (if (and (list? lst)
           (scm-not (null? lst)))
      (if (scm-eq? (scm-car lst) 'list)
          (scm-cdr lst)
          (list->record-pattern lst))
      lst))

(define (list->record-pattern lst)
  (if (symbol? (scm-car lst))
      (let ((name (symbol->string (scm-car lst))))
        (if (char=? #\+ (string-ref name 0))
            (let loop ((name (substring name 1 (string-length name)))
                       (lst (scm-cdr lst))
                       (members '()))
              (cond ((null? lst)
                     (make-record-pattern name (scm-reverse members)))
                    (else 
                     (if (keyword? (scm-car lst))
                         (loop name (scm-cddr lst)
                               (scm-cons (scm-cons (keyword->string (scm-car lst)) (scm-cadr lst)) members))
                         (loop name (scm-cdr lst)
                               (scm-cons (scm-car lst) members))))))
            lst))
      lst))

(define (scm-cons? pattern)
  (and (list? pattern)
       (scm-eq? (scm-car pattern) 'scm-cons)))

(define-structure pattern-vars bindings)

(define (match-pattern pattern consequent)
  (let ((bindings (make-pattern-vars '())))
    `(if (unbound? *result*)
         (begin
           ,(if (scm-eq? pattern 'else)
                `(set! *match-found* #t)
                (match-pattern-helper pattern bindings))
           (set! *result* (if *match-found* 
                              ,(if (scm-not (null? (pattern-vars-bindings bindings)))
                                   `(let ,(pattern-vars-bindings bindings)
                                      ,(expand-consequent pattern consequent))
                                   (expand-consequent pattern consequent))
                              '*unbound*))))))

(define (vector-pattern? fname)
  (or (scm-eq? fname 'vector)
      (scm-eq? fname 'u8vector)
      (scm-eq? fname 's8vector)
      (scm-eq? fname 'bit_array)))

(define (vector-test-fn fname)
  (case fname
    ((vector) 'vector?)
    ((u8vector) 'u8vector?)
    ((s8vector) 's8vector?)
    ((bit_array) 'is_bit_array)
    (else (error "Invalid vector constructor." fname))))

(define (vector-len-fn fname)
  (case fname
    ((vector) 'vector-length)
    ((u8vector) 'u8vector-length)
    ((s8vector) 's8vector-length)
    ((bit_array) 'bit_array_length)
    (else (error "Invalid vector constructor." fname))))

(define (vector-to-list-fn fname)
    (case fname
    ((vector) 'vector->list)
    ((u8vector) 'u8vector->list)
    ((s8vector) 's8vector->list)
    ((bit_array) 'bit_array_to_list)
    (else (error "Invalid vector constructor." fname))))

(define (match-pattern-helper pattern bindings)
  (set! pattern (normalize-list-for-matching pattern))
  (cond ((null? pattern)
         `(if (null? *value*)
              (set! *match-found* #t)
              (set! *match-found* #f)))
        ((scm-cons? pattern)
         (set! pattern (scm-cdr pattern))
         `(if (pair? *value*)
              (begin (let ((*value* (first *value*)))
                       ,(match-pattern-helper (scm-car pattern) bindings))
                     (if *match-found*
                         (let ((*value* (rest *value*)))
                           ,(match-pattern-helper (scm-cadr pattern) bindings))))
              (set! *match-found* #f)))
        ((list? pattern)
         (if (scm-eq? (scm-car pattern) 'quote)
             `(if (equal? ,pattern *value*)
                  (set! *match-found* #t)
                  (set! *match-found* #f))
             (if (vector-pattern? (scm-car pattern))
                 (match-vector-pattern (scm-car pattern) (scm-cdr pattern) bindings)
                 (let ((pattern-length (scm-length pattern)))
                   `(if (and (list? *value*)
                             (= ,pattern-length (scm-length *value*)))
                        (begin (let ((*value* (first *value*)))
                                 ,(match-pattern-helper (scm-car pattern) bindings))
                               (if *match-found*
                                   (let ((*value* (rest *value*)))
                                     ,(match-pattern-helper (scm-cdr pattern) bindings))))
                        (set! *match-found* #f))))))
        ((record-pattern? pattern)
         (match-record-pattern pattern bindings))
        ((symbol? pattern)
         (if (scm-not (scm-eq? pattern '_))
             (pattern-vars-bindings-set! bindings (scm-cons (scm-list pattern #f) (pattern-vars-bindings bindings))))
         `(set! *match-found* #t))
        (else `(if (equal? ,pattern *value*)
                   (set! *match-found* #t)
                   (set! *match-found* #f)))))

(define (match-vector-pattern fname pattern bindings)
  (let ((pattern-length (scm-length pattern)))
    `(if (and (,(vector-test-fn fname) *value*)
              (= ,pattern-length (,(vector-len-fn fname) *value*)))
         (begin (let ((*value* (,(vector-to-list-fn fname) *value*)))
                  (set! *conv-value* *value*)
                  (let ((*value* (scm-car *value*)))
                    ,(match-pattern-helper (scm-car pattern) bindings))
                  (if *match-found*
                      (let ((*value* (scm-cdr *value*)))
                        ,(match-pattern-helper (scm-cdr pattern) bindings)))))
         (set! *match-found* #f))))

(define (match-record-pattern pattern bindings)
  (let ((predic (string->symbol (string-append (record-pattern-name pattern) "?"))))
    (let ((prefix `(if (,predic *value*))))
      (let loop ((members (record-pattern-members pattern))
                 (conds '()))
        (cond ((null? members)
               (let ((body '(set! *match-found* #t)))
                 (scm-append
                  (scm-append prefix (scm-list (if (null? conds) 
                                           `(if #t ,body)
                                           `(if (and ,@(scm-reverse conds)) 
                                                ,body 
                                                (set! *match-found* #f)))))
                  (scm-list '(set! *match-found* #f)))))
              ((symbol? (scm-car members))
               (let ((s (scm-car members)))
                 (if (scm-not (scm-eq? s '_))
                     (pattern-vars-bindings-set! bindings (scm-cons (scm-list s #f) (pattern-vars-bindings bindings)))))
               (loop (scm-cdr members) conds))
              ((pair? (scm-car members))
               (let ((accessor (string->symbol (string-append (record-pattern-name pattern)
                                                              "-" (scm-caar members)))))
                 (loop (scm-cdr members) (scm-cons `(equal? ,(scm-cdar members) (,accessor *value*)) conds))))
              (else
               (error "Invalid record pattern: " pattern)))))))

(define (expand-vector-consequent pattern consequent)
  `(let* ((*value* *conv-value*)
          (*rest* (scm-cdr *value*)))
     (set! *value* (scm-car *value*))
     ,(expand-consequent (scm-car pattern) #f)
     (set! *value* *rest*)
     ,(expand-consequent (scm-cdr pattern) consequent)))

(define (expand-consequent pattern consequent)
  (set! pattern (normalize-list-for-matching pattern))
  (cond ((or (null? pattern) (scm-eq? pattern 'else))
         consequent)
        ((scm-cons? pattern)
         (set! pattern (scm-cdr pattern))
         `(let ((*rest* (rest *value*)))
            (set! *value* (first *value*))
            ,(expand-consequent (scm-car pattern) #f)
            (set! *value* *rest*)
            ,(expand-consequent (scm-cadr pattern) consequent)))
        ((list? pattern)
         (if (scm-eq? (scm-car pattern) 'quote)
             consequent
             (if (vector-pattern? (scm-car pattern))
                 (expand-vector-consequent (scm-cdr pattern) consequent)
                 `(let ((*rest* (rest *value*)))
                    (set! *value* (first *value*))
                    ,(expand-consequent (scm-car pattern) #f)
                    (set! *value* *rest*)
                    ,(expand-consequent (scm-cdr pattern) consequent)))))
        ((record-pattern? pattern)
         (expand-rec-consequent pattern consequent))
        ((symbol? pattern)
         (if (scm-eq? pattern '_)
             consequent
             `(begin (set! ,pattern *value*)
                     ,consequent)))
        (else consequent)))

(define (expand-rec-consequent pattern consequent)
  (let loop ((members (record-pattern-members pattern))
             (i 0)
             (bindings '()))
    (cond ((null? members)
           (if (null? bindings)
               consequent
               `(begin ,@(scm-reverse bindings) ,consequent)))
          ((symbol? (scm-car members))
           (if (scm-eq? (scm-car members) '_)
               (loop (scm-cdr members) (+ i 1) bindings)
               (let ((accessor (string->symbol (string-append (record-pattern-name pattern)
                                                              "-" (number->string i)))))
                 (loop (scm-cdr members) (+ i 1) (scm-cons `(set! ,(scm-car members) (,accessor *value*)) bindings)))))
          (else (loop (scm-cdr members) (+ i 1) bindings)))))
