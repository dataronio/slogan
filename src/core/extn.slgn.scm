;; Copyright (c) 2013-2016 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define is_eqv eqv?)
(define is_eq eq?)
(define is_equal equal?)
(define is_boolean boolean?)
(define is_function procedure?)
(define is_symbol symbol?)
(define is_promise ##promise?)

(define (is_true obj) (scm-eq? obj #t))
(define (is_false obj) (scm-eq? obj #f))

(define (is_void obj) (void? obj))
(define (is_object obj) (scm-not (void? obj)))

(define (current_exception_handler) 
  (current-exception-handler))

(define (set_current_exception_handler handler)
  (current-exception-handler handler))

(define is_error error-exception?)
(define error_message error-exception-message)
(define error_args error-exception-parameters)
(define is_noncontinuable_exception noncontinuable-exception?)
(define noncontinuable_exception_reason noncontinuable-exception-reason)

(define (show_exception e #!optional (port (current-output-port)))
  (if (error-exception? e)
      (begin (slgn-display (error-exception-message e) display-string: #t port: port)
             (scm-display #\space port)
             (let loop ((args (error-exception-parameters e)))
               (if (scm-not (null? args))
                   (begin (slgn-display (scm-car args) display-string: #t port: port)
                          (scm-display #\space port)
                          (loop (scm-cdr args))))))
      (display-exception e port)))

(define callcc call/cc)
(define dynamic_wind dynamic-wind)
(define call_with_values call-with-values)

(define (compose #!rest fns)
  (if (null? fns) (set! fns (scm-list identity)))
  (let ((fns (scm-reverse fns)))
    (lambda (#!rest args)
      (let loop ((fns (scm-cdr fns))
                 (result (scm-apply (scm-car fns) args)))
        (if (scm-not (null? fns))
            (loop (scm-cdr fns) ((scm-car fns) result))
            result)))))

(define (mapfn f) (lambda (xs #!rest ys) (scm-apply map f xs ys)))

(define (partial f #!rest args) (lambda (#!rest args2) (scm-apply f (scm-append args args2))))

(define (until p f x) (if (p x) x (until p f (f x))))

(define (complement f) (lambda (#!rest args) (scm-not (scm-apply f args))))

(define (vector-safe-ref v k d)
  (if (and (>= k 0) (< k (vector-length v)))
      (vector-ref v k)
      d))

(define (string-safe-ref v k d)
  (if (and (>= k 0) (< k (string-length v)))
      (string-ref v k)
      d))

(define (u8vector-safe-ref v k d)
  (if (and (>= k 0) (< k (u8vector-length v)))
      (u8vector-ref v k)
      d))

(define (s8vector-safe-ref v k d)
  (if (and (>= k 0) (< k (s8vector-length v)))
      (s8vector-ref v k)
      d))

(define (u16vector-safe-ref v k d)
  (if (and (>= k 0) (< k (u16vector-length v)))
      (u16vector-ref v k)
      d))

(define (s16vector-safe-ref v k d)
  (if (and (>= k 0) (< k (s16vector-length v)))
      (s16vector-ref v k)
      d))

(define (u32vector-safe-ref v k d)
  (if (and (>= k 0) (< k (u32vector-length v)))
      (u32vector-ref v k)
      d))

(define (s32vector-safe-ref v k d)
  (if (and (>= k 0) (< k (s32vector-length v)))
      (s32vector-ref v k)
      d))

(define (u64vector-safe-ref v k d)
  (if (and (>= k 0) (< k (u64vector-length v)))
      (u64vector-ref v k)
      d))

(define (s64vector-safe-ref v k d)
  (if (and (>= k 0) (< k (s64vector-length v)))
      (s64vector-ref v k)
      d))

(define (f32vector-safe-ref v k d)
  (if (and (>= k 0) (< k (f32vector-length v)))
      (f32vector-ref v k)
      d))

(define (f64vector-safe-ref v k d)
  (if (and (>= k 0) (< k (f64vector-length v)))
      (f64vector-ref v k)
      d))

(define (scm-nth-helper xs n) (scm-nth n xs))

(define (scm-sublist ls #!optional (start 0) (end (scm-length ls)))
  (let loop ((ls ls)
             (i 0)
             (result '()))
    (cond ((or (null? ls) (= i end))
           (scm-reverse result))
          ((>= i start)
           (loop (scm-cdr ls)
                 (+ i 1)
                 (scm-cons (scm-car ls) result)))
          (else (loop (scm-cdr ls)
                      (+ i 1)
                      result)))))

(define *array-accessors*
  (scm-list (scm-cons 'vector (scm-cons subvector vector-ref))
            (scm-cons 'list (scm-cons scm-sublist scm-nth-helper))
            (scm-cons 'string (scm-cons substring string-ref))
            (scm-cons 'bitvector (scm-cons subbitarray bitvector-set?))
            (scm-cons 'u8vector (scm-cons subu8vector u8vector-ref))
            (scm-cons 'u16vector (scm-cons subu16vector u16vector-ref))
            (scm-cons 'u32vector (scm-cons subu32vector u32vector-ref))
            (scm-cons 's8vector (scm-cons subs8vector s8vector-ref))
            (scm-cons 's16vector (scm-cons subs16vector s16vector-ref))
            (scm-cons 's32vector (scm-cons subs32vector s32vector-ref))            
            (scm-cons 'u64vector (scm-cons subu64vector u64vector-ref))
            (scm-cons 's64vector (scm-cons subs64vector s64vector-ref))
            (scm-cons 'f32vector (scm-cons subf32vector f32vector-ref))
            (scm-cons 'f64vector (scm-cons subf64vector f64vector-ref))))
            
(define (array-accessor type tab key)
  (let ((a (scm-assq type *array-accessors*)))
    (if a
        (if (pair? key)
            ((scm-cadr a) tab (scm-car key)
             (let ((end (scm-cdr key)))
               (if (scm-eq? *void* end)
                   (generic-array-length tab)
                                 end)))
            ((scm-cddr a) tab key)))))

(define (map-mutate tab key val)
  (cond
   ((vector? tab)
    (vector-set! tab key val))
   ((string? tab)
    (string-set! tab key val))
   ((hashtable? tab)
    (hashtable_set tab key val))   
   ((list? tab)
    (set-at key val tab))
   ((%bitvector? tab)
    (if val
        (bitvector-set! tab key)
        (bitvector-clear! tab key)))
   ((u8vector? tab)
    (u8vector-set! tab key val))
   ((s8vector? tab)
    (s8vector-set! tab key val))
   ((u16vector? tab)
    (u16vector-set! tab key val))
   ((s16vector? tab)
    (s16vector-set! tab key val))
   ((u32vector? tab)
    (u32vector-set! tab key val))
   ((s32vector? tab)
    (s32vector-set! tab key val))
   ((u64vector? tab)
    (u64vector-set! tab key val))
   ((s64vector? tab)
    (s64vector-set! tab key val))
   ((f32vector? tab)
    (f32vector-set! tab key val))
   ((f64vector? tab)
    (f64vector-set! tab key val))
   (else
    (error !not_indexed tab))))

(define (map-safe-access tab key default)
  (cond
   ((vector? tab)
    (vector-safe-ref tab key default))
   ((string? tab)
    (string-safe-ref tab key default))
   ((hashtable? tab)
    (hashtable_at tab key default))   
   ((list? tab)
    (if (< key (scm-length tab))
        (scm-nth key tab)
        default))
   ((%bitvector? tab)
    (if (< key (bitvector-length tab))
        (bitvector-set? tab key)
        default))
   ((u8vector? tab)
    (u8vector-safe-ref tab key default))
   ((s8vector? tab)
    (s8vector-safe-ref tab key default))
   ((u16vector? tab)
    (u16vector-safe-ref tab key default))
   ((s16vector? tab)
    (s16vector-safe-ref tab key default))
   ((u32vector? tab)
    (u32vector-safe-ref tab key default))
   ((s32vector? tab)
    (s32vector-safe-ref tab key default))
   ((u64vector? tab)
    (u64vector-safe-ref tab key default))
   ((s64vector? tab)
    (s64vector-safe-ref tab key default))
   ((f32vector? tab)
    (f32vector-safe-ref tab key default))
   ((f64vector? tab)
    (f64vector-safe-ref tab key default))   
   (else
    (error !not_indexed tab))))

(define (ref tab key #!key (value *void*) (default #f))
  (if (scm-not (scm-eq? value *void*))
    (map-mutate tab key value)
    (map-safe-access tab key default)))

(define (map-access tab key)
  (cond
   ((vector? tab)
    (array-accessor 'vector tab key))
   ((string? tab)
    (array-accessor 'string tab key))
   ((hashtable? tab)
    (hashtable_at tab key))   
   ((list? tab)
    (array-accessor 'list tab key))
   ((%bitvector? tab)
    (array-accessor 'bitvector tab key))
   ((u8vector? tab)
    (array-accessor 'u8vector tab key))
   ((s8vector? tab)
    (array-accessor 's8vector tab key))
   ((u16vector? tab)
    (array-accessor 'u16vector tab key))
   ((s16vector? tab)
    (array-accessor 's16vector tab key))
   ((u32vector? tab)
    (array-accessor 'u32vector tab key))
   ((s32vector? tab)
    (array-accessor 's32vector tab key))
   ((u64vector? tab)
    (array-accessor 'u64vector tab key))
   ((s64vector? tab)
    (array-accessor 's64vector tab key))
   ((f32vector? tab)
    (array-accessor 'f32vector tab key))
   ((f64vector? tab)
    (array-accessor 'f64vector tab key))
   (else
    (error !not_indexed tab))))

(define (*-@-* tab key #!optional (value *void*))
  (if (scm-not (scm-eq? value *void*))
      (map-mutate tab key value)
      (map-access tab key)))

(define (do_times n fn #!key (from 0) init)
  (call/cc
    (lambda (break)
      (if (not (procedure? fn))
        (error "expected procedure instead of " fn))
      (let ((cmpr (if (> n from) < >))
            (trans (if (> n from) + -)))
        (let loop ((i from) (res init))
          (if (cmpr i n)
            (loop (trans i 1) (fn i res break))
            res))))))

(define (not-equal? a b)
  (scm-not (equal? a b)))

(define == equal?)
(define <> not-equal?)
