;; Copyright (c) 2013-2016 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define-structure s-yield fn k)

(define *enforce-comma* #t)

(define (scm-slogan tokenizer)
  (let ((expr (expression/statement tokenizer)))
    (if (> (tokenizer 'yield-count) 0)
        (begin (reset-yield-count! tokenizer 0)
               (error "yield can be called only from a function."))
        expr)))

(define (expression/statement tokenizer #!optional (top #t))
  (if (eof-object? (tokenizer 'peek))
    (tokenizer 'next)
    (let ((v (statement tokenizer)))
      (if (scm-not v) (set! v (scm-expression tokenizer)))
      (assert-semicolon tokenizer)
      v)))

(define (statement tokenizer)
  (sanitize-expression
   tokenizer
   (if (scm-eq? (tokenizer 'peek) '*semicolon*) *void*
       (declare-stmt tokenizer))))

(define (highlighted-line colno)
  (if (< colno 0)
      (set! colno 1))
  (with-output-to-string
    '()
    (lambda ()
      (let loop ((n 0))
	(if (= n colno) (scm-display #\^)
	    (begin (scm-display #\space)
		   (loop (+ n 1))))))))

(define (highlighted-error-line tokenizer #!optional token)
  (let ((curr-tok-len (current-token-length tokenizer))
        (tlen (if token
                  (string-length (if (symbol? token) (symbol->string token) token))
                  0)))
    (let loop ((line-no (tokenizer 'line)) 
               (n 1)
               (program-text (tokenizer 'program-text)))
      (if (scm-not (null? program-text))
          (if (= n line-no)
              (scm-cons (scm-car program-text) (highlighted-line (tokenizer 'column)))
              (loop line-no (+ n 1) (scm-cdr program-text)))
          #f))))

(define (parser-error tokenizer msg #!optional token)
  (error (with-output-to-string 
           '()
           (lambda ()
             (if tokenizer
                 (begin
                   (display-all "at [line: " (tokenizer 'line)
                                ", column: " (tokenizer 'column)
                                "] " msg)
                   (scm-newline)))
             (let ((hl (highlighted-error-line tokenizer token)))
               (if hl (begin (scm-display (scm-car hl))
                             (scm-newline)
                             (scm-display (scm-cdr hl))
                             (scm-newline))))))))

(define (assert-semicolon tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*semicolon*)
            (scm-eq? token '*close-brace*)
            (eof-object? token))
        (if (scm-eq? token '*semicolon*)
            (tokenizer 'next))
        #t)))

(define (declare-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'declare)
      (begin (tokenizer 'next)
             (let ((name (tokenizer 'next)))
               (case name
                 ((generic) (declare-generic-stmt tokenizer))
                 ((ffi) (declare-ffi-stmt tokenizer))
                 (else
                  (parser-error tokenizer "Invalid declare type.")))))
      (func-def-stmt tokenizer)))

(define (normalize-c-struct-members memtypes)
  (scm-map (lambda (m) (scm-cons (scm-cadr m) (scm-caddr m))) memtypes))

(define (c-struct-stmt tokenizer)
  (let ((struct-name (tokenizer 'next)))
    (if (scm-not (symbol? struct-name))
        (parser-error tokenizer "Struct name must be a symbol." struct-name)
        (let ((memtypes (scm-expression tokenizer)))
          (if (scm-not (scm-eq? (scm-car memtypes) 'scm-list))
              (parser-error tokenizer "Struct member types must be a list." memtypes)
              `(def-c-struct ',struct-name ',(normalize-c-struct-members (scm-cdr memtypes))))))))

(define (c-fn-stmt tokenizer rettype libname)
  (let ((fn-name (tokenizer 'next)))
    (if (scm-not (symbol? fn-name))
        (parser-error tokenizer "Function name must be a symbol." fn-name)
        (let ((paramtypes (scm-expression tokenizer)))
          (if (scm-not (pair? paramtypes))
              (parser-error tokenizer "Expected parameter list."))
          (if (scm-not (scm-eq? (scm-car paramtypes) 'scm-list))
              (parser-error tokenizer "Parameter types must be a list." paramtypes)
              (let ((name fn-name))
                (if (scm-eq? (tokenizer 'peek) 'as)
                    (begin (tokenizer 'next)
                           (set! name (tokenizer 'next))
                           (if (scm-not (symbol? name))
                               (parser-error tokenizer "Function local name must be a symbol." name))))
                (def-c-fn libname fn-name name (scm-cdr paramtypes) rettype)))))))
                
(define (cdef-stmt tokenizer libname)
  (let ((token (tokenizer 'next)))
    (if (scm-eq? token 'struct)
        (c-struct-stmt tokenizer)
        (c-fn-stmt tokenizer token libname))))

(define (def-ffi tokenizer libname expr)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-bracket*))
      (parser-error tokenizer "FFI definitions must be within a list.")
      (let loop ((defs '()))
        (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
            (begin (tokenizer 'next)
                   (scm-append expr (scm-reverse defs)))
            (let ((cdef (cdef-stmt tokenizer libname)))
              (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'def-ffi)
              (loop (scm-cons cdef defs)))))))

(define *ffi-lib-count* 0)
(define (genffisym)
  (let ((s (string-append "*ffi-" (number->string *ffi-lib-count*) "-*")))
    (set! *ffi-lib-count* (+ *ffi-lib-count* 1))
    (string->symbol s)))

(define (declare-ffi-stmt tokenizer)
  (let ((libname (tokenizer 'next)))
    (if (scm-not (or (string? libname)
                 (symbol? libname)))
        (parser-error tokenizer "Invalid library name - " libname)
        (let ((lname (genffisym)))
          (def-ffi tokenizer lname `(begin (define ,lname (if (string? ,libname)
                                                              (ffi_open ,libname)
                                                              ,libname))))))))
(define (declare-generic-stmt tokenizer)
  (let ((name (tokenizer 'next)))
    (if (valid-identifier? name)
        (define-generic-method name tokenizer)
        (parser-error tokenizer "Expected a valid generic name."))))

(define (define-generic-method name tokenizer)
  (check-if-reserved-name name tokenizer)
  (let ((params '(*self* #!rest *args*)))
    `(define ,name
       (let ((*old-name* ,name))              
         (lambda ,params
           (if (procedure? *self*)
               (with-exception-catcher
                (lambda (e)
                  (if (or (wrong-number-of-arguments-exception? e)
                          (nonprocedure-operator-exception? e))
                      (apply *old-name* *self* *args*)
                      (raise e)))
                (lambda ()
                  (apply (*self* ',name) *args*)))
               (apply *old-name* *self* *args*)))))))                           
                
(define (func-contract-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? 'where token)
           (tokenizer 'next)
           (let ((precond (scm-expression tokenizer)))
             (if (scm-eq? (tokenizer 'peek) '*inserter*)
                 (begin
                   (tokenizer 'next)
                   (scm-cons precond (scm-expression tokenizer)))
                 (scm-cons precond #f))))
          (else #f))))

(define *func-contracts-disabled* #f)

(define (disable_function_contracts)
  (set! *func-contracts-disabled* #t))

(define (enable_function_contracts)
  (set! *func-contracts-disabled* #f))

(define (prepare-func-body-for-if body)
  (if (and (pair? body) (scm-eq? 'begin (scm-car body)))
      `(let () ,@(scm-cdr body))
      body))

(define (merge-func-contract name body-expr contract-expr)
  (if (not contract-expr)
      body-expr
      (let ((body-expr (prepare-func-body-for-if body-expr))
            (pre-cond (scm-car contract-expr))
            (post-cond (scm-cdr contract-expr)))
        (if post-cond
            `(if (or *func-contracts-disabled* ,pre-cond)
                 (let ((% ,body-expr))
                   (if (or *func-contracts-disabled* ,post-cond)
                       %
                       (error 'postcondition_failed ',name ',post-cond)))
                 (error 'precondition_failed ',name ',pre-cond))
            `(if (or *func-contracts-disabled* ,pre-cond)
                 ,body-expr
                 (error 'precondition_failed ',name ',pre-cond))))))

(define (func-def-stmt-with-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (let ((has-name? (not (scm-eq? name '*open-paren*))))
      (if has-name?
          (begin
            (check-if-reserved-name name tokenizer)
            (tokenizer 'next)))
      (let* ((params (scm-car (func-params-expr tokenizer #t)))
             (contract-expr (func-contract-expr tokenizer))
             (body-expr (merge-func-contract name (func-body-expr tokenizer params) contract-expr))
             (fexpr (merge-lambda tokenizer params body-expr)))
        (if has-name?
            (scm-list 'define name fexpr)
            fexpr)))))

(define (func-def-stmt tokenizer)
  (cond ((scm-eq? 'function (tokenizer 'peek))
         (tokenizer 'next)
	 (func-def-stmt-with-name tokenizer))
	((scm-eq? '*fn* (tokenizer 'peek))
	 (func-def-expr tokenizer))
        (else (break-stmt tokenizer))))

(define (break-stmt tokenizer)
  (cond ((eq? 'break (tokenizer 'peek))
         (tokenizer 'next)
         (cond ((eq? '*open-paren* (tokenizer 'peek))
                (tokenizer 'next)
                (let ((expr (if (eq? '*close-paren* (tokenizer 'peek))
                                #f
                                (scm-expression tokenizer))))
                  (if (not (eq? '*close-paren* (tokenizer 'next)))
                      (parser-error tokenizer "Expected closing parenthesis."))
                  `(break ,expr)))
               (else '(break #f))))
        (else (continue-stmt tokenizer))))

(define (continue-stmt tokenizer)
  (cond ((eq? 'continue (tokenizer 'peek))
         (tokenizer 'next)
         '(continue))
        (else (record-def-stmt tokenizer))))

(define (mk-predic-name psym)
  (if (scm-eq? psym '_)
      'is_object
      (string->symbol 
       (string-append 
        "is_" 
        (symbol->string psym)))))

(define (params->args params)
  (let loop ((params params)
             (args '()))
    (if (null? params)
        (scm-reverse args)
        (cond ((pair? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-caar params) args)))
              ((symbol? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-car params) args)))
              (else (loop (scm-cdr params) args))))))

(define (types-has-rest? types)
  (member '@rest types))

(define (assignment-stmt tokenizer)
  (if (symbol? (tokenizer 'peek))
    (let ((sym (tokenizer 'next)))
      (if (scm-eq? sym 'let)
        (let ((n (tokenizer 'peek)))
          (if (symbol? n)
            (if (scm-eq? '*open-paren* n)
              (begin
                (tokenizer 'put sym)
                (let-expr tokenizer))
              (define-stmt tokenizer))))
        (cond
         ((scm-not (valid-identifier? sym))
          (tokenizer 'put sym)
          #f)
         ((scm-eq? (tokenizer 'peek) '*assignment*)
          (var-def-set sym tokenizer #f))
         (else
          (tokenizer 'put sym) 
          #f))))
    #f))

(define (vars-defs-set syms exprs def)
  (if (not (= (scm-length syms) (scm-length exprs)))
      (error "Not enough values or variables." syms exprs))
  (let loop ((syms syms) (exprs exprs) (defexprs '()))
    (if (not (null? syms))
        (let ((sym (scm-car syms)))
          (let ((defexpr
                  (if (rvar? sym)
                      (let ((sym (normalize-rvar sym)))
                        (if def
                            `(begin
                               (define ,sym (scm-rvar))
                               (scm-rbind ,sym ,(scm-car exprs)))
                            (scm-list 'scm-rbind sym (scm-car exprs))))
                      (scm-list (if def 'define 'set!) sym (scm-car exprs)))))
            (loop (scm-cdr syms) (scm-cdr exprs) (scm-cons defexpr defexprs))))
        (scm-append '(begin) (scm-reverse defexprs)))))

(define (def-vars-list tokenizer)
  (let loop ((token (tokenizer 'peek))
             (names '()))
    (cond ((scm-eq? token '*assignment*)
           (scm-reverse names))
          ((scm-eq? token '*comma*)
           (tokenizer 'next)
           (loop (tokenizer 'peek) names))
          ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (tokenizer 'next)
           (loop (tokenizer 'peek) (scm-cons token names)))
          (else
           (parser-error tokenizer "Invalid variable name.")))))

(define (def-exprs-list tokenizer)
  (let loop ((e (scm-expression tokenizer))
             (exprs '()))
    (let ((token (tokenizer 'peek)))
      (cond ((scm-eq? token '*comma*)
             (tokenizer 'next)
             (loop (scm-expression tokenizer)
                   (scm-cons e exprs)))
            (else (scm-reverse (scm-cons e exprs)))))))

(define (define-stmt tokenizer)
  (let ((token (tokenizer 'next)))
    (cond
      ((symbol? token)
       (check-if-reserved-name token tokenizer)
       (cond
        ((scm-eq? '*assignment* (tokenizer 'peek))
         (var-def-set token tokenizer #t))
        ((scm-eq? '*comma* (tokenizer 'peek))
         (tokenizer 'next)
         (let ((vars (scm-append (scm-list token) (def-vars-list tokenizer))))
           (if (scm-eq? '*assignment* (tokenizer 'next))
               (let ((exprs (def-exprs-list tokenizer)))
                 (vars-defs-set vars exprs #t))
               (parser-error tokenizer "Expected assignment."))))
        ((scm-eq? '*open-paren* (tokenizer 'peek))
         (tokenizer 'put token)
         (named-let-expr 'let tokenizer))
        (else
         (parser-error tokenizer "Invalid let expression."))))
      (else
       (parser-error tokenizer "Not a valid variable name.")))))

(define (normalize-rvar sym)
  (let ((s (symbol->string sym)))
    (string->symbol (substring s 1 (string-length s)))))

(define (rvar? sym)
  (if (symbol? sym) 
      (let ((s (symbol->string sym)))
        (and (> (string-length s) 0)
             (char=? #\? (string-ref s 0))))
      #f))

(define (var-def-set sym tokenizer def)
  (if (scm-eq? (tokenizer 'peek) '*assignment*)
      (begin (tokenizer 'next)
             (if (rvar? sym)
                 (let ((sym (normalize-rvar sym)))
                   (if def
                       `(begin
                          (define ,sym (scm-rvar))
                          (scm-rbind ,sym ,(scm-expression tokenizer)))
                       (scm-list 'scm-rbind sym (scm-expression tokenizer))))
                 (scm-list (if def 'define 'set!) sym (scm-expression tokenizer))))
      (parser-error tokenizer "Expected assignment.")))

(define (invoke-access-expression tokenizer expr)
  (let loop ((expr expr))
    (let ((tok (tokenizer 'peek)))
      (cond ((scm-eq? tok '*open-paren*)
             (loop (func-call-expr expr tokenizer)))
            ((scm-eq? tok '*colon*)
             (pair-literal tokenizer expr))
            ((scm-eq? tok '*open-bracket*)
             (array-access-expr tokenizer expr))
            ((scm-eq? tok '*task-send*)
             (task-send-expr expr tokenizer))
            (else expr)))))

(define (scm-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) '*semicolon*)
      *void*
      (sanitize-expression
       tokenizer
       (invoke-access-expression tokenizer (logical-and-expr tokenizer)))))

(define (array-access-expr tokenizer expr)
  (invoke-access-expression
   tokenizer
   (let loop ((expr expr))
     (cond ((scm-eq? (tokenizer 'peek) '*open-bracket*)
            (tokenizer 'next)
            (loop
             (cond ((scm-eq? '*colon* (tokenizer 'peek))
                    (tokenizer 'next)
                    (cond ((scm-eq? (tokenizer 'peek) '*close-bracket*)
                           (tokenizer 'next)
                           `(let ((*expr* ,expr))
                              (*-@-* *expr* (scm-cons 0 (generic-array-length *expr*)))))
                          (else
                           (let ((e `(*-@-* ,expr (scm-cons 0 ,(scm-expression tokenizer)))))
                             (if (scm-eq? (tokenizer 'next) '*close-bracket*)
                                 e
                                 (parser-error tokenizer "Expected closing bracket here."))))))
                   (else
                    (let ((idx-expr (scm-expression tokenizer)))
                      (if (scm-eq? (tokenizer 'next) '*close-bracket*)
                          (cond ((scm-eq? (tokenizer 'peek) '*assignment*)
                                 (tokenizer 'next)
                                 `(*-@-* ,expr ,idx-expr ,(scm-expression tokenizer)))
                                (else
                                 `(*-@-* ,expr ,idx-expr)))
                          (parser-error tokenizer "Missing closing bracket.")))))))
           (else expr)))))

(define (pair-literal tokenizer expr)
  (tokenizer 'next)
  (let ((tail-expr (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
                       *void*
                       (scm-expression tokenizer))))
    `(scm-cons ,expr ,tail-expr)))

(define (then-expr tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
      (parser-error tokenizer "Expected closing parenthesis."))
  (func-body-expr tokenizer #f #t))

(define (if-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'if)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (scm-expression tokenizer)
                                     (then-expr tokenizer)))))
           (if (scm-eq? (tokenizer 'peek) 'else)
               (begin (tokenizer 'next)
                      (if (scm-eq? (tokenizer 'peek) 'if)
                          (scm-append expr (scm-list (if-expr tokenizer)))
                          (scm-append expr (scm-list (func-body-expr tokenizer #f #t)))))
               (scm-append expr '(#f)))))
        (else (when-expr tokenizer))))

(define (when-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'when)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (scm-expression tokenizer)
                                     (then-expr tokenizer)))))
           (scm-append expr '(#f))))
        (else (case-expr tokenizer))))

(define (case-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'case)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before case clause."))
         (let ((value (scm-expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after case clause."))
           (let loop ((token (tokenizer 'peek)) (last-expr #f) (body '()))
             (if last-expr (scm-append `(case ,value) (scm-reverse body))
                 (let ((expr (normalize-sym (case-pattern-expression tokenizer))))
                   (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
                       (parser-error tokenizer "Missing -> after case expression.")
                       (tokenizer 'next))
                   (let ((result (func-body-expr tokenizer #f #t))
                         (next (tokenizer 'peek)) (le #f))
                     (if (scm-eq? next '*pipe*)
                         (tokenizer 'next)
                         (set! le #t))
                     (loop (tokenizer 'peek) le
                           (if (and le (scm-not (scm-eq? expr 'else)))
                               (scm-cons '(else #f) (scm-cons (scm-list (if (list? expr) expr (scm-cons expr '())) result) body))
                               (scm-cons (scm-list (if (or (list? expr) (scm-eq? expr 'else)) expr (scm-cons expr '()))
                                                   result) body)))))))))
        (else (match-expr tokenizer))))

(define (case-pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (scm-expression tokenizer)))

(define (pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (begin
	(tokenizer 'pattern-mode-on)
	(let ((expr (scm-expression tokenizer)))
	  (tokenizer 'pattern-mode-off)
	  expr))))

(define (unbound? r) (scm-eq? r '*unbound*))

(define (match-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'match)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before match clause."))
         (let ((value (scm-expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after match clause."))
           (match-body-expr value tokenizer)))
        (else (try-catch-expr tokenizer))))

(define (match-patterns&guards tokenizer)
  (let loop ((patterns '()) (guards '()))
    (let ((pattern (pattern-expression tokenizer))
          (guard #t))
      (if (scm-eq? (tokenizer 'peek) 'where)
          (begin (tokenizer 'next)
                 (set! guard (scm-expression tokenizer))))
      (let ((token (tokenizer 'peek)))
        (cond ((scm-eq? token '*pipe*)
               (tokenizer 'next)
               (loop (scm-cons pattern patterns)
                     (scm-cons guard guards)))
              ((scm-eq? token '*inserter*)
               (tokenizer 'next)
               (scm-cons (scm-reverse (scm-cons pattern patterns))
                         (scm-reverse (scm-cons guard guards))))
              (else
               (parser-error tokenizer "Missing -> after pattern.")))))))

(define (mk-match-body patterns&guards consequent prev-pattern body)
  (let loop ((patterns (scm-car patterns&guards))
             (guards (scm-cdr patterns&guards))
             (body body))
    (if (null? patterns)
        body
        (let ((pattern (scm-car patterns))
              (guard (scm-car guards)))
          (let ((c (if (scm-eq? guard #t)
                       consequent
                       `(if ,guard
                            ,consequent
                            (begin (set! *match-found* #f)
                                   (set! *value* *orig-value*)
                                   '*unbound*)))))
            (loop (scm-cdr patterns) (scm-cdr guards)
                  (scm-cons (match-pattern (if (scm-eq? pattern '@) prev-pattern pattern) c) body)))))))

(define (last-pattern patterns&guards)
  (scm-car (scm-reverse (scm-car patterns&guards))))

(define (match-body-expr value tokenizer)
  (let loop ((token (tokenizer 'peek)) (prev-pattern #f) (last-expr #f) (body '()))
    (if last-expr `(let ((*match-expr* ,value))
                     (let ((*value* *match-expr*)
                           (*orig-value* *match-expr*)
                           (*match-found* #f)
                           (*conv-value* #f)
                           (*result* '*unbound*))
                       ,@(scm-reverse body)
                       (if (unbound? *result*)
                           (error 'no_match_found)
                           *result*)))
        (let* ((patterns&guards (match-patterns&guards tokenizer))
               (pattern (last-pattern patterns&guards))
               (consequent (func-body-expr tokenizer #f #t)))
          (let ((next (tokenizer 'peek))
                (le (scm-eq? pattern 'else)))
            (if (scm-eq? next '*pipe*)
                (if (scm-not le) (tokenizer 'next))
                (if (scm-not le) (set! le #t)))
            (loop (tokenizer 'peek)
                  (if (scm-eq? pattern '@) prev-pattern pattern)
                  le (mk-match-body patterns&guards consequent prev-pattern body)))))))

(define (try-catch-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((or (scm-eq? token 'try)
               (scm-eq? token 'trycc))
           (tokenizer 'next)
           (let ((try-expr (stmt-or-expr tokenizer)))
             (case (tokenizer 'peek)
               ((catch)
                (let* ((args (catch-args tokenizer))
                       (ex (scm-car args)))
                  (make-try-catch-expr token try-expr args
                                       `(let ((,ex (parse-exception ,ex))) ,(func-body-expr tokenizer args))
                                       (finally-expr tokenizer))))
               ((finally)
                (make-try-catch-expr token try-expr '(*e*) '(raise *e*)
                                     (finally-expr tokenizer)))
               (else (parser-error tokenizer "Expected catch or finally clauses.")))))
          (else (yield-expr tokenizer)))))

(define (catch-args tokenizer)
  (tokenizer 'next)
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing opening parenthesis."))
  (tokenizer 'next)
  (let ((result (tokenizer 'next)))
    (if (scm-not (and (symbol? result)
		  (check-if-reserved-name result tokenizer)))
        (parser-error tokenizer "Missing exception identifier."))
    (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
        (parser-error tokenizer "Missing closing parenthesis."))
    (tokenizer 'next)
    (scm-list result)))

(define (finally-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'finally)
         (tokenizer 'next)
         (stmt-or-expr tokenizer))
        (else *void*)))
      
(define (get-exception-handler-fnname try-token)
  (if (scm-eq? try-token 'try) 'with-exception-catcher 'with-exception-handler))

(define (make-try-catch-expr try-token try-expr catch-args catch-expr finally-expr)
  (let ((try-expr (scm-list (get-exception-handler-fnname try-token)
			(scm-list 'lambda catch-args catch-expr)
			(scm-list 'lambda (scm-list) try-expr))))
    (if (void? finally-expr) try-expr
	(scm-list 'let (scm-list (scm-list '*finally* (scm-list 'lambda (scm-list) finally-expr)))
            (scm-list (get-exception-handler-fnname try-token)
                  (scm-list 'lambda '(*e*) '(begin (*finally*) (raise *e*)))
                  (scm-list 'lambda '() try-expr))
	    '(*finally*)))))

(define (yield-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'yield)
           (tokenizer 'next)
           (tokenizer 'yield-count-up)
           (let ((expr (scm-expression tokenizer)))
             `(call/cc (lambda(*yield*)
                         (let ((*r* (s-yield-k *yield-obj*)))
                           (s-yield-fn-set! *yield-obj* *yield*)
                           (*r* (scm-cons ,expr *yield-obj*)))))))
           (else (assert-stmt tokenizer)))))

(define *assertions-enabled* #t)
(define (enable_asserts) (set! *assertions-enabled* #t))
(define (disable_asserts) (set! *assertions-enabled* #f))

(define (assert-stmt tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'assert)
           (tokenizer 'next)
           (let ((line (tokenizer 'line))
                 (expr (scm-expression tokenizer)))
             (let ((msg (if (scm-eq? '*comma* (tokenizer 'peek))
                            (begin (tokenizer 'next)
                                   (scm-expression tokenizer))
                            #f)))
               `(if *assertions-enabled*
                    (if (not ,expr)
                        (if ,msg
                            (error ,msg)
                            (error (quote assertion_failed)
                                   ,(string-append "line: " (number->string line)))))
                    #t))))
          (else #f))))

(define (normalize-sym s)
  (if (and (list? s) (scm-eq? (scm-car s) 'quote))
      (scm-cadr s)
      s))

(define (block-expr tokenizer #!optional (use-let #f))
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-brace*))
      (parser-error tokenizer "Missing block start.")
      (begin (tokenizer 'next)
             (let loop ((expr (if use-let (scm-cons 'let (scm-cons '() '())) (scm-cons 'begin '())))
                        (count 0))
               (let ((token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-brace*)
                        (tokenizer 'next)
                        (if (zero? count) (scm-append expr (scm-list *void*)) expr))
                       ((eof-object? token)
                        (parser-error tokenizer "Unexpected end of input. Missing closing brace?"))
                       (else
                        (loop (scm-append expr (scm-list (expression/statement tokenizer #f)))
                              (+ 1 count)))))))))

(define (cmpr-expr tokenizer)
  (let loop ((fst-expr #f)
             (expr (addsub-expr tokenizer)))
    (if (cmpr-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*equals*) (loop #t (swap-operands (scm-append (eq-expr tokenizer) (scm-list expr)))))
          ((*not-equals*) (loop #t (swap-operands (scm-append (not-eq-expr tokenizer) (scm-list expr)))))	
          ((*less-than*) (loop #t (swap-operands (scm-append (lt-expr tokenizer) (scm-list expr)))))
          ((*greater-than*) (loop #t (swap-operands (scm-append (gt-expr tokenizer) (scm-list expr)))))
          ((*less-than-equals*) (loop #t (swap-operands (scm-append (lteq-expr tokenizer) (scm-list expr)))))
          ((*greater-than-equals*) (loop #t (swap-operands (scm-append (gteq-expr tokenizer) (scm-list expr))))))
        expr)))

(define (logical-and-expr tokenizer)
  (let loop ((expr (logical-or-expr tokenizer)))
    (if (scm-eq? '*and* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (and-expr tokenizer) (scm-list expr)))))
        expr)))

(define (logical-or-expr tokenizer)
  (let loop ((expr (cmpr-expr tokenizer)))
    (if (scm-eq? '*or* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (or-expr tokenizer) (scm-list expr)))))
        expr)))
  
(define (addsub-expr tokenizer)
  (let loop ((expr (term-expr tokenizer)))
    (if (add-sub-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*plus*) (loop (swap-operands (scm-append (add-expr tokenizer) (scm-list expr)))))
          ((*minus*) (loop (swap-operands (scm-append (sub-expr tokenizer) (scm-list expr))))))
        expr)))

(define (factor-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (scm-eq? token '*open-paren*)
        (begin (tokenizer 'next)
               (let ((expr (scm-expression tokenizer)))
                 (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
                     (begin (parser-error tokenizer "Missing closing parenthesis.")
                            #f)
                     (begin (tokenizer 'next)
                            (member-access/funcall-expr expr tokenizer)))))
        (let ((expr (if-expr tokenizer)))
          (if expr expr
              (let-expr tokenizer))))))

(define (handle-rvar-access sym)
  (if (rvar? sym)
      (scm-list 'scm-rget (normalize-rvar sym))
      sym))

(define (token->neg-number token)
  (if (number? token)
      (- token)
      (scm-list '- token)))

(define (task-send-expr task-expr tokenizer)
  (tokenizer 'next)
  `(let ((*msg* ,(scm-expression tokenizer)))
     (thread-send ,task-expr *msg*)
     *msg*))

(define (literal-expr tokenizer)
  (let ((expr (func-def-expr tokenizer)))
    (if expr
        (member-access/funcall-expr expr tokenizer)
        (let ((token (tokenizer 'peek)))
          (cond ((or (number? token)
                     (string? token)
		     (char? token))
                 (slgn-repr->scm-repr (tokenizer 'next)))
                ((add-sub-opr? token)
                 (tokenizer 'next)
                 (let ((sub (scm-eq? token '*minus*))
                       (next (tokenizer 'peek)))
                   (if sub
                       (if (or (number? next) 
                               (valid-identifier? next))
                           (begin (tokenizer 'next)
                                  (token->neg-number next))
                           (scm-list '- (scm-expression tokenizer)))
                       (scm-expression tokenizer))))                       
                ((valid-identifier? token) (handle-symbol token tokenizer))
                ((scm-eq? token '*open-bracket*)
                 (list-literal tokenizer))
                ((scm-eq? token '*open-brace*)
                 (block-expr tokenizer #t))
                ((scm-eq? token '*hash*)
                 (array-or-table-literal tokenizer))
                ((scm-eq? token '*task*)
                 (tokenizer 'next)
                 `(thread-start! (make-thread (lambda () ,(scm-expression tokenizer)))))                 
                ((scm-eq? token '*task-recv*)
                 (tokenizer 'next)
                 `(thread-receive))
                ((scm-eq? token '*delay*)
                 (tokenizer 'next)
                 (scm-list 'delay (func-body-expr tokenizer #f)))
                ((scm-eq? token '*quote*)
                 (tokenizer 'next)
                 (let ((sym (tokenizer 'peek)))
                   (cond ((scm-not (symbol? sym))
                          (parser-error tokenizer "Expected symbol."))
                         ((slgn-is_special_token sym)
                          (parser-error tokenizer "Invalid symbol literal."))
                         (else
                          (tokenizer 'next)
                          (scm-list 'quote sym)))))
		((symbol? token) (handle-symbol token tokenizer))
                (else (parser-error tokenizer "Invalid literal expression.")))))))

(define (handle-symbol token tokenizer)
  (cond ((scm-eq? token '?)                        
	 (tokenizer 'next)
	 (scm-list 'scm-rvar))
        ((scm-eq? token '*semicolon*)
         (parser-error tokenizer "Semicolon not expected here."))
	(else (let ((var (tokenizer 'next)))
                (if (slgn-is_special_token var)
                    (parser-error tokenizer "Misplaced token or operator."))
		(if (scm-eq? (tokenizer 'peek) '*period*)
		    (begin (tokenizer 'next)
			   (closure-member-access var tokenizer))
		    (handle-rvar-access (slgn-repr->scm-repr var)))))))

(define (member-access/funcall-expr expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*period*)
         (begin (tokenizer 'next)
                (closure-member-access expr tokenizer)))
        ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (func-call-expr expr tokenizer))
        (else expr)))

(define (list-literal tokenizer)
  (tokenizer 'next)
  (let loop ((result (scm-list 'scm-list)))
    (let ((token (tokenizer 'peek)))
      (if (scm-eq? token '*close-bracket*)
          (begin (tokenizer 'next)
                 (scm-reverse result))
          (let ((expr (scm-expression tokenizer)))
            (if (scm-eq? (tokenizer 'peek) '*pipe*)
                (begin (tokenizer 'next)
                       (list-comprehension-expr tokenizer expr))
                (begin (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'list-literal)
                       (loop (scm-cons expr result)))))))))

(define (list-comprehension-expr tokenizer result-expr)
  (let ((vars-lists-filters 
         (let loop ((vars '())
                    (lists '())
                    (filters '()))
           (if (eq? (tokenizer 'peek) '*close-bracket*)
               (scm-list (scm-reverse vars) (scm-reverse lists)
                         (scm-reverse filters))
               (let ((var (scm-expression tokenizer))
                     (extractor (tokenizer 'next)))
                 (if (scm-eq? '*extractor* extractor)
                     (let ((lists (scm-cons (scm-expression tokenizer) lists))
                           (vars (scm-cons var vars))
                           (filters (scm-cons (if (scm-eq? (tokenizer 'peek) 'where)
                                                  (begin (tokenizer 'next)
                                                         (scm-expression tokenizer))
                                                  #t)
                                              filters)))
                       (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'list-comprehension-expr)
                       (loop vars lists filters))))))))
    (let ((expr (list-comprehension (scm-cadr vars-lists-filters) 
                                    (scm-car vars-lists-filters) 
                                    (scm-caddr vars-lists-filters) 
                                    result-expr)))
      (let ((t (tokenizer 'next)))
        (if (scm-not (scm-eq? t '*close-bracket*))
            (parser-error tokenizer "Expected closing bracket.")))
      expr)))
                    
(define (array-prefix? prefix tokenizer) 
  (or (scm-eq? prefix 'u8)
      (scm-eq? prefix 's8)
      (scm-eq? prefix 'b)
      (scm-eq? prefix 'v)
      (scm-eq? prefix 'u16)
      (scm-eq? prefix 's16)
      (scm-eq? prefix 'u32)
      (scm-eq? prefix 's32)
      (scm-eq? prefix 'u64)
      (scm-eq? prefix 's64)
      (scm-eq? prefix 'f32)
      (scm-eq? prefix 'f64)))

(define (array-prefix->constructor prefix)
  (case prefix
    ((v) 'scm-vector)
    ((u8) 'scm-u8vector)
    ((s8) 'scm-s8vector)
    ((u16) 'scm-u16vector)
    ((s16) 'scm-s16vector)
    ((u32) 'scm-u32vector)
    ((s32) 'scm-s32vector)
    ((u64) 'scm-u64vector)
    ((s64) 'scm-s64vector)
    ((f32) 'scm-f32vector)
    ((f64) 'scm-f64vector)
    (else 'bit_array)))

(define (array-literal tokenizer)
  (let ((prefix (tokenizer 'peek)))
    (if (array-prefix? prefix tokenizer)
        (tokenizer 'next)
        (set! prefix 'v))
    (if (scm-eq? (tokenizer 'peek) '*open-bracket*)
        (begin (tokenizer 'next)
               (let loop ((expr (scm-list (array-prefix->constructor prefix)))
                          (token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-bracket*)
                        (tokenizer 'next)
                        (scm-reverse expr))
                       (else (let ((e (scm-expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-bracket* *enforce-comma* 'array-literal)
                               (loop (scm-cons e expr) (tokenizer 'peek)))))))
        (parser-error tokenizer "Invalid start of array literal."))))

(define (table-literal mkset? tokenizer)
  (tokenizer 'next)
  (let ((close-token (if mkset? '*close-paren* '*close-brace*)))
    (let loop ((args '()))
      (if (scm-eq? (tokenizer 'peek) close-token)
          (begin
            (tokenizer 'next)
            (if mkset?
                `(make-set ,@args)
                `(make-equal-hashtable (scm-list ,@args))))
          (let ((keyval (scm-expression tokenizer)))
            (begin
              (if (and (not mkset?)
                       (scm-not (and
                                 (pair? keyval)
                                 (scm-eq? (scm-car keyval) 'scm-cons))))
                  (parser-error tokenizer "Expected key-value pair."))
              (assert-comma-separator tokenizer close-token *enforce-comma* 'table-literal)
              (loop (scm-cons keyval args))))))))
    
(define (array-or-table-literal tokenizer)
  (tokenizer 'next)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token '*open-brace*)
           (table-literal #f tokenizer))
          ((scm-eq? token '*open-paren*)
           (table-literal #t tokenizer))
          (else
           (array-literal tokenizer)))))

(define (for-bindings tokenizer)
  (let loop ((token (tokenizer 'peek)) (bindings '()))
    (cond ((or (scm-eq? token '*close-paren*)
               (scm-eq? token '*semicolon*))
	   bindings)
	  ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (tokenizer 'next)
           (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
               (parser-error tokenizer "Expected assignment."))
           (let ((expr (scm-expression tokenizer)))
             (let ((next (tokenizer 'peek)))
               (if (scm-eq? next '*comma*) 
                   (tokenizer 'next)))
             (loop (tokenizer 'peek) (scm-cons (scm-list token expr) bindings))))
          (else (parser-error tokenizer "Expected variable declaration.")))))

(define (for-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'for)
         (tokenizer 'next)
         (if (not (eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis here."))
         (let ((bindings (for-bindings tokenizer)))
           (if (not (eq? '*semicolon* (tokenizer 'next)))
               (parser-error tokenizer "Expected semicolon here."))
           (let ((cond-expr (if (eq? '*semicolon* (tokenizer 'peek)) #t (scm-expression tokenizer))))
             (if (not (eq? '*semicolon* (tokenizer 'next)))
                 (parser-error tokenizer "Expected semicolon here."))
             (let ((nxt-expr (if (eq? '*close-paren* (tokenizer 'peek)) #f (scm-expression tokenizer))))
               (if (not (eq? (tokenizer 'next) '*close-paren*))
                   (parser-error tokenizer "Expected closing parenthesis here."))
               (let ((counter (if (not (null? bindings)) (scm-caar bindings) #f)))
                 `(call/cc (lambda (break)
                             (let* ,(scm-append '((*for-value* #f)) (scm-reverse bindings))
                               (let *for-loop* ()
                                 (if ,cond-expr
                                     (begin
                                       (set! *for-value*
                                             (call/cc (lambda (continue)
                                                        ,(func-body-expr tokenizer #f #f))))
                                       ,(if counter
                                            `(set! ,counter ,nxt-expr)
                                            nxt-expr)
                                       (*for-loop*))
                                     *for-value*))))))))))
        (else  (func-call-expr (literal-expr tokenizer) tokenizer))))

(define (let-expr tokenizer)
  (let ((expr (let ((letkw (letkw? (tokenizer 'peek))))
		(if letkw
		    (begin (tokenizer 'next)
			   (if (valid-identifier? (tokenizer 'peek))
			       (named-let-expr letkw tokenizer)
			       (normal-let-expr letkw tokenizer)))
		    (for-expr tokenizer)))))
    expr))

(define (extract-let-binding-names bindings)
  (let loop ((bindings bindings) (vars '()))
    (if (null? bindings)
        (scm-cons '*let* (scm-reverse vars))
        (loop (scm-cdr bindings) (scm-cons (scm-caar bindings) vars)))))

(define (normal-let-expr letkw tokenizer)
  (let ((bindings (let-bindings tokenizer)))
    (scm-list letkw bindings (func-body-expr tokenizer (extract-let-binding-names bindings)))))

(define (named-let-expr letkw tokenizer)
  (if (scm-not (scm-eq? letkw 'let))
      (parser-error tokenizer (string-append "Cannot define " (symbol->string letkw)
                                             " as a named let.")))
  (let ((name (tokenizer 'next))
        (bindings (let-bindings tokenizer)))
    (scm-list letkw name bindings (func-body-expr tokenizer (extract-let-binding-names bindings)))))

(define (let-bindings tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "Expected let variable bindings list."))
  (let loop ((token (tokenizer 'next))
	     (bindings '()))
    (cond ((scm-eq? token '*close-paren*)
	   bindings)
	  ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
               (parser-error tokenizer "Expected assignment."))
           (let ((expr (scm-expression tokenizer)))
             (let ((next (tokenizer 'peek)))
               (if (scm-eq? next '*comma*) 
                   (tokenizer 'next)))
             (loop (tokenizer 'next) (scm-append bindings (scm-list (scm-list token expr))))))
          (else (parser-error tokenizer "Expected variable declaration.")))))

(define (letkw? sym)
  (if (and (symbol? sym)
	   (or (scm-eq? sym 'let)
	       (scm-eq? sym 'letseq)
	       (scm-eq? sym 'letrec)))
      (cond ((scm-eq? sym 'letseq)
             'let*)
            (else sym))
      #f))

(define (mod-exports-list tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((not (scm-eq? '*open-paren* token))
           '())
          (else
           (tokenizer 'next)
           (let loop ((exports '()))
             (let ((token (tokenizer 'peek)))
               (if (scm-not (scm-eq? token '*close-paren*))
                   (let ((expr (scm-expression tokenizer)))
                     (cond ((symbol? expr)
                            (check-if-reserved-name expr tokenizer)
                            (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'mod-exports-list)
                            (loop (scm-cons expr exports)))
                           ((pair? expr)
                            (cond ((scm-eq? (scm-car expr) 'scm-cons)
                                   (let ((expr (scm-cons (scm-cadr expr) (scm-caddr expr))))
                                     (check-if-reserved-name (scm-car expr) tokenizer)
                                     (check-if-reserved-name (scm-cdr expr) tokenizer)
                                     (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'mod-exports-list-2)
                                     (loop (scm-cons expr exports))))
                                  ((scm-eq? (scm-car expr) 'scm-list)
                                   (loop (scm-cons (scm-cdr expr) exports)))
                                  (else
                                   (parser-error tokenizer "Invalid export description."))))
                           (else
                            (parser-error tokenizer "Invalid name in exports."))))
                   (begin
                     (tokenizer 'next)
                     (scm-reverse exports)))))))))

(define (diff-exports defs-in-body exclude)
  (if (null? exclude)
      defs-in-body
      (let loop ((e defs-in-body) (exports '()))
        (cond ((null? e)
               (scm-reverse exports))
              ((scm-memq (scm-car e) exclude)
               (loop (scm-cdr e) exports))
              (else
               (loop (scm-cdr e) (scm-cons (scm-car e) exports)))))))

(define (check-if-body-has-exported-names body exports)
  (let ((defs-in-body
          (let loop ((body body) (defs '()))
            (if (null? body)
                defs
                (let ((e (scm-car body)))
                  (cond ((pair? e)
                         (loop (scm-cdr body)
                               (if (scm-eq? 'define (scm-car e))
                                   (scm-cons (scm-cadr e) defs)
                                   defs)))
                        ((symbol? e)
                         (loop (scm-cdr body)
                               (if (scm-eq? 'define e)
                                   (scm-cons (scm-cadr body) defs)
                                   defs)))
                        (else (loop (scm-cdr body) defs))))))))
    (if (eq? (scm-car exports) '_)
        (diff-exports defs-in-body (if (not (null? (scm-cdr exports)))
                                       (scm-cadr exports)
                                       '()))
        (let loop ((exps exports))
          (if (null? exps)
              exports
              (let ((e (scm-car exps)))
                (if (scm-memq (if (symbol? e) e (scm-cdr e)) defs-in-body)
                    (loop (scm-cdr exps))
                    (error "Exported name not found in definitions." e))))))))

(define (merge-module name exports body)
  (let ((exports (check-if-body-has-exported-names body exports)))
    (let ((dispatch-expr
           (let loop ((es exports)
                      (dispatcher `(case *name*)))
             (if (null? es)
                 `(if *name*
                      ,(scm-append dispatcher '((else (error (quote name_not_found) *name*))))
                      ',exports)
                 (let ((n (scm-car es)))
                   (if (symbol? n)
                       (loop (scm-cdr es) (scm-append dispatcher `(((,n) ,n))))
                       (loop (scm-cdr es) (scm-append dispatcher `(((,(scm-car n)) ,(scm-cdr n)))))))))))
      (let ((body-expr (scm-list 'let '() body `(lambda (#!optional *name*) ,dispatch-expr))))
        (if name `(define ,name ,body-expr) body-expr)))))
                       
(define (module-def-expr tokenizer)
  (cond ((scm-eq? 'module (tokenizer 'peek))
         (tokenizer 'next)
         (let ((mod-name (tokenizer 'peek)))
           (if (not (symbol? mod-name))
               (parser-error tokenizer "Expected module name.")
               (if (eq? mod-name '*open-paren*)
                   (set! mod-name #f)
                   (begin (tokenizer 'next)
                          (check-if-reserved-name mod-name tokenizer))))
           (let ((mod-exports (mod-exports-list tokenizer))
                 (mod-body (func-body-expr tokenizer '())))
             (merge-module mod-name mod-exports mod-body))))
        (else #f)))
             
(define (func-def-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? '*fn* token) (scm-eq? 'function token))
        (begin (tokenizer 'next)
               (let* ((params (scm-car (func-params-expr tokenizer #f)))
                      (body-expr (func-body-expr tokenizer params)))
                 (merge-lambda tokenizer params body-expr)))
        (module-def-expr tokenizer))))

(define (merge-lambda tokenizer params lambda-body)
  (let ((expr (let ((lambda-expr (scm-list 'lambda params)))
                (if (scm-not (list? lambda-body))
                    (set! lambda-body (scm-list 'begin lambda-body)))
                (if (<= 1 (scm-length lambda-body))
                    (scm-append lambda-expr (scm-list lambda-body))
                    (let loop ((lambda-expr lambda-expr)
                               (lambda-body (if (scm-eq? (scm-car lambda-body) 'begin)
                                                (scm-cdr lambda-body)
                                                lambda-body)))
                      (if (null? lambda-body)
                          lambda-expr
                          (loop (scm-append lambda-expr (scm-list (scm-car lambda-body)))
                                (scm-cdr lambda-body))))))))
    (if (> (tokenizer 'yield-count) 0)
        (tokenizer 'reset-yield-count))
    expr))

(define (wrap-in-return-cont expr)
  `(call/cc (lambda (*return*)
              (let ((*yield-obj* (make-s-yield #f *return*)))
                (begin ,expr
                       (let ((*r* (s-yield-k *yield-obj*)))
                         (s-yield-fn-set! *yield-obj* #f)
                         (*r* *yield-obj*)))))))

(define (stmt-or-expr tokenizer)
  (let ((expr (statement tokenizer)))
    (if (scm-not expr)
        (scm-expression tokenizer)
        expr)))

(define (extract-param-names params)
  (let loop ((params params) (res '()))
    (if (null? params)
      (scm-reverse res)
      (let ((p (scm-car params)))
        (cond
         ((or (eq? #!optional p) (eq? #!key p) (eq? #!rest p))
          (loop (scm-cdr params) res))
         ((symbol? p) (loop (scm-cdr params) (scm-cons p res)))
         ((pair? p) (loop (scm-cdr params) (scm-cons (scm-car p) res)))
         (else (loop (scm-cdr params) res)))))))

(define (func-body-expr tokenizer params #!optional (use-let #f))
  (let ((implicit-match? #f)
        (let-expr? (and params (> (scm-length params) 0) (eq? '*let* (scm-car params)))))
    (let ((params (if let-expr? (scm-cdr params) params)))
      (if (scm-eq? (tokenizer 'peek) '*pipe*)
          (if (and params (> (scm-length params) 0))
              (begin
                (tokenizer 'next)
                (set! implicit-match? #t))
              (parser-error tokenizer "Implicit match cannot be specified here.")))
      (let ((match-value (if implicit-match?
                             (let ((params (extract-param-names params)))
                               (if (= (scm-length params) 1)
                                   (scm-car params)
                                   (append '(scm-list) (extract-param-names params))))
                             #f)))
        (let ((old-yield-count (tokenizer 'yield-count)))
          (let ((body-expr
                 (let ((token (tokenizer 'peek)))
                   (if (or (scm-eq? token '*semicolon*) 
                           (eof-object? token))
                       '(begin (quote ()))
                       (if implicit-match?
                           (match-body-expr match-value tokenizer)
                           (if (scm-eq? (tokenizer 'peek) '*open-brace*)
                               (block-expr tokenizer use-let)
                               (stmt-or-expr tokenizer)))))))
            (if (and (not let-expr?) params (> (tokenizer 'yield-count) old-yield-count))
                (wrap-in-return-cont body-expr)
                body-expr)))))))

(define (func-call-expr func-val tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token '*open-paren*)
           (if (and (symbol? func-val)
                    (check-if-reserved-name func-val tokenizer)
                    (tokenizer 'pattern-mode?))
               (let ((s (symbol->string func-val)))
                 (set! func-val (string->symbol (string-append "+" s)))))
           (tokenizer 'next)
           (invoke-access-expression
            tokenizer
            (let ((expr (mk-func-call-expr tokenizer func-val)))
              (cond ((scm-eq? (tokenizer 'peek) '*close-paren*)
                     (tokenizer 'next) 
                     (if (scm-eq? (tokenizer 'peek) '*period*)
                         (member-access/funcall-expr expr tokenizer)
                         expr))
                    (else (parser-error
                           tokenizer
                           "Missing closing parenthesis after function argument list."))))))
          ((scm-eq? token '*open-bracket*)
           (array-access-expr tokenizer func-val))
          (else func-val))))

(define (mk-func-call-expr tokenizer func-val)
  (let ((expr (func-args-expr tokenizer)))
    (scm-cons func-val expr)))

(define (record-def-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'record)
      (begin (tokenizer 'next)
	     (let ((token (tokenizer 'peek)))
	       (if (scm-not (valid-identifier? token))
		   (parser-error tokenizer "Missing record name."))
	       (mk-record-expr (tokenizer 'next) tokenizer)))
      (assignment-stmt tokenizer)))

(define (rec-get-precond tokenizer)
  (tokenizer 'next)
  (let ((precond (scm-expression tokenizer)))
    (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-precond)
    precond))

(define (mk-rec-type-check-expr field-name type-name)
  (let ((predic-name (string->symbol (string-append "is_" (symbol->string type-name)))))
    `(,predic-name ,field-name)))

(define (rec-get-field-def tokenizer field-name)
  (let ((token (tokenizer 'peek)))
    (cond
     ((scm-eq? token '*assignment*)
      (tokenizer 'next)
      (let ((val (scm-expression tokenizer)))
        (if (scm-eq? (tokenizer 'peek) 'where)
            (scm-cons val (rec-get-precond tokenizer))
            (begin (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                   (scm-cons val #t)))))
     ((scm-eq? token '*colon*)
      (tokenizer 'next)
      (let ((type-name (tokenizer 'next)))
        (if (symbol? type-name)
            (if (eq? (tokenizer 'peek) '*assignment*)
                (begin (tokenizer 'next)
                       (let ((expr (scm-cons (scm-expression tokenizer) (mk-rec-type-check-expr field-name type-name))))
                         (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                         expr))
                (let ((expr (scm-cons #f (mk-rec-type-check-expr field-name type-name))))
                  (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def)
                  expr))
            (parser-error tokenizer "Expected a type name here."))))
     (else
      (if (scm-eq? token 'where)
          (scm-cons #f (rec-get-precond tokenizer))
          (begin (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'rec-get-field-def-3)
                 (scm-cons #f #t)))))))

(define (mk-record-expr name tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((token (tokenizer 'peek))
                    (members '()) (default-values '())
                    (preconds '()))
           (cond ((valid-identifier? token)
                  (let ((token (tokenizer 'next))
                        (fdef (rec-get-field-def tokenizer token)))
                    (loop (tokenizer 'peek) (scm-cons token members)
                          (scm-cons (scm-car fdef) default-values) 
                          (scm-cons (scm-cdr fdef) preconds))))
                 ((scm-eq? token '*close-paren*)
                  (tokenizer 'next)
                  (def-struct-expr name (scm-reverse members) (scm-reverse default-values) (scm-reverse preconds)))
                 (else (parser-error tokenizer "Invalid record specification.")))))
        (else (parser-error tokenizer "Expected record member specification."))))

(define (def-struct-expr name members default-values preconds)
  (scm-append (scm-list 'begin (scm-append (scm-list 'define-structure name) members))
	  (mk-struct-accessors/modifiers name members default-values preconds)))

(define (mk-record-precond-expr precond mem)
  (if (scm-eq? precond #t)
      precond
      `(if (scm-not ,precond)
           (error 'precondition_failed ,mem)
           ,mem)))

(define (mk-record-precond-exprs preconds mems)
  (let loop ((preconds preconds) (mems mems) (result '()))
    (if (null? preconds) (scm-append (scm-list 'begin) (scm-reverse result))
        (loop (scm-cdr preconds) (scm-cdr mems)
              (if (scm-eq? #t (scm-car preconds))
                  result
                  (scm-cons (mk-record-precond-expr (scm-car preconds) (scm-car mems)) result))))))
        
(define (mk-record-constructor recname members default-values preconds)
  (scm-append (scm-list 'lambda (scm-append (scm-list '#!key) (mk-record-constructor-params members default-values)))
          (scm-list (mk-record-precond-exprs preconds members) 
                (scm-cons (string->symbol (string-append "make-" recname)) members))))

(define (mk-record-constructor-params members default-values)
  (let loop ((members members) (default-values default-values) 
             (params '()))
    (cond ((null? members) (scm-reverse params))
          (else (loop (scm-cdr members) (scm-cdr default-values)
                      (scm-cons (scm-list (scm-car members) 
                                  (scm-car default-values)) params))))))

(define (mk-struct-accessors/modifiers name members default-values preconds)
  (let ((sname (symbol->string name)))
    (let loop ((members members)
               (preconds preconds)
               (i 0)
               (expr (scm-list 
                      (scm-list 'define (string->symbol sname) 
                            (mk-record-constructor sname members default-values preconds))
                      (scm-list 'define (string->symbol (string-append "make_" sname))
                            (string->symbol (string-append "make-" sname)))
                      (scm-list 'define 
                            (string->symbol (string-append "is_" sname))
                            (string->symbol (string-append sname "?"))))))
      (if (null? members) (scm-reverse expr)
          (begin (loop (scm-cdr members) (scm-cdr preconds) (+ i 1)
                       (scm-append expr (member-accessor/modifier name (scm-car members) (scm-car preconds) i))))))))

(define (member-accessor/modifier name mem precond index)
  (let ((sname (symbol->string name))
	(smem (symbol->string mem)))
    (let ((scm-accessor (string->symbol (string-append sname "-" smem)))
	  (scm-modifier (string->symbol (string-append sname "-" smem "-set!")))
	  (slgn-accessor (string->symbol (string-append sname "_" smem)))
          (idx-accessor (string->symbol (string-append sname "-" (number->string index))))
	  (slgn-modifier (string->symbol (string-append sname "_set_" smem))))
      (scm-list (scm-list 'define slgn-accessor scm-accessor)
            (scm-list 'define idx-accessor scm-accessor)
	    (scm-list 'define slgn-modifier (scm-append (scm-list 'lambda (scm-list '*s* mem)) 
                                                (scm-append (if (scm-eq? #t precond) '() (scm-list (mk-record-precond-expr precond mem)))
                                                        (scm-list (scm-list scm-modifier '*s* mem)))))))))

(define (assert-comma-separator tokenizer end-seq-char comma-required caller)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*comma*)
            (if (list? end-seq-char) 
                (scm-memq token end-seq-char) 
                (scm-eq? token end-seq-char)))
        (if (scm-eq? token '*comma*) (tokenizer 'next))
        (if comma-required
            (parser-error tokenizer (with-output-to-string
                                      '()
                                      (lambda ()
                                        (scm-display "Missing comma or ") 
                                        (scm-display end-seq-char) 
                                        (scm-display ".")
                                        (scm-display "(")
                                        (scm-display caller)
                                        (scm-display ")"))))))))

(define (func-args-expr tokenizer)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-not (scm-eq? token '*close-paren*))
          (cond ((valid-identifier? token)
                 (let ((sym (tokenizer 'next)))
                   (if (scm-eq? (tokenizer 'peek) '*assignment*)
                       (begin (tokenizer 'next)
                              (let ((expr (scm-expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr)
                                (loop (scm-append args (scm-list (slgn-variable->scm-keyword sym) expr)))))
                       (begin (tokenizer 'put sym)
                              (let ((expr (scm-expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr-2)
                                (loop (scm-append args (scm-list expr))))))))
                (else
                 (let ((expr (scm-expression tokenizer)))
                   (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-args-expr-3)
                   (loop (scm-append args (scm-list expr))))))
          args))))

(define (check-if-reserved-name sym tokenizer)
  (if (or (reserved-name? sym) (slgn-is_special_token sym))
      (parser-error tokenizer (string-append "Invalid use of keyword or operator: "
                                             (symbol->string sym) ".") sym)
      sym))

(define (valid-identifier? sym)
  (and (symbol? sym)
       (scm-not (or (reserved-name? sym)
		(slgn-is_special_token sym)))))
  
(define (check-func-param tokenizer) 
  (check-if-reserved-name (tokenizer 'peek) tokenizer)
  (let ((sym (tokenizer 'next)))
    (if (scm-eq? sym '_) (gensym) sym)))

(define (func-param-type tokenizer)
  (let ((type (cond ((scm-eq? (tokenizer 'peek) '*colon*)
		     (tokenizer 'next)
		     (let ((s (tokenizer 'next)))
		       (if (symbol? s) s (parser-error tokenizer "Expected type name."))))
		    (else '_))))
    (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'func-param-type)
    type))

(define (func-params-expr tokenizer params-required?)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((params '()) (types '())
                    (directives-found #f))
           (let ((token (tokenizer 'peek)))
             (cond ((valid-identifier? token)
                    (let ((sym (check-func-param tokenizer)))
                      (cond ((param-directive? sym)
                             (loop (scm-cons (slgn-directive->scm-directive sym) params)
				   (if (scm-eq? sym '@rest) (scm-cons sym types) types)
				   #t))
                            ((scm-eq? (tokenizer 'peek) '*assignment*)
                             (tokenizer 'next)
                             (let ((expr (scm-expression tokenizer)))
                               (if directives-found
                                   (loop (scm-cons (scm-list sym expr) params)
					 (scm-cons (func-param-type tokenizer) types)					 
					 directives-found)
				   (loop (scm-cons 
					  (scm-list sym expr) 
					  (scm-cons 
					   (slgn-directive->scm-directive '@optional) params))
					 (scm-cons (func-param-type tokenizer) types)					 
					 #t))))
                            (else 
                             (loop (scm-cons sym params)
				   (scm-cons (func-param-type tokenizer) types)				   
				   directives-found)))))
                   (else
                    (if (scm-eq? token '*close-paren*)
                        (begin (tokenizer 'next)
                               (scm-cons (scm-reverse params) (scm-reverse types)))
                        (parser-error tokenizer "Missing closing parenthesis after parameter list.")))))))
        (else
	 (if params-required?
	     (parser-error tokenizer "Missing parameter list.")
	     (scm-cons '() '())))))

(define (param-directive? sym)
  (scm-memq sym '(@optional @key @rest)))

(define (closure-member-access var tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (let loop ((expr `(,var ',(tokenizer 'next))))
	(if (scm-eq? (tokenizer 'peek) '*period*)
	    (begin (tokenizer 'next)
		   (if (valid-identifier? (tokenizer 'peek))
		       (loop (scm-cons expr `(',(tokenizer 'next))))
		       (parser-error tokenizer "Expected identifier.")))
	    expr))
      (parser-error tokenizer "Expected identifier.")))

(define (add-expr tokenizer)
  (swap-operands (scm-cons '+ (scm-list (term-expr tokenizer)))))

(define (sub-expr tokenizer)
  (swap-operands (scm-cons '- (scm-list (term-expr tokenizer)))))

(define (mult-expr tokenizer)
  (swap-operands (scm-cons '* (scm-list (factor-expr tokenizer)))))

(define (div-expr tokenizer)
  (swap-operands (scm-cons '/ (scm-list (factor-expr tokenizer)))))

(define (eq-expr tokenizer)
  (swap-operands (scm-cons '== (scm-list (addsub-expr tokenizer)))))

(define (not-eq-expr tokenizer)
  (swap-operands (scm-cons '<> (scm-list (addsub-expr tokenizer)))))

(define (lt-expr tokenizer)
  (swap-operands (scm-cons 'lt-compare (scm-list (addsub-expr tokenizer)))))

(define (lteq-expr tokenizer)
  (swap-operands (scm-cons 'lteq-compare (scm-list (addsub-expr tokenizer)))))

(define (gt-expr tokenizer)
  (swap-operands (scm-cons 'gt-compare (scm-list (addsub-expr tokenizer)))))

(define (gteq-expr tokenizer)
  (swap-operands (scm-cons 'gteq-compare (scm-list (addsub-expr tokenizer)))))

(define (and-expr tokenizer)
  (swap-operands (scm-cons 'and (scm-list (logical-or-expr tokenizer)))))

(define (or-expr tokenizer)
  (swap-operands (scm-cons 'or (scm-list (cmpr-expr tokenizer)))))

(define (term-expr tokenizer)
  (let loop ((expr (factor-expr tokenizer)))
    (if (mult-div-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*asterisk*) (loop (swap-operands (scm-append (mult-expr tokenizer) (scm-list expr)))))
          ((*backslash*) (loop (swap-operands (scm-append (div-expr tokenizer) (scm-list expr))))))
        expr)))

(define (swap-operands expr)
  (if (= 3 (scm-length expr))
      (scm-list (scm-car expr) (scm-caddr expr) (scm-cadr expr))
      expr))

(define *reserved-names* '(^ function module record true false
			     if else when let letseq letrec yield
			     case match where try trycc catch finally
			     declare assert for break continue))

(define (reserved-name? sym)
  (and (symbol? sym)
       (scm-memq sym *reserved-names*)))

(define (parened-names->list tokenizer)
  (if (scm-eq? (tokenizer 'next) '*open-paren*)
      (let loop ((token (tokenizer 'next))
                 (result '()))
        (cond ((scm-eq? token '*close-paren*)
               (scm-reverse result))
              ((valid-identifier? token)
               (assert-comma-separator tokenizer '*close-paren* *enforce-comma* 'parened-names->list)
               (loop (tokenizer 'next) (scm-cons token result)))
              (else #f)))
      #f))

(define expression scm-expression)
(define slogan scm-slogan)
