;; Copyright (c) 2013-2016 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define-structure s-yield fn k)

(define (slogan tokenizer)
  (let ((expr (expression/statement tokenizer)))
    (if (> (tokenizer 'yield-count) 0)
        (begin (reset-yield-count! tokenizer 0)
               (error "yield can be called only from a function."))
        expr)))

(define (expression/statement tokenizer #!optional (top #t))
  (if (eof-object? (tokenizer 'peek))
      (tokenizer 'next)
      (let ((v (add-def-to-namespace (statement tokenizer) top)))
        (if (scm-not v) (set! v (intern-to-top-namespace (expression tokenizer) top)))
        (assert-semicolon tokenizer)
        v)))

(define (statement tokenizer)
  (sanitize-expression
   tokenizer
   (if (scm-eq? (tokenizer 'peek) '*semicolon*) *void*
       (namespace-stmt tokenizer))))

(define (highligted-line colno)
  (if (< colno 0)
      (set! colno 1))
  (with-output-to-string
    '()
    (lambda ()
      (let loop ((n 0))
	(if (= n colno) (scm-display #\^)
	    (begin (scm-display #\space)
		   (loop (+ n 1))))))))

(define (highligted-error-line tokenizer #!optional token)
  (let ((curr-tok-len (current-token-length tokenizer))
        (tlen (if token
                  (string-length (if (symbol? token) (symbol->string token) token))
                  0)))
    (let loop ((line-no (tokenizer 'line)) 
               (n 1)
               (program-text (tokenizer 'program-text)))
      (if (scm-not (null? program-text))
          (if (= n line-no)
              (scm-cons (scm-car program-text) (highligted-line (+ tlen (- (tokenizer 'column) curr-tok-len))))
              (loop line-no (+ n 1) (scm-cdr program-text)))
          #f))))

(define (parser-error tokenizer msg #!optional token)
  (pop-namespace)
  (error (with-output-to-string 
           '()
           (lambda ()
             (if tokenizer
                 (scm-println "at [line: "(tokenizer 'line) 
                          ", column: " (tokenizer 'column) "]. " 
                          msg))
             (let ((hl (highligted-error-line tokenizer token)))
               (if hl (begin (scm-println (scm-car hl))
                             (scm-println (scm-cdr hl)))))))))

(define (assert-semicolon tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*semicolon*)
            (scm-eq? token '*close-brace*)
            (eof-object? token))
        (if (scm-eq? token '*semicolon*)
            (tokenizer 'next))
        (parser-error tokenizer "Statement or expression not properly terminated."))))

(define (namespace-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'namespace)
      (begin (tokenizer 'next)
             (if (valid-identifier? (tokenizer 'peek))
		 (push-namespace (check-if-reserved-name (tokenizer 'next) tokenizer))
		 (pop-namespace)))
      (import-stmt tokenizer)))

(define (import-with-prefix tokenizer ns-name import-names)
  (tokenizer 'next)
  (let ((prefix (tokenizer 'next)))
    (if (scm-not (valid-identifier? prefix))
        (parser-error tokenizer "Expected name prefix.")
        (import-from-namespace ns-name import-names prefix))))
  
(define (import-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'import)
      (begin (tokenizer 'next)
             (let ((import-names (import-defs tokenizer)))
               (cond ((list? import-names)
                      (if (scm-not (scm-eq? (tokenizer 'next) 'from))
                          (parser-error tokenizer "Expected `from <namespace_name>'."))
                      (let ((nname (tokenizer 'next)))
                        (if (scm-not (valid-identifier? nname))
                            (parser-error tokenizer "Expected namespace name."))
                        (if (scm-eq? (tokenizer 'peek) 'as)
                            (import-with-prefix tokenizer nname import-names)
                            (import-from-namespace nname import-names))))
                     (else (if (scm-eq? (tokenizer 'peek) 'as)
                               (import-with-prefix tokenizer import-names #f)
                               (import-from-namespace import-names))))))
      (declare-stmt tokenizer)))

(define (declare-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'declare)
      (begin (tokenizer 'next)
             (let ((name (tokenizer 'next)))
               (case name
                 ((lazy) (declare-lazy-stmt tokenizer))
                 ((imported) (declare-imported-stmt tokenizer))
                 ((generic) (declare-generic-stmt tokenizer))
                 ((ffi) (declare-ffi-stmt tokenizer))
                 (else
                  (parser-error tokenizer "Invalid declare type.")))))
      (func-def-stmt tokenizer)))

(define (normalize-c-struct-members memtypes)
  (scm-map (lambda (m) (scm-cons (scm-cadr m) (scm-caddr m))) memtypes))

(define (c-struct-stmt tokenizer)
  (let ((struct-name (tokenizer 'next)))
    (if (scm-not (symbol? struct-name))
        (parser-error tokenizer "Struct name must be a symbol." struct-name)
        (let ((memtypes (expression tokenizer)))
          (if (scm-not (scm-eq? (scm-car memtypes) 'list))
              (parser-error tokenizer "Struct member types must be a list." memtypes)
              `(def-c-struct ',struct-name ',(normalize-c-struct-members (scm-cdr memtypes))))))))

(define (c-fn-stmt tokenizer rettype libname)
  (let ((fn-name (tokenizer 'next)))
    (if (scm-not (symbol? fn-name))
        (parser-error tokenizer "Function name must be a symbol." fn-name)
        (let ((paramtypes (expression tokenizer)))
          (if (scm-not (pair? paramtypes))
              (parser-error tokenizer "Expected parameter list."))
          (if (scm-not (scm-eq? (scm-car paramtypes) 'list))
              (parser-error tokenizer "Parameter types must be a list." paramtypes)
              (let ((name fn-name))
                (if (scm-eq? (tokenizer 'peek) 'as)
                    (begin (tokenizer 'next)
                           (set! name (tokenizer 'next))
                           (if (scm-not (symbol? name))
                               (parser-error tokenizer "Function local name must be a symbol." name))))
                (def-c-fn libname fn-name name (scm-cdr paramtypes) rettype)))))))
                
(define (cdef-stmt tokenizer libname)
  (let ((token (tokenizer 'next)))
    (if (scm-eq? token 'struct)
        (c-struct-stmt tokenizer)
        (c-fn-stmt tokenizer token libname))))

(define (def-ffi tokenizer libname expr)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-bracket*))
      (parser-error tokenizer "FFI definitions must be within a list.")
      (let loop ((defs '()))
        (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
            (begin (tokenizer 'next)
                   (scm-append expr (scm-reverse defs)))
            (let ((cdef (cdef-stmt tokenizer libname)))
              (assert-comma-separator tokenizer '*close-bracket*)
              (loop (scm-cons cdef defs)))))))

(define *ffi-lib-count* 0)
(define (genffisym)
  (let ((s (string-append "*ffi-" (number->string *ffi-lib-count*) "-*")))
    (set! *ffi-lib-count* (+ *ffi-lib-count* 1))
    (string->symbol s)))

(define (declare-ffi-stmt tokenizer)
  (let ((libname (tokenizer 'next)))
    (if (scm-not (or (string? libname)
                 (symbol? libname)))
        (parser-error tokenizer "Invalid library name - " libname)
        (let ((lname (genffisym)))
          (def-ffi tokenizer lname `(begin (define ,lname (if (string? ,libname)
                                                              (ffi_open ,libname)
                                                              ,libname))))))))
(define (declare-lazy-stmt tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (valid-identifier? name)
	(declare-lazy (tokenizer 'next))
        (declare-lazy (parened-names->list tokenizer)))))

(define (declare-imported-stmt tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (declare-imported (tokenizer 'next))
      (let ((names (parened-names->list tokenizer)))
        (if names (declare-imported names)
            (parser-error tokenizer "Invalid import list.")))))

(define (declare-generic-stmt tokenizer)
  (let ((name (tokenizer 'next)))
    (if (valid-identifier? name)
        (define-generic-method name tokenizer)
        (parser-error tokenizer "Expected a valid generic method name."))))

(define (define-generic-method name tokenizer)
  (check-if-reserved-name name tokenizer)
  (let ((params (func-params-expr tokenizer)))
    (let ((generic-expr
	   `(define ,name 
	      (lambda ,params
	      (error "Method not defined.")))))
      (if (scm-eq? (tokenizer 'peek) 'cases)
	  `(begin ,generic-expr ,@(generic-cases-expr tokenizer name params))
	  generic-expr))))

(define (generic-cases-expr tokenizer name params)
  (tokenizer 'next)
  (let loop ((types (method-types-decl tokenizer))
	     (method-defs '())
	     (found-else #f))
    (if (scm-not (scm-eq? (tokenizer 'next) '*inserter*))
	(parser-error tokenizer "Missing -> after types expression."))
    (let* ((body-expr (func-body-expr tokenizer params))
           (mdef (scm-cons types (scm-list 'define name (merge-lambda 
                                                         tokenizer params 
                                                         body-expr)))))
      (cond ((scm-eq? (tokenizer 'peek) '*comma*)
	     (tokenizer 'next)
	     (cond ((scm-eq? (tokenizer 'peek) 'else)
		    (tokenizer 'next)
		    (loop
		     '()
		     (scm-cons (mk-method-def mdef) method-defs)
		     #t))
		   (else
		    (loop (method-types-decl tokenizer)
			  (scm-cons (mk-method-def mdef) method-defs) #f))))
	    (found-else
	     (scm-cons (mk-method-def mdef) (scm-reverse method-defs)))
	    (else
	     (scm-reverse (scm-cons (mk-method-def mdef) method-defs)))))))

(define (import-defs tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (tokenizer 'next)
      (import-defs-list tokenizer)))

(define (import-defs-list tokenizer)
  (let ((names (parened-names->list tokenizer)))
    (if names names
        (parser-error tokenizer "Invalid import list."))))

(define (func-def-stmt-from-name tokenizer #!optional is-lazy noname)
  (let ((name (tokenizer 'peek)))
    (if (and (scm-eq? name '*open-paren*)
             (scm-not noname))
	(if is-lazy
            (parser-error tokenizer "lazy function must have a name.")
	    (let* ((params (func-params-expr tokenizer))
                   (body-expr (func-body-expr tokenizer params)))
	      (merge-lambda tokenizer params body-expr)))
	(begin (if (scm-not noname)
                   (begin (check-if-reserved-name name tokenizer)
                          (tokenizer 'next)
                          (remove-macro-lazy-fns-def name)))
	       (let ((params (func-params-expr tokenizer)))
		 (if (and is-lazy (scm-not noname))
                     (def-lazy name (make-lazy #f #f)))
                 (let* ((body-expr (func-body-expr tokenizer params))
                        (expr (merge-lambda 
                               tokenizer params 
                               (if (and is-lazy (scm-not noname))
                                   (expr-forcify (func-body-expr tokenizer params) params)
                                   body-expr))))
                   (if (scm-not noname)
                       (scm-list 'define name expr)
                       expr)))))))

(define (func-def? token) (or (scm-eq? 'fn token) (scm-eq? 'function token)))

(define (func-def-stmt tokenizer)
  (cond ((func-def? (tokenizer 'peek))
         (tokenizer 'next)
         (if (scm-eq? (tokenizer 'peek) 'lazy)
             (lazy-fn-stmt tokenizer)
             (func-def-stmt-from-name tokenizer)))
        (else (method-def-stmt tokenizer))))

(define (method-types-decl tokenizer)
  (if (scm-not (scm-eq? '*open-paren* (tokenizer 'next)))
      (parser-error tokenizer "Types declaration must start with opening parenthesis."))
  (let ((types-decl (func-args-expr tokenizer #f)))
    (if (scm-not (scm-eq? '*close-paren* (tokenizer 'next)))
        (parser-error tokenizer "Missing closing parenthesis after type declaration."))
    (if (scm-not (for_all symbol? types-decl))
        (parser-error tokenizer "Invalid type declaration."))
    types-decl))

(define (mk-predic-name psym)
  (if (scm-eq? psym '_)
      'is_object
      (string->symbol 
       (string-append 
        "is_" 
        (symbol->string psym)))))

(define (mk-method-types-chk types args)
  (let loop ((types types)
             (args args)
             (chk-expr '()))
    (if (null? types) (scm-append (scm-list 'and) (scm-reverse chk-expr))
        (let ((type-name (scm-car types)))
          (if (scm-eq? type-name '@rest)
              (loop (cddr types)
                    (scm-cdr args)
                    (scm-cons `(for_all ,(mk-predic-name (scm-cadr types)) ,(scm-car args)) chk-expr))
              (loop (scm-cdr types) 
                    (scm-cdr args) 
                    (scm-cons `(,(mk-predic-name (scm-car types)) ,(scm-car args)) chk-expr)))))))

(define (params->args params)
  (let loop ((params params)
             (args '()))
    (if (null? params)
        (scm-reverse args)
        (cond ((pair? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-caar params) args)))
              ((symbol? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-car params) args)))
              (else (loop (scm-cdr params) args))))))

(define (method-def-stmt-from-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (scm-not (valid-identifier? name))
        (parser-error tokenizer "Method must have a valid name."))
    (begin (tokenizer 'next)
           (remove-macro-lazy-fns-def name)
           (let ((types (method-types-decl tokenizer))
                 (params (func-params-expr tokenizer)))
             (let ((body-expr (func-body-expr tokenizer params)))
               (scm-cons types (scm-list 'define name (merge-lambda 
                                                       tokenizer params 
                                                       body-expr))))))))

(define (method-def-stmt tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'method)
         (tokenizer 'next)
         (mk-method-def (method-def-stmt-from-name tokenizer)))
        (else (record-def-stmt tokenizer))))

(define (types-has-rest? types)
  (member '@rest types))

(define (mk-method-def method-def)
  (let ((func-def (scm-cdr method-def))
	(types (scm-car method-def)))
    (let ((name (scm-cadr func-def))
	  (params (scm-cadr (scm-caddr func-def)))
	  (args (params->args (scm-cadr (scm-caddr func-def))))
	  (body (scm-caddr (scm-caddr func-def))))
      (let ((types-chk (mk-method-types-chk types args))
	    (old-name (string->symbol 
		       (string-append 
			"*" 
			(symbol->string name) 
			"*"))))
        (let ((parent-call (if (types-has-rest? types)
                               `(scm-apply ,old-name ,@args)
                               `(,old-name ,@args))))
          `(define ,name (let ((,old-name ,name))
                           (lambda ,params 
                             (if ,types-chk 
                                 ,body
                                 ,parent-call)))))))))
  
(define (assignment-stmt tokenizer)
  (if (symbol? (tokenizer 'peek))
      (let ((sym (tokenizer 'next)))
	(if (scm-eq? sym 'define)
	    (define-stmt tokenizer)
	    (cond ((scm-not (valid-identifier? sym))
		   (tokenizer 'put sym)
		   #f)
		  ((scm-eq? (tokenizer 'peek) '*assignment*)
		   (set-stmt sym tokenizer))
		  (else (tokenizer 'put sym) 
			#f))))
      #f))

(define (macro-def-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'macro)
      (begin (tokenizer 'next)
             (mk-macro-def (tokenizer 'next) tokenizer))
      (assignment-stmt tokenizer)))

(define (lazy-fn-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'lazy)
      (begin (tokenizer 'next)
	     (func-def-stmt-from-name tokenizer #t))
      (assignment-stmt tokenizer)))

(define (mk-macro-def macro-name tokenizer)
  (check-if-reserved-name macro-name tokenizer)
  (remove-macro-lazy-fns-def macro-name)
  (tokenizer 'macro-mode-on)
  (scm-eval (let ((expr (scm-list 'define macro-name (func-def-stmt-from-name tokenizer #f #t))))
          (add-def-to-namespace expr #t)))
  (def-macro macro-name #t)
  (tokenizer 'macro-mode-off)
  *void*)

(define (enter-scope) (push-macros-lazy-fns))

(define (leave-scope) (pop-macros-lazy-fns))

(define (define-stmt tokenizer)
  (let ((token (tokenizer 'next)))
    (if (symbol? token)
        (let ((unquote? (scm-eq? '*unquote* token)))
          (if unquote?
              (if (scm-not (tokenizer 'quote-mode?))
                  (parser-error tokenizer "Not in quote mode.")
                  (set! token (tokenizer 'next))))
          (check-if-reserved-name token tokenizer)
          (var-def-set (if unquote? (scm-list 'unquote token) token) tokenizer #t))
        (parser-error tokenizer "Invalid variable name."))))

(define (set-stmt sym tokenizer) (var-def-set sym tokenizer #f))

(define (normalize-rvar sym)
  (let ((s (symbol->string sym)))
    (string->symbol (substring s 1 (string-length s)))))

(define (rvar? sym)
  (if (symbol? sym) 
      (let ((s (symbol->string sym)))
        (and (> (string-length s) 0)
             (char=? #\? (string-ref s 0))))
      #f))

(define (var-def-set sym tokenizer def)
  (remove-macro-lazy-fns-def sym)
  (if (scm-eq? (tokenizer 'peek) '*assignment*)
      (begin (tokenizer 'next)
             (if (rvar? sym)
                 (let ((sym (normalize-rvar sym)))
                   (if def
                       `(begin
                          (define ,sym (scm-rvar))
                          (scm-rbind ,sym ,(expression tokenizer)))
                       (scm-list 'scm-rbind sym (expression tokenizer))))
                 (scm-list (if def 'define 'set!) sym (expression tokenizer))))
      (parser-error tokenizer "Expected assignment.")))

(define (expression tokenizer)
  (sanitize-expression tokenizer
   (let ((expr (logical-and-expr tokenizer)))
     (let loop ((expr expr))
       (let ((tok (tokenizer 'peek)))
         (cond ((scm-eq? tok '*open-paren*)
                (loop (func-call-expr expr tokenizer)))
               ((scm-eq? tok '*colon*)
                (pair-literal tokenizer expr))
               (else expr)))))))

(define (pair-literal tokenizer expr)
  (tokenizer 'next)
  (let ((lpair? (scm-eq? (tokenizer 'peek) '*colon*)))
    (if lpair? (tokenizer 'next))
    (let ((tail-expr (if lpair? 
			 `(delay ,(expression tokenizer))
			 (expression tokenizer))))
      (if (tokenizer 'quote-mode?)
	  `(,expr . ,tail-expr)
	  `(scm-cons ,expr ,tail-expr)))))

(define (then-expr tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
      (parser-error tokenizer "Expected closing parenthesis."))
  (func-body-expr tokenizer #f #t))

(define (if-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'if)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (expression tokenizer)
                                     (then-expr tokenizer)))))
           (if (scm-eq? (tokenizer 'peek) 'else)
               (begin (tokenizer 'next)
                      (if (scm-eq? (tokenizer 'peek) 'if)
                          (scm-append expr (scm-list (if-expr tokenizer)))
                          (scm-append expr (scm-list (func-body-expr tokenizer #f #t)))))
               (scm-append expr '(#f)))))
        (else (when-expr tokenizer))))

(define (when-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'when)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (expression tokenizer)
                                     (then-expr tokenizer)))))
           (scm-append expr '(#f))))
        (else (case-expr tokenizer))))

(define (case-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'case)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before case clause."))
         (let ((value (expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after case clause."))
           (let loop ((token (tokenizer 'peek)) (last-expr #f) (body '()))
             (if last-expr (scm-append `(case ,value) (scm-reverse body))
                 (let ((expr (normalize-sym (case-pattern-expression tokenizer))))
                   (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
                       (parser-error tokenizer "Missing -> after case expression.")
                       (tokenizer 'next))
                   (let ((result (func-body-expr tokenizer #f #t))
                         (next (tokenizer 'peek)) (le #f))
                     (if (scm-eq? next '*comma*)
                         (tokenizer 'next)
                         (set! le #t))
                     (loop (tokenizer 'peek) le
                           (if (and le (scm-not (scm-eq? expr 'else)))
                               (scm-cons '(else #f) (scm-cons (scm-list (if (list? expr) expr (scm-cons expr '())) result) body))
                               (scm-cons (scm-list (if (or (list? expr) (scm-eq? expr 'else)) expr (scm-cons expr '()))
                                                   result) body)))))))))
        (else (match-expr tokenizer))))

(define (case-pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (expression tokenizer)))

(define (pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (begin
	(tokenizer 'pattern-mode-on)
	(let ((expr (expression tokenizer)))
	  (tokenizer 'pattern-mode-off)
	  expr))))

(define (unbound? r) (scm-eq? r '*unbound*))

(define (match-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'match)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before match clause."))
         (let ((value (expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after match clause."))
           (match-body-expr value tokenizer)))
        (else (try-catch-expr tokenizer))))

(define (match-body-expr value tokenizer)
  (let loop ((token (tokenizer 'peek)) (prev-pattern #f) (last-expr #f) (body '()))
    (if last-expr `(let ((*match-expr* ,value))
                     (let ((*value* *match-expr*)
                           (*orig-value* *match-expr*)
                           (*match-found* #f)
                           (*conv-value* #f)
                           (*result* '*unbound*))
                       ,@(scm-reverse body)
                       (if (unbound? *result*)
                           (error "No match found.")
                           *result*)))
        (let ((pattern (pattern-expression tokenizer))
              (guard #t))
          (if (scm-eq? (tokenizer 'peek) 'where)
              (begin (tokenizer 'next)
                     (set! guard (expression tokenizer))))
          (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
              (parser-error tokenizer "Missing -> after pattern.")
              (tokenizer 'next))
          (let ((consequent (func-body-expr tokenizer #f #t)))
            (if (scm-not (scm-eq? guard #t))
                (set! consequent `(if ,guard 
                                      ,consequent 
                                      (begin (set! *match-found* #f) 
                                             (set! *value* *orig-value*)
                                             '*unbound*))))
            (let ((next (tokenizer 'peek))
                  (le (scm-eq? pattern 'else)))
              (if (scm-eq? next '*comma*)
                  (if (scm-not le) (tokenizer 'next))
                  (if (scm-not le) (set! le #t)))
              (loop (tokenizer 'peek)
                    (if (scm-eq? pattern '@) prev-pattern pattern) le
                    (scm-cons (match-pattern (if (scm-eq? pattern '@) prev-pattern pattern) consequent) body))))))))

(define (try-catch-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((or (scm-eq? token 'try)
               (scm-eq? token 'trycc))
           (tokenizer 'next)
           (let ((try-expr (expression tokenizer)))
             (case (tokenizer 'peek)
               ((catch)
                (make-try-catch-expr token try-expr (catch-args tokenizer) 
                                     (expression tokenizer) 
                                     (finally-expr tokenizer)))
               ((finally)
                (make-try-catch-expr token try-expr '(*e*) '(raise *e*)
                                     (finally-expr tokenizer)))
               (else (parser-error tokenizer "Expected catch or finally clauses.")))))
          (else (yield-expr tokenizer)))))

(define (catch-args tokenizer)
  (tokenizer 'next)
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing opening parenthesis."))
  (tokenizer 'next)
  (let ((result (tokenizer 'next)))
    (if (scm-not (and (symbol? result)
		  (check-if-reserved-name result tokenizer)))
        (parser-error tokenizer "Missing exception identifier."))
    (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
        (parser-error tokenizer "Missing closing parenthesis."))
    (tokenizer 'next)
    (scm-list result)))

(define (finally-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'finally)
         (tokenizer 'next)
         (expression tokenizer))
        (else *void*)))
      
(define (get-exception-handler-fnname try-token)
  (if (scm-eq? try-token 'try) 'with-exception-catcher 'with-exception-handler))

(define (make-try-catch-expr try-token try-expr catch-args catch-expr finally-expr)
  (let ((try-expr (scm-list (get-exception-handler-fnname try-token)
			(scm-list 'lambda catch-args catch-expr)
			(scm-list 'lambda (list) try-expr))))
    (if (void? finally-expr) try-expr
	(scm-list 'let (scm-list (scm-list '*finally* (scm-list 'lambda (list) finally-expr)))
            (scm-list (get-exception-handler-fnname try-token)
                  (scm-list 'lambda '(*e*) '(begin (*finally*) (raise *e*)))
                  (scm-list 'lambda '() try-expr))
	    '(*finally*)))))

(define (yield-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'yield)
           (tokenizer 'next)
           (tokenizer 'yield-count-up)
           (let ((expr (expression tokenizer)))
             `(call/cc (lambda(*yield*)
                         (let ((*r* (s-yield-k *yield-obj*)))
                           (s-yield-fn-set! *yield-obj* *yield*)
                           (*r* (scm-cons ,expr *yield-obj*)))))))
          (else #f))))

(define (normalize-sym s)
  (if (and (list? s)
           (scm-eq? (scm-car s) 'quote))
      (scm-cadr s)
      s))

(define (expression-with-semicolon tokenizer)
  (let ((expr (expression tokenizer)))
    (if (scm-eq? (tokenizer 'peek) '*semicolon*)
        (tokenizer 'next))
    expr))

(define (block-expr tokenizer #!optional (use-let #f))
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-brace*))
      (parser-error tokenizer "Missing block start.")
      (begin (enter-scope)
             (tokenizer 'next)
             (let loop ((expr (if use-let (scm-cons 'let (scm-cons '() '())) (scm-cons 'begin '())))
                        (count 0))
               (let ((token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-brace*)
                        (leave-scope)
                        (tokenizer 'next)
                        (if (zero? count) (scm-append expr (scm-list *void*)) expr))
                       ((eof-object? token)
                        (parser-error tokenizer "Unexpected end of input. Missing closing brace?"))
                       (else
                        (loop (scm-append expr (scm-list (expression/statement tokenizer #f)))
                              (+ 1 count)))))))))

(define (safe-cmpr-expr? expr)
  (and (pair? expr)
       (scm-memq (scm-car expr) '(safe-equal? safe-< safe-<= safe-> safe->=))))

(define (cmpr-expr tokenizer)
  (let ((expr (let loop ((expr (addsub-expr tokenizer)))
                (if (cmpr-opr? (tokenizer 'peek))
                    (case (tokenizer 'next)
                      ((*equals*) (loop (swap-operands (scm-append (eq-expr tokenizer) (scm-list expr)))))
                      ((*less-than*) (loop (swap-operands (scm-append (lt-expr tokenizer) (scm-list expr)))))
                      ((*greater-than*) (loop (swap-operands (scm-append (gt-expr tokenizer) (scm-list expr)))))
                      ((*less-than-equals*) (loop (swap-operands (scm-append (lteq-expr tokenizer) (scm-list expr)))))
                      ((*greater-than-equals*) (loop (swap-operands (scm-append (gteq-expr tokenizer) (scm-list expr))))))
                    expr))))
    (if (safe-cmpr-expr? expr)
        (scm-append expr (scm-list #t))
        expr)))

(define (logical-and-expr tokenizer)
  (let loop ((expr (logical-or-expr tokenizer)))
    (if (scm-eq? '*and* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (and-expr tokenizer) (scm-list expr)))))
        expr)))

(define (logical-or-expr tokenizer)
  (let loop ((expr (cmpr-expr tokenizer)))
    (if (scm-eq? '*or* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (or-expr tokenizer) (scm-list expr)))))
        expr)))
  
(define (addsub-expr tokenizer)
  (let loop ((expr (term-expr tokenizer)))
    (if (add-sub-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*plus*) (loop (swap-operands (scm-append (add-expr tokenizer) (scm-list expr)))))
          ((*minus*) (loop (swap-operands (scm-append (sub-expr tokenizer) (scm-list expr))))))
        expr)))

(define (factor-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (scm-eq? token '*open-paren*)
        (begin (tokenizer 'next)
               (let ((expr (expression tokenizer)))
                 (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
                     (begin (parser-error tokenizer "Missing closing parenthesis.")
                            #f)
                     (begin (tokenizer 'next)
                            (member-access/funcall-expr expr tokenizer)))))
        (let ((expr (if-expr tokenizer)))
          (if expr expr
              (let-expr tokenizer))))))

(define (handle-rvar-access sym)
  (if (rvar? sym)
      (scm-list 'scm-rget (normalize-rvar sym))
      sym))

(define (token->neg-number token)
  (if (number? token)
      (string->number (string-append "-" (number->string token)))
      (scm-list '- token)))

(define (literal-expr tokenizer)
  (let ((expr (func-def-expr tokenizer)))
    (if expr
        (member-access/funcall-expr expr tokenizer)
        (let ((token (tokenizer 'peek)))
          (cond ((or (number? token)
                     (string? token)
		     (char? token))
                 (slgn-repr->scm-repr (tokenizer 'next)))
                ((add-sub-opr? token)
                 (tokenizer 'next)
                 (let ((sub (scm-eq? token '*minus*))
                       (next (tokenizer 'peek)))
                   (if sub
                       (if (or (number? next) 
                               (valid-identifier? next))
                           (begin (tokenizer 'next)
                                  (token->neg-number next))
                           (scm-list '- (expression tokenizer)))
                       (expression tokenizer))))                       
                ((valid-identifier? token) (handle-symbol token tokenizer))
                ((scm-eq? token '*open-bracket*)
                 (list-literal tokenizer))
                ((scm-eq? token '*open-brace*)
                 (block-expr tokenizer (scm-not (tokenizer 'macro-mode?))))
                ((scm-eq? token '*hash*)
                 (array-or-table-literal tokenizer))
		((scm-eq? token '*quasiquote*)
		 (tokenizer 'next)
                 (let ((already-in-quote-mode (tokenizer 'quote-mode?)))
                   (tokenizer 'quote-mode-on)
                   (let ((e (expression tokenizer)))
                     (tokenizer 'quote-mode-off)
                     (if (scm-not already-in-quote-mode) (scm-list 'quasiquote e) e))))
                ((scm-eq? token '*unquote*)
                 (if (scm-not (tokenizer 'quote-mode?))
                     (parser-error tokenizer "Not in quote mode."))
                 (tokenizer 'next)
                 (let ((splice? (if (scm-eq? (tokenizer 'peek) '*quasiquote*)
                                    (begin (tokenizer 'next) #t)
                                    #f)))
                   (scm-list (if splice? 'unquote-splicing 'unquote) (func-body-expr tokenizer #f))))
                ((scm-eq? token '*quote*)
                 (tokenizer 'next)
                 (let ((sym (tokenizer 'peek)))
                   (if (scm-not (symbol? sym))
                       (parser-error tokenizer "Expected symbol."))
                   (tokenizer 'next)
                   (if (tokenizer 'quote-mode?) sym
                       (scm-list 'quote sym))))
		((symbol? token) (handle-symbol token tokenizer))
                (else (parser-error tokenizer "Invalid literal expression.")))))))

(define (handle-symbol token tokenizer)
  (cond ((scm-eq? token '?)                        
	 (tokenizer 'next)
	 (scm-list 'scm-rvar))
	(else (let ((var (tokenizer 'next)))
		(if (scm-eq? (tokenizer 'peek) '*period*)
		    (begin (tokenizer 'next)
			   (closure-member-access var tokenizer))
		    (handle-rvar-access (slgn-repr->scm-repr var)))))))

(define (member-access/funcall-expr expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*period*)
         (begin (tokenizer 'next)
                (closure-member-access expr tokenizer)))
        ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (func-call-expr expr tokenizer))
        (else expr)))

(define (list-literal tokenizer)
  (tokenizer 'next)
  (let loop ((result (if (tokenizer 'quote-mode?) 
                         (list) 
                         (scm-list 'list))))
    (let ((token (tokenizer 'peek)))
      (if (scm-eq? token '*close-bracket*)
          (begin (tokenizer 'next)
                 (scm-reverse result))
          (let ((expr (expression tokenizer)))
            (if (scm-eq? (tokenizer 'peek) '*pipe*)
                (begin (tokenizer 'next)
                       (list-comprehension-expr tokenizer expr))
                (begin (assert-comma-separator tokenizer '*close-bracket*)
                       (loop (scm-cons expr result)))))))))

(define (list-comprehension-expr tokenizer result-expr)
  (let ((vars-lists-filters 
         (let loop ((vars '())
                    (lists '())
                    (filters '()))
           (let ((var (tokenizer 'next))
                 (extractor (tokenizer 'next)))
             (if (and (symbol? var)
                      (scm-eq? '*extractor* extractor))
		 (begin (check-if-reserved-name var tokenizer)
			(let ((lists (scm-cons (expression tokenizer) lists))
			      (vars (scm-cons var vars))
			      (filters (scm-cons (if (scm-eq? (tokenizer 'peek) 'where)
						 (begin (tokenizer 'next)
							(expression tokenizer))
						 #t)
					     filters)))
			  (assert-comma-separator tokenizer '*close-bracket*)
			  (loop vars lists filters)))
                 (begin (tokenizer 'put extractor)
                        (tokenizer 'put var)
                        (scm-list (scm-reverse vars) (scm-reverse lists) 
                              (scm-reverse filters))))))))
    (let ((expr (list-comprehension (scm-cadr vars-lists-filters) 
                                    (scm-car vars-lists-filters) 
                                    (scm-caddr vars-lists-filters) 
                                    result-expr)))
      (let ((t (tokenizer 'next)))
        (if (scm-not (scm-eq? t '*close-bracket*))
            (parser-error tokenizer "Expected closing bracket.")))
      expr)))
                    
(define (array-prefix? prefix tokenizer) 
  (or (scm-eq? prefix 'u8)
      (scm-eq? prefix 's8)
      (scm-eq? prefix 'b)
      (scm-eq? prefix 'v)
      (scm-eq? prefix 'u16)
      (scm-eq? prefix 's16)
      (scm-eq? prefix 'u32)
      (scm-eq? prefix 's32)
      (scm-eq? prefix 'u64)
      (scm-eq? prefix 's64)
      (scm-eq? prefix 'f32)
      (scm-eq? prefix 'f64)))

(define (array-prefix->constructor prefix)
  (case prefix
    ((v) 'scm-vector)
    ((u8) 'scm-u8vector)
    ((s8) 'scm-s8vector)
    ((u16) 'scm-u16vector)
    ((s16) 'scm-s16vector)
    ((u32) 'scm-u32vector)
    ((s32) 'scm-s32vector)
    ((u64) 'scm-u64vector)
    ((s64) 'scm-s64vector)
    ((f32) 'scm-f32vector)
    ((f64) 'scm-f64vector)
    (else 'bit_array)))

(define (array-literal tokenizer)
  (let ((prefix (tokenizer 'peek)))
    (if (array-prefix? prefix tokenizer)
        (tokenizer 'next)
        (set! prefix 'v))
    (if (scm-eq? (tokenizer 'peek) '*open-bracket*)
        (begin (tokenizer 'next)
               (let loop ((expr (scm-list (array-prefix->constructor prefix)))
                          (token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-bracket*)
                        (tokenizer 'next)
                        (scm-reverse expr))
                       (else (let ((e (expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-bracket*)
                               (loop (scm-cons e expr) (tokenizer 'peek)))))))
        (parser-error tokenizer "Invalid start of array literal."))))

(define (table-literal tokenizer)
  (tokenizer 'next)
  (let loop ((expr '(let ((*table* (make_equal_hashtable))))))
    (if (scm-eq? (tokenizer 'peek) '*close-brace*)
        (begin (tokenizer 'next)
               (scm-append expr '(*table*)))
        (let ((keyval (expression tokenizer)))
          (if (scm-not (and (pair? keyval)
                        (scm-eq? (scm-car keyval) 'scm-cons)))
              (parser-error tokenizer "Key-value must be a pair.")
              (begin (assert-comma-separator tokenizer '*close-brace*)
                     (loop (scm-append expr (scm-list `(hashtable_set *table* ,(scm-cadr keyval) ,(scm-caddr keyval)))))))))))
    
(define (array-or-table-literal tokenizer)
  (tokenizer 'next)
  (if (scm-eq? (tokenizer 'peek) '*open-brace*)
      (table-literal tokenizer)
      (array-literal tokenizer)))

(define (let-expr tokenizer)
  (enter-scope)
  (let ((expr (let ((letkw (letkw? (tokenizer 'peek))))
		(if letkw
		    (begin (tokenizer 'next)
			   (if (valid-identifier? (tokenizer 'peek))
			       (named-let-expr letkw tokenizer)
			       (normal-let-expr letkw tokenizer)))
		    (func-call-expr (literal-expr tokenizer) tokenizer)))))
    (leave-scope)
    expr))

(define (normal-let-expr letkw tokenizer)
  (scm-list letkw (let-bindings tokenizer) (func-body-expr tokenizer #f)))

(define (named-let-expr letkw tokenizer)
  (if (scm-not (scm-eq? letkw 'let))
      (parser-error tokenizer (string-append "Cannot define "
                                             (symbol->string letkw)
                                             " as a named let.")))
  (let ((name (tokenizer 'next)))
    (remove-macro-lazy-fns-def name)
    (scm-list letkw name (let-bindings tokenizer) (func-body-expr tokenizer #f))))

(define (let-bindings tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "Expected let variable bindings list."))
  (let loop ((token (tokenizer 'next))
	     (bindings '()))
    (cond ((scm-eq? token '*close-paren*)
	   bindings)
	  ((symbol? token)
           (let ((unqoute? (scm-eq? token '*unquote*)))
             (if unqoute?
                 (if (scm-not (tokenizer 'quote-mode?))
                     (parser-error tokenizer "Not in quote mode.")
                     (set! token (tokenizer 'next))))
             (check-if-reserved-name token tokenizer)
             (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
                 (parser-error tokenizer "Expected assignment."))
             (if (scm-not unqoute?) (remove-macro-lazy-fns-def token))
             (let ((expr (func-body-expr tokenizer #f)))
               (let ((next (tokenizer 'peek)))
                 (if (scm-eq? next '*comma*) 
                     (tokenizer 'next)))
               (loop (tokenizer 'next) (scm-append bindings (scm-list (scm-list (if unqoute? (scm-list 'unquote token) token) expr)))))))
	  (else (parser-error tokenizer "Expected variable declaration.")))))

(define (letkw? sym)
  (if (and (symbol? sym)
	   (or (scm-eq? sym 'let)
	       (scm-eq? sym 'letseq)
	       (scm-eq? sym 'letrec)))
      (cond ((scm-eq? sym 'letseq)
             'let*)
            (else sym))
      #f))

(define (func-def-expr tokenizer)
  (if (func-def? (tokenizer 'peek))
      (begin (tokenizer 'next)
             (let* ((params (func-params-expr tokenizer))
                    (body-expr (func-body-expr tokenizer params)))
	       (merge-lambda tokenizer params body-expr)))
      #f))

(define (merge-lambda tokenizer params lambda-body)
  (let ((expr (let ((lambda-expr (scm-list 'lambda params)))
                (if (scm-not (list? lambda-body))
                    (set! lambda-body (scm-list 'begin lambda-body)))
                (if (<= 1 (scm-length lambda-body))
                    (scm-append lambda-expr (scm-list lambda-body))
                    (let loop ((lambda-expr lambda-expr)
                               (lambda-body (if (scm-eq? (scm-car lambda-body) 'begin)
                                                (scm-cdr lambda-body)
                                                lambda-body)))
                      (if (null? lambda-body)
                          lambda-expr
                          (loop (scm-append lambda-expr (scm-list (scm-car lambda-body)))
                                (scm-cdr lambda-body))))))))
    (if (> (tokenizer 'yield-count) 0)
        (tokenizer 'reset-yield-count))
    expr))

(define (wrap-in-return-cont expr)
  `(call/cc (lambda (*return*)
              (let ((*yield-obj* (make-s-yield #f *return*)))
                (begin ,expr
                       (let ((*r* (s-yield-k *yield-obj*)))
                         (s-yield-fn-set! *yield-obj* #f)
                         (*r* *yield-obj*)))))))

(define (func-body-expr tokenizer params #!optional (use-let #f))
  (let ((old-yield-count (tokenizer 'yield-count)))
    (let ((body-expr
           (let ((token (tokenizer 'peek)))
             (if (or (scm-eq? token '*semicolon*) 
                     (eof-object? token))
                 '(begin (quote ()))
                 (begin (enter-scope)
                        (push-func-params params)
                        (let ((expr (if (scm-eq? (tokenizer 'peek) '*open-brace*)
                                        (block-expr tokenizer use-let)
                                        (let ((expr (statement tokenizer)))
                                          (if (scm-not expr)
                                              (expression tokenizer)
                                              expr)))))
                          (leave-scope)
                          expr))))))
      (if (and params (> (tokenizer 'yield-count) old-yield-count))
          (wrap-in-return-cont body-expr)
          body-expr))))

(define (func-call-expr func-val tokenizer)
  (if (and (symbol? func-val)
           (check-if-reserved-name func-val tokenizer)
           (get-macro-def func-val)
           (scm-not (tokenizer 'pattern-mode?)))
      (macro-call-expr func-val tokenizer)
      (let ((lazy-fn (get-lazy-def func-val)))
        (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
               (if (and (symbol? func-val)
                        (check-if-reserved-name func-val tokenizer)
                        (tokenizer 'pattern-mode?))
                   (let ((s (symbol->string func-val)))
                     (set! func-val (string->symbol (string-append "+" s)))))
               (tokenizer 'next)
               (let ((expr (mk-func-call-expr tokenizer func-val lazy-fn)))
                 (cond ((scm-eq? (tokenizer 'peek) '*close-paren*)
                        (tokenizer 'next) 
                        (if (scm-eq? (tokenizer 'peek) '*period*)
                            (member-access/funcall-expr expr tokenizer)
                            expr))
                       (else (parser-error tokenizer "Missing closing parenthesis after function argument list.")))))
              (else func-val)))))

(define (mk-func-call-expr tokenizer func-val lazy-fn)
  (let ((expr (func-args-expr tokenizer lazy-fn)))
    (if (and (scm-not (null? expr)) (scm-not lazy-fn) 
             (scm-eq? func-val 'task))
        (if (or (scm-not (list? (scm-car expr))) 
                (scm-not (scm-eq? (scm-caar expr) 'lambda)))
            (set! expr (scm-cons (merge-lambda tokenizer '() (scm-car expr)) (scm-cdr expr)))))
    (scm-cons func-val expr)))

(define (macro-args-list tokenizer)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-not (scm-eq? token '*close-paren*))
          (let ((expr (func-body-expr tokenizer #f #t)))
            (assert-comma-separator tokenizer '*close-paren*)
            (loop (scm-append args (scm-list expr))))
          args))))

(define (macro-call-expr macro-name tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing macro argument list.")
      (tokenizer 'next))
  (let ((args (func-args-expr tokenizer #f)))
    (if (scm-not (scm-eq? '*close-paren* (tokenizer 'next)))
        (parser-error tokenizer "Missing closing parenthesis after macro argument list."))
    (expand-macro macro-name args)))

(define (expand-macro macro-name args)
  (let ((expr (scm-apply (scm-eval macro-name) args)))
    (if (pair? expr)
        (let loop ((expr expr)
                   (result '()))
          (cond
           ((null? expr) (scm-reverse result))
           ((pair? (scm-car expr))
            (if (get-macro-def (scm-caar expr))
                (loop (scm-cdr expr) (scm-cons (expand-macro (scm-caar expr) (scm-cdar expr)) result))
                (loop (scm-cdr expr) (scm-cons (scm-car expr) result))))
           (else (loop (scm-cdr expr) (scm-cons (scm-car expr) result)))))
        expr)))              

(define (record-def-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'record)
      (begin (tokenizer 'next)
	     (let ((token (tokenizer 'peek)))
	       (if (scm-not (valid-identifier? token))
		   (parser-error tokenizer "Missing record name."))
	       (mk-record-expr (tokenizer 'next) tokenizer)))
      (macro-def-stmt tokenizer)))

(define (rec-get-precond tokenizer)
  (tokenizer 'next)
  (let ((precond (expression tokenizer)))
    (assert-comma-separator tokenizer '*close-paren*)
    precond))
  
(define (rec-get-field-def tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*assignment*)
         (tokenizer 'next)
         (let ((val (expression tokenizer)))
           (if (scm-eq? (tokenizer 'peek) 'where)
               (scm-cons val (rec-get-precond tokenizer))
               (begin (assert-comma-separator tokenizer '*close-paren*)
                      (scm-cons val #t)))))
        (else
         (if (scm-eq? (tokenizer 'peek) 'where)
             (scm-cons #f (rec-get-precond tokenizer))
             (begin (assert-comma-separator tokenizer '*close-paren*)
                    (scm-cons #f #t))))))
  
(define (mk-record-expr name tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((token (tokenizer 'peek))
                    (members '()) (default-values '())
                    (preconds '()))
           (cond ((valid-identifier? token)
                  (let ((token (tokenizer 'next))
                        (fdef (rec-get-field-def tokenizer)))
                    (loop (tokenizer 'peek) (scm-cons token members)
                          (scm-cons (scm-car fdef) default-values) 
                          (scm-cons (scm-cdr fdef) preconds))))
                 ((scm-eq? token '*close-paren*)
                  (tokenizer 'next)
                  (def-struct-expr name (scm-reverse members) (scm-reverse default-values) (scm-reverse preconds)))
                 (else (parser-error tokenizer "Invalid record specification.")))))
        (else (parser-error tokenizer "Expected record member specification."))))

(define (def-struct-expr name members default-values preconds)
  (scm-append (scm-list 'begin (scm-append (scm-list 'define-structure name) members))
	  (mk-struct-accessors/modifiers name members default-values preconds)))

(define (mk-record-precond-expr precond mem)
  (scm-list 'if (scm-list 'not precond) (scm-list 'error (with-output-to-string 
                                               '()
                                               (lambda () 
                                                 (scm-display "Precondition failed: ")
                                                 (scm-display precond)
                                                 (scm-display ".")))
                                      mem)))

(define (mk-record-precond-exprs preconds mems)
  (let loop ((preconds preconds) (mems mems) (result '()))
    (if (null? preconds) (scm-append (scm-list 'begin) (scm-reverse result))
        (loop (scm-cdr preconds) (scm-cdr mems)
              (scm-cons (mk-record-precond-expr (scm-car preconds) (scm-car mems)) result)))))
        
(define (mk-record-constructor recname members default-values preconds)
  (scm-append (scm-list 'lambda (scm-append (scm-list '#!key) (mk-record-constructor-params members default-values)))
          (scm-list (mk-record-precond-exprs preconds members) 
                (scm-cons (string->symbol (string-append "make-" (add-namespace-prefix recname))) members))))

(define (mk-record-constructor-params members default-values)
  (let loop ((members members) (default-values default-values) 
             (params '()))
    (cond ((null? members) (scm-reverse params))
          (else (loop (scm-cdr members) (scm-cdr default-values)
                      (scm-cons (scm-list (scm-car members) 
                                  (scm-car default-values)) params))))))

(define (mk-struct-accessors/modifiers name members default-values preconds)
  (let ((sname (symbol->string name)))
    (let loop ((members members)
               (preconds preconds)
               (i 0)
               (expr (scm-list 
                      (scm-list 'define (string->symbol sname) 
                            (mk-record-constructor sname members default-values preconds))
                      (scm-list 'define (string->symbol (string-append "make_" sname))
                            (string->symbol (string-append "make-" (add-namespace-prefix sname))))
                      (scm-list 'define 
                            (string->symbol (string-append "is_" sname))
                            (string->symbol (add-namespace-prefix (string-append sname "?")))))))
      (if (null? members) (scm-reverse expr)
          (begin (loop (scm-cdr members) (scm-cdr preconds) (+ i 1)
                       (scm-append expr (member-accessor/modifier name (scm-car members) (scm-car preconds) i))))))))

(define (member-accessor/modifier name mem precond index)
  (let ((sname (symbol->string name))
	(smem (symbol->string mem)))
    (let ((scm-accessor (string->symbol (add-namespace-prefix (string-append sname "-" smem))))
	  (scm-modifier (string->symbol (add-namespace-prefix (string-append sname "-" smem "-set!"))))
	  (slgn-accessor (string->symbol (string-append sname "_" smem)))
          (idx-accessor (string->symbol (string-append sname "-" (number->string index))))
	  (slgn-modifier (string->symbol (string-append sname "_set_" smem))))
      (scm-list (scm-list 'define slgn-accessor scm-accessor)
            (scm-list 'define idx-accessor scm-accessor)
	    (scm-list 'define slgn-modifier (scm-append (scm-list 'lambda (scm-list '*s* mem)) 
                                                (scm-append (scm-list (mk-record-precond-expr precond mem))
                                                        (scm-list (scm-list scm-modifier '*s* mem)))))))))

(define (assert-comma-separator tokenizer end-seq-char #!optional comma-required)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*comma*)
            (if (list? end-seq-char) 
                (scm-memq token end-seq-char) 
                (scm-eq? token end-seq-char)))
        (if (scm-eq? token '*comma*) (tokenizer 'next))
        (if comma-required
            (parser-error tokenizer (with-output-to-string
                                      '()
                                      (lambda ()
                                        (scm-display "Missing comma or ") 
                                        (slgn-display end-seq-char) 
                                        (scm-display "."))))))))

(define (func-args-expr tokenizer lazy-fn)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-not (scm-eq? token '*close-paren*))
          (cond ((valid-identifier? token)
                 (let ((sym (tokenizer 'next)))
                   (if (scm-eq? (tokenizer 'peek) '*assignment*)
                       (begin (tokenizer 'next)
                              (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (scm-append args (scm-list (slgn-variable->scm-keyword sym) expr)))))
                       (begin (tokenizer 'put sym)
                              (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (scm-append args (scm-list expr))))))))
                (else
                 (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                   (assert-comma-separator tokenizer '*close-paren*)
                   (loop (scm-append args (scm-list expr))))))
          args))))

(define (check-if-reserved-name sym tokenizer)
  (if (or (reserved-name? sym)
	  (is_special_token sym))
      (parser-error tokenizer (string-append "Invalid use of keyword or operator: "
                                             (symbol->string sym) ".") sym)
      sym))

(define (valid-identifier? sym)
  (and (symbol? sym)
       (scm-not (or (reserved-name? sym)
		(is_special_token sym)))))
  
(define (check-func-param tokenizer) 
  (check-if-reserved-name (tokenizer 'peek) tokenizer)
  (tokenizer 'next))

(define (func-params-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((params '())
                    (directives-found #f))
           (let ((token (tokenizer 'peek)))
             (cond ((valid-identifier? token)
                    (let ((sym (check-func-param tokenizer)))
                      (cond ((param-directive? sym)
                             (loop (scm-cons (slgn-directive->scm-directive sym) params) #t))
                            ((scm-eq? (tokenizer 'peek) '*assignment*)
                             (tokenizer 'next)
                             (let ((expr (expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-paren*)
                               (if directives-found
                                   (loop (scm-cons (scm-list sym expr) params) directives-found)
				   (loop (scm-cons 
					  (scm-list sym expr) 
					  (scm-cons 
					   (slgn-directive->scm-directive '@optional) params)) 
					 #t))))
                            (else 
                             (assert-comma-separator tokenizer '*close-paren*)
                             (loop (scm-cons sym params) directives-found)))))
                   ((scm-eq? '*unquote* token)
                    (if (scm-not (tokenizer 'quote-mode?))
                        (parser-error tokenizer "Not in quote more.")
                        (begin (assert-comma-separator tokenizer '*close-paren*)
                               (loop (scm-cons (expression tokenizer) params)
                                     directives-found))))
                   (else
                    (if (scm-eq? token '*close-paren*)
                        (begin (tokenizer 'next)
                               (scm-reverse params))
                        (parser-error tokenizer "Missing closing parenthesis after parameter list.")))))))
        ((valid-identifier? (tokenizer 'peek))
         (check-func-param tokenizer))
        (else 
         (parser-error tokenizer "Missing opening parenthesis at the start of parameter list."))))

(define (param-directive? sym)
  (scm-memq sym '(@optional @key @rest)))

(define (closure-member-access var tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (let loop ((expr `(,var ',(tokenizer 'next))))
	(if (scm-eq? (tokenizer 'peek) '*period*)
	    (begin (tokenizer 'next)
		   (if (valid-identifier? (tokenizer 'peek))
		       (loop (scm-cons expr `(',(tokenizer 'next))))
		       (parser-error tokenizer "Expected identifier.")))
	    expr))
      (parser-error tokenizer "Expected identifier.")))

(define (add-expr tokenizer)
  (swap-operands (scm-cons '+ (scm-list (term-expr tokenizer)))))

(define (sub-expr tokenizer)
  (swap-operands (scm-cons '- (scm-list (term-expr tokenizer)))))

(define (mult-expr tokenizer)
  (swap-operands (scm-cons '* (scm-list (factor-expr tokenizer)))))

(define (div-expr tokenizer)
  (swap-operands (scm-cons '/ (scm-list (factor-expr tokenizer)))))

(define (eq-expr tokenizer)
  (swap-operands (scm-cons 'safe-equal? (scm-list (addsub-expr tokenizer)))))

(define (lt-expr tokenizer)
  (swap-operands (scm-cons 'safe-< (scm-list (addsub-expr tokenizer)))))

(define (lteq-expr tokenizer)
  (swap-operands (scm-cons 'safe-<= (scm-list (addsub-expr tokenizer)))))

(define (gt-expr tokenizer)
  (swap-operands (scm-cons 'safe-> (scm-list (addsub-expr tokenizer)))))

(define (gteq-expr tokenizer)
  (swap-operands (scm-cons 'safe->= (scm-list (addsub-expr tokenizer)))))

(define (and-expr tokenizer)
  (swap-operands (scm-cons 'and (scm-list (logical-or-expr tokenizer)))))

(define (or-expr tokenizer)
  (swap-operands (scm-cons 'or (scm-list (cmpr-expr tokenizer)))))

(define (term-expr tokenizer)
  (let loop ((expr (factor-expr tokenizer)))
    (if (mult-div-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*asterisk*) (loop (swap-operands (scm-append (mult-expr tokenizer) (scm-list expr)))))
          ((*backslash*) (loop (swap-operands (scm-append (div-expr tokenizer) (scm-list expr))))))
        expr)))

(define (add-sub-opr? token)
  (or (scm-eq? token '*plus*)
      (scm-eq? token '*minus*)))

(define (mult-div-opr? token)
  (or (scm-eq? token '*asterisk*)
      (scm-eq? token '*backslash*)))

(define (cmpr-opr? token)
  (or (scm-eq? token '*equals*)
      (scm-eq? token '*less-than*)
      (scm-eq? token '*greater-than*)
      (scm-eq? token '*less-than-equals*)
      (scm-eq? token '*greater-than-equals*)))

(define (and-or-opr? token)
  (or (scm-eq? token '*and*)
      (scm-eq? token '*or*)))

(define (swap-operands expr)
  (if (= 3 (scm-length expr))
      (scm-list (scm-car expr) (scm-caddr expr) (scm-cadr expr))
      expr))

(define *reserved-names* '(fn function method define record true false
			      if else when let letseq letrec yield
			      case match where try trycc catch finally
                              macro namespace import declare))

(define (reserved-name? sym)
  (and (symbol? sym)
       (scm-memq sym *reserved-names*)))

(define (parened-names->list tokenizer)
  (if (scm-eq? (tokenizer 'next) '*open-paren*)
      (let loop ((token (tokenizer 'next))
                 (result '()))
        (cond ((scm-eq? token '*close-paren*)
               (scm-reverse result))
              ((valid-identifier? token)
               (assert-comma-separator tokenizer '*close-paren*)
               (loop (tokenizer 'next) (scm-cons token result)))
              (else #f)))
      #f))
