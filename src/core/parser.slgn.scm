;; Copyright (c) 2013-2016 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define-structure s-yield fn k)

(define (slogan tokenizer)
  (let ((expr (expression/statement tokenizer)))
    (if (> (tokenizer 'yield-count) 0)
        (begin (reset-yield-count! tokenizer 0)
               (error "yield can be called only from a function."))
        expr)))

(define (expression/statement tokenizer #!optional (top #t))
  (if (eof-object? (tokenizer 'peek))
    (tokenizer 'next)
    (let ((v (statement tokenizer)))
      (if (scm-not v) (set! v (expression tokenizer)))
      (assert-semicolon tokenizer)
      v)))

(define (statement tokenizer)
  (sanitize-expression
   tokenizer
   (if (scm-eq? (tokenizer 'peek) '*semicolon*) *void*
       (declare-stmt tokenizer))))

(define (highlighted-line colno)
  (if (< colno 0)
      (set! colno 1))
  (with-output-to-string
    '()
    (lambda ()
      (let loop ((n 0))
	(if (= n colno) (scm-display #\^)
	    (begin (scm-display #\space)
		   (loop (+ n 1))))))))

(define (highlighted-error-line tokenizer #!optional token)
  (let ((curr-tok-len (current-token-length tokenizer))
        (tlen (if token
                  (string-length (if (symbol? token) (symbol->string token) token))
                  0)))
    (let loop ((line-no (tokenizer 'line)) 
               (n 1)
               (program-text (tokenizer 'program-text)))
      (if (scm-not (null? program-text))
          (if (= n line-no)
              (scm-cons (scm-car program-text) (highlighted-line (tokenizer 'column)))
              (loop line-no (+ n 1) (scm-cdr program-text)))
          #f))))

(define (parser-error tokenizer msg #!optional token)
  (error (with-output-to-string 
           '()
           (lambda ()
             (if tokenizer
                 (scm-println "at [line: "(tokenizer 'line) 
                          ", column: " (tokenizer 'column) "] " 
                          msg))
             (let ((hl (highlighted-error-line tokenizer token)))
               (if hl (begin (scm-println (scm-car hl))
                             (scm-println (scm-cdr hl)))))))))

(define (assert-semicolon tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*semicolon*)
            (scm-eq? token '*close-brace*)
            (eof-object? token))
        (if (scm-eq? token '*semicolon*)
            (tokenizer 'next))
        (parser-error tokenizer "Statement or expression not properly terminated."))))

(define (declare-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'declare)
      (begin (tokenizer 'next)
             (let ((name (tokenizer 'next)))
               (case name
                 ((generic) (declare-generic-stmt tokenizer))
                 ((ffi) (declare-ffi-stmt tokenizer))
                 (else
                  (parser-error tokenizer "Invalid declare type.")))))
      (func-def-stmt tokenizer)))

(define (normalize-c-struct-members memtypes)
  (scm-map (lambda (m) (scm-cons (scm-cadr m) (scm-caddr m))) memtypes))

(define (c-struct-stmt tokenizer)
  (let ((struct-name (tokenizer 'next)))
    (if (scm-not (symbol? struct-name))
        (parser-error tokenizer "Struct name must be a symbol." struct-name)
        (let ((memtypes (expression tokenizer)))
          (if (scm-not (scm-eq? (scm-car memtypes) 'scm-list))
              (parser-error tokenizer "Struct member types must be a list." memtypes)
              `(def-c-struct ',struct-name ',(normalize-c-struct-members (scm-cdr memtypes))))))))

(define (c-fn-stmt tokenizer rettype libname)
  (let ((fn-name (tokenizer 'next)))
    (if (scm-not (symbol? fn-name))
        (parser-error tokenizer "Function name must be a symbol." fn-name)
        (let ((paramtypes (expression tokenizer)))
          (if (scm-not (pair? paramtypes))
              (parser-error tokenizer "Expected parameter list."))
          (if (scm-not (scm-eq? (scm-car paramtypes) 'scm-list))
              (parser-error tokenizer "Parameter types must be a list." paramtypes)
              (let ((name fn-name))
                (if (scm-eq? (tokenizer 'peek) 'as)
                    (begin (tokenizer 'next)
                           (set! name (tokenizer 'next))
                           (if (scm-not (symbol? name))
                               (parser-error tokenizer "Function local name must be a symbol." name))))
                (def-c-fn libname fn-name name (scm-cdr paramtypes) rettype)))))))
                
(define (cdef-stmt tokenizer libname)
  (let ((token (tokenizer 'next)))
    (if (scm-eq? token 'struct)
        (c-struct-stmt tokenizer)
        (c-fn-stmt tokenizer token libname))))

(define (def-ffi tokenizer libname expr)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-bracket*))
      (parser-error tokenizer "FFI definitions must be within a list.")
      (let loop ((defs '()))
        (if (scm-eq? (tokenizer 'peek) '*close-bracket*)
            (begin (tokenizer 'next)
                   (scm-append expr (scm-reverse defs)))
            (let ((cdef (cdef-stmt tokenizer libname)))
              (assert-comma-separator tokenizer '*close-bracket*)
              (loop (scm-cons cdef defs)))))))

(define *ffi-lib-count* 0)
(define (genffisym)
  (let ((s (string-append "*ffi-" (number->string *ffi-lib-count*) "-*")))
    (set! *ffi-lib-count* (+ *ffi-lib-count* 1))
    (string->symbol s)))

(define (declare-ffi-stmt tokenizer)
  (let ((libname (tokenizer 'next)))
    (if (scm-not (or (string? libname)
                 (symbol? libname)))
        (parser-error tokenizer "Invalid library name - " libname)
        (let ((lname (genffisym)))
          (def-ffi tokenizer lname `(begin (define ,lname (if (string? ,libname)
                                                              (ffi_open ,libname)
                                                              ,libname))))))))
(define (declare-generic-stmt tokenizer)
  (let ((name (tokenizer 'next)))
    (if (valid-identifier? name)
        (define-generic-method name tokenizer)
        (parser-error tokenizer "Expected a valid generic method name."))))

(define (define-generic-method name tokenizer)
  (check-if-reserved-name name tokenizer)
  (let ((params (scm-car (func-params-expr tokenizer #t))))
    (let ((generic-expr
	   `(define ,name 
	      (lambda ,params
	      (error "Method not defined.")))))
      (if (scm-eq? (tokenizer 'peek) '*pipe*)
	  `(begin ,generic-expr ,@(generic-cases-expr tokenizer name params))
	  generic-expr))))

(define (generic-cases-expr tokenizer name params)
  (tokenizer 'next)
  (let loop ((types (method-types-decl tokenizer))
	     (method-defs '())
	     (found-else #f))
    (if (scm-not (scm-eq? (tokenizer 'next) '*inserter*))
	(parser-error tokenizer "Missing -> after types expression."))
    (let* ((body-expr (func-body-expr tokenizer params))
           (mdef (scm-cons types (scm-list 'define name (merge-lambda 
                                                          tokenizer params 
                                                          body-expr)))))
      (cond ((scm-eq? (tokenizer 'peek) '*pipe*)
	     (tokenizer 'next)
	     (cond ((scm-eq? (tokenizer 'peek) 'else)
		    (tokenizer 'next)
		    (loop
		     '()
		     (scm-cons (mk-method-def mdef) method-defs)
		     #t))
		   (else
		    (loop (method-types-decl tokenizer)
			  (scm-cons (mk-method-def mdef) method-defs) #f))))
	    (found-else
	     (scm-cons (mk-method-def mdef) (scm-reverse method-defs)))
	    (else
	     (scm-reverse (scm-cons (mk-method-def mdef) method-defs)))))))

(define (func-def-stmt-with-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (let ((has-name? (not (eq? name '*open-paren*))))
      (if has-name?
          (begin
            (check-if-reserved-name name tokenizer)
            (tokenizer 'next)))
      (let* ((params (scm-car (func-params-expr tokenizer #t)))
             (body-expr (func-body-expr tokenizer params))
             (fexpr (merge-lambda tokenizer params body-expr)))
        (if has-name?
            (scm-list 'define name fexpr)
            fexpr)))))

(define (func-def-stmt tokenizer)
  (cond ((eq? 'function (tokenizer 'peek))
         (tokenizer 'next)
	 (func-def-stmt-with-name tokenizer))
	((eq? '*fn* (tokenizer 'peek))
	 (func-def-expr tokenizer))
        (else (method-def-stmt tokenizer))))

(define (method-types-decl tokenizer)
  (if (scm-not (scm-eq? '*open-paren* (tokenizer 'next)))
      (parser-error tokenizer "Types declaration must start with opening parenthesis."))
  (let ((types-decl (func-args-expr tokenizer)))
    (if (scm-not (scm-eq? '*close-paren* (tokenizer 'next)))
        (parser-error tokenizer "Missing closing parenthesis after type declaration."))
    (if (scm-not (for_all symbol? types-decl))
        (parser-error tokenizer "Invalid type declaration."))
    types-decl))

(define (mk-predic-name psym)
  (if (scm-eq? psym '_)
      'is_object
      (string->symbol 
       (string-append 
        "is_" 
        (symbol->string psym)))))

(define (mk-method-types-chk types args)
  (let loop ((types types)
             (args args)
             (chk-expr '()))
    (if (null? types) (scm-append (scm-list 'and) (scm-reverse chk-expr))
        (let ((type-name (scm-car types)))
          (if (scm-eq? type-name '@rest)
              (loop (cddr types)
                    (scm-cdr args)
                    (scm-cons `(for_all ,(mk-predic-name (scm-cadr types)) ,(scm-car args)) chk-expr))
              (loop (scm-cdr types) 
                    (scm-cdr args) 
                    (scm-cons `(,(mk-predic-name (scm-car types)) ,(scm-car args)) chk-expr)))))))

(define (params->args params)
  (let loop ((params params)
             (args '()))
    (if (null? params)
        (scm-reverse args)
        (cond ((pair? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-caar params) args)))
              ((symbol? (scm-car params))
               (loop (scm-cdr params) (scm-cons (scm-car params) args)))
              (else (loop (scm-cdr params) args))))))

(define (method-def-stmt-from-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (scm-not (valid-identifier? name))
        (parser-error tokenizer "Method must have a valid name."))
    (begin (tokenizer 'next)
	   (let ((pts (func-params-expr tokenizer #t)))
	     (let ((types (scm-cdr pts))
		   (params (scm-car pts)))
	       (let ((body-expr (func-body-expr tokenizer params)))
		 (scm-cons types (scm-list 'define name (merge-lambda 
							 tokenizer params 
							 body-expr)))))))))

(define (method-def-stmt tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'method)
         (tokenizer 'next)
         (mk-method-def (method-def-stmt-from-name tokenizer)))
        (else (record-def-stmt tokenizer))))

(define (types-has-rest? types)
  (member '@rest types))

(define (mk-method-def method-def)
  (let ((func-def (scm-cdr method-def))
	(types (scm-car method-def)))
    (let ((name (scm-cadr func-def))
	  (params (scm-cadr (scm-caddr func-def)))
	  (args (params->args (scm-cadr (scm-caddr func-def))))
	  (body (scm-caddr (scm-caddr func-def))))
      (let ((types-chk (mk-method-types-chk types args))
	    (old-name (string->symbol 
		       (string-append 
			"*" 
			(symbol->string name) 
			"*"))))
        (let ((parent-call (if (types-has-rest? types)
                               `(scm-apply ,old-name ,@args)
                               `(,old-name ,@args))))
          `(set! ,name (let ((,old-name ,name))
                         (lambda ,params 
                           (if ,types-chk 
                             ,body
                             ,parent-call)))))))))

(define (assignment-stmt tokenizer)
  (if (symbol? (tokenizer 'peek))
    (let ((sym (tokenizer 'next)))
      (if (scm-eq? sym 'let)
        (let ((n (tokenizer 'peek)))
          (if (symbol? n)
            (if (eq? '*open-paren* n)
              (begin
                (tokenizer 'put sym)
                (let-expr tokenizer))
              (define-stmt tokenizer))))
        (cond
         ((scm-not (valid-identifier? sym))
          (tokenizer 'put sym)
          #f)
         ((scm-eq? (tokenizer 'peek) '*assignment*)
          (set-stmt sym tokenizer))
         (else
          (tokenizer 'put sym) 
          #f))))
    #f))

(define (vars-defs-set syms exprs def)
  (if (not (= (scm-length syms) (scm-length exprs)))
      (error "Not enough values or variables." syms exprs))
  (let loop ((syms syms) (exprs exprs) (defexprs '()))
    (if (not (null? syms))
        (let ((sym (scm-car syms)))
          (let ((defexpr
                  (if (rvar? sym)
                      (let ((sym (normalize-rvar sym)))
                        (if def
                            `(begin
                               (define ,sym (scm-rvar))
                               (scm-rbind ,sym ,(scm-car exprs)))
                            (scm-list 'scm-rbind sym (scm-car exprs))))
                      (scm-list (if def 'define 'set!) sym (scm-car exprs)))))
            (loop (scm-cdr syms) (scm-cdr exprs) (scm-cons defexpr defexprs))))
        (scm-append '(begin) (scm-reverse defexprs)))))

(define (def-vars-list tokenizer)
  (let loop ((token (tokenizer 'peek))
             (names '()))
    (cond ((eq? token '*assignment*)
           (scm-reverse names))
          ((eq? token '*comma*)
           (tokenizer 'next)
           (loop (tokenizer 'peek) names))
          ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (tokenizer 'next)
           (loop (tokenizer 'peek) (scm-cons token names)))
          (else
           (parser-error tokenizer "Invalid variable name.")))))

(define (def-exprs-list tokenizer)
  (let loop ((e (expression tokenizer))
             (exprs '()))
    (let ((token (tokenizer 'peek)))
      (cond ((eq? token '*comma*)
             (tokenizer 'next)
             (loop (expression tokenizer)
                   (scm-cons e exprs)))
            (else (scm-reverse (scm-cons e exprs)))))))

(define (define-stmt tokenizer)
  (let ((token (tokenizer 'next)))
    (cond
      ((symbol? token)
       (check-if-reserved-name token tokenizer)
       (cond
        ((eq? '*assignment* (tokenizer 'peek))
         (var-def-set token tokenizer #t))
        ((eq? '*comma* (tokenizer 'peek))
         (tokenizer 'next)
         (let ((vars (scm-append (scm-list token) (def-vars-list tokenizer))))
           (if (eq? '*assignment* (tokenizer 'next))
               (let ((exprs (def-exprs-list tokenizer)))
                 (vars-defs-set vars exprs #t))
               (parser-error tokenizer "Expected assignment."))))
        ((eq? '*open-paren* (tokenizer 'peek))
         (tokenizer 'put token)
         (named-let-expr 'let tokenizer))
        (else
         (parser-error tokenizer "Invalid let expression."))))
      (else
       (parser-error tokenizer "Invalid variable name.")))))

(define (set-stmt sym tokenizer) (var-def-set sym tokenizer #f))

(define (normalize-rvar sym)
  (let ((s (symbol->string sym)))
    (string->symbol (substring s 1 (string-length s)))))

(define (rvar? sym)
  (if (symbol? sym) 
      (let ((s (symbol->string sym)))
        (and (> (string-length s) 0)
             (char=? #\? (string-ref s 0))))
      #f))

(define (var-def-set sym tokenizer def)
  (if (scm-eq? (tokenizer 'peek) '*assignment*)
      (begin (tokenizer 'next)
             (if (rvar? sym)
                 (let ((sym (normalize-rvar sym)))
                   (if def
                       `(begin
                          (define ,sym (scm-rvar))
                          (scm-rbind ,sym ,(expression tokenizer)))
                       (scm-list 'scm-rbind sym (expression tokenizer))))
                 (scm-list (if def 'define 'set!) sym (expression tokenizer))))
      (parser-error tokenizer "Expected assignment.")))

(define (expression tokenizer)
  (sanitize-expression tokenizer
   (let ((expr (logical-and-expr tokenizer)))
     (let loop ((expr expr))
       (let ((tok (tokenizer 'peek)))
         (cond ((scm-eq? tok '*open-paren*)
                (loop (func-call-expr expr tokenizer)))
               ((scm-eq? tok '*colon*)
                (pair-literal tokenizer expr))
               (else expr)))))))

(define (pair-literal tokenizer expr)
  (tokenizer 'next)
  (let ((lpair? (scm-eq? (tokenizer 'peek) '*colon*)))
    (if lpair? (tokenizer 'next))
    (let ((tail-expr (if lpair? 
			 `(delay ,(expression tokenizer))
			 (expression tokenizer))))
      `(scm-cons ,expr ,tail-expr))))

(define (then-expr tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
      (parser-error tokenizer "Expected closing parenthesis."))
  (func-body-expr tokenizer #f #t))

(define (if-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'if)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (expression tokenizer)
                                     (then-expr tokenizer)))))
           (if (scm-eq? (tokenizer 'peek) 'else)
               (begin (tokenizer 'next)
                      (if (scm-eq? (tokenizer 'peek) 'if)
                          (scm-append expr (scm-list (if-expr tokenizer)))
                          (scm-append expr (scm-list (func-body-expr tokenizer #f #t)))))
               (scm-append expr '(#f)))))
        (else (when-expr tokenizer))))

(define (when-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'when)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (scm-cons 'if (scm-list (expression tokenizer)
                                     (then-expr tokenizer)))))
           (scm-append expr '(#f))))
        (else (case-expr tokenizer))))

(define (case-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'case)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before case clause."))
         (let ((value (expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after case clause."))
           (let loop ((token (tokenizer 'peek)) (last-expr #f) (body '()))
             (if last-expr (scm-append `(case ,value) (scm-reverse body))
                 (let ((expr (normalize-sym (case-pattern-expression tokenizer))))
                   (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
                       (parser-error tokenizer "Missing -> after case expression.")
                       (tokenizer 'next))
                   (let ((result (func-body-expr tokenizer #f #t))
                         (next (tokenizer 'peek)) (le #f))
                     (if (scm-eq? next '*pipe*)
                         (tokenizer 'next)
                         (set! le #t))
                     (loop (tokenizer 'peek) le
                           (if (and le (scm-not (scm-eq? expr 'else)))
                               (scm-cons '(else #f) (scm-cons (scm-list (if (list? expr) expr (scm-cons expr '())) result) body))
                               (scm-cons (scm-list (if (or (list? expr) (scm-eq? expr 'else)) expr (scm-cons expr '()))
                                                   result) body)))))))))
        (else (match-expr tokenizer))))

(define (case-pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (expression tokenizer)))

(define (pattern-expression tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (begin
	(tokenizer 'pattern-mode-on)
	(let ((expr (expression tokenizer)))
	  (tokenizer 'pattern-mode-off)
	  expr))))

(define (unbound? r) (scm-eq? r '*unbound*))

(define (match-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'match)
         (tokenizer 'next)
         (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before match clause."))
         (let ((value (expression tokenizer)))
           (if (scm-not (scm-eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after match clause."))
           (match-body-expr value tokenizer)))
        (else (try-catch-expr tokenizer))))

(define (match-body-expr value tokenizer)
  (let loop ((token (tokenizer 'peek)) (prev-pattern #f) (last-expr #f) (body '()))
    (if last-expr `(let ((*match-expr* ,value))
                     (let ((*value* *match-expr*)
                           (*orig-value* *match-expr*)
                           (*match-found* #f)
                           (*conv-value* #f)
                           (*result* '*unbound*))
                       ,@(scm-reverse body)
                       (if (unbound? *result*)
                           (error "No match found.")
                           *result*)))
        (let ((pattern (pattern-expression tokenizer))
              (guard #t))
          (if (scm-eq? (tokenizer 'peek) 'where)
              (begin (tokenizer 'next)
                     (set! guard (expression tokenizer))))
          (if (scm-not (scm-eq? (tokenizer 'peek) '*inserter*))
              (parser-error tokenizer "Missing -> after pattern.")
              (tokenizer 'next))
          (let ((consequent (func-body-expr tokenizer #f #t)))
            (if (scm-not (scm-eq? guard #t))
                (set! consequent `(if ,guard 
                                      ,consequent 
                                      (begin (set! *match-found* #f) 
                                             (set! *value* *orig-value*)
                                             '*unbound*))))
            (let ((next (tokenizer 'peek))
                  (le (scm-eq? pattern 'else)))
              (if (scm-eq? next '*pipe*)
                  (if (scm-not le) (tokenizer 'next))
                  (if (scm-not le) (set! le #t)))
              (loop (tokenizer 'peek)
                    (if (scm-eq? pattern '@) prev-pattern pattern) le
                    (scm-cons (match-pattern (if (scm-eq? pattern '@) prev-pattern pattern) consequent) body))))))))

(define (try-catch-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((or (scm-eq? token 'try)
               (scm-eq? token 'trycc))
           (tokenizer 'next)
           (let ((try-expr (stmt-or-expr tokenizer)))
             (case (tokenizer 'peek)
               ((catch)
                (make-try-catch-expr token try-expr (catch-args tokenizer) 
                                     (stmt-or-expr tokenizer) 
                                     (finally-expr tokenizer)))
               ((finally)
                (make-try-catch-expr token try-expr '(*e*) '(raise *e*)
                                     (finally-expr tokenizer)))
               (else (parser-error tokenizer "Expected catch or finally clauses.")))))
          (else (yield-expr tokenizer)))))

(define (catch-args tokenizer)
  (tokenizer 'next)
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing opening parenthesis."))
  (tokenizer 'next)
  (let ((result (tokenizer 'next)))
    (if (scm-not (and (symbol? result)
		  (check-if-reserved-name result tokenizer)))
        (parser-error tokenizer "Missing exception identifier."))
    (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
        (parser-error tokenizer "Missing closing parenthesis."))
    (tokenizer 'next)
    (scm-list result)))

(define (finally-expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) 'finally)
         (tokenizer 'next)
         (stmt-or-expr tokenizer))
        (else *void*)))
      
(define (get-exception-handler-fnname try-token)
  (if (scm-eq? try-token 'try) 'with-exception-catcher 'with-exception-handler))

(define (make-try-catch-expr try-token try-expr catch-args catch-expr finally-expr)
  (let ((try-expr (scm-list (get-exception-handler-fnname try-token)
			(scm-list 'lambda catch-args catch-expr)
			(scm-list 'lambda (scm-list) try-expr))))
    (if (void? finally-expr) try-expr
	(scm-list 'let (scm-list (scm-list '*finally* (scm-list 'lambda (scm-list) finally-expr)))
            (scm-list (get-exception-handler-fnname try-token)
                  (scm-list 'lambda '(*e*) '(begin (*finally*) (raise *e*)))
                  (scm-list 'lambda '() try-expr))
	    '(*finally*)))))

(define (yield-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'yield)
           (tokenizer 'next)
           (tokenizer 'yield-count-up)
           (let ((expr (expression tokenizer)))
             `(call/cc (lambda(*yield*)
                         (let ((*r* (s-yield-k *yield-obj*)))
                           (s-yield-fn-set! *yield-obj* *yield*)
                           (*r* (scm-cons ,expr *yield-obj*)))))))
           (else (assert-stmt tokenizer)))))

(define *assertions-enabled* #t)
(define (enable_asserts flag) (set! *assertions-enabled* flag))

(define (assert-stmt tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token 'assert)
           (tokenizer 'next)
           (let ((expr (expression tokenizer)))
             (let ((msg (if (scm-eq? '*comma* (tokenizer 'peek))
                          (begin (tokenizer 'next)
                                 (expression tokenizer))
                          #f)))
             (if *assertions-enabled*
               `(if (not ,expr)
                  (if ,msg
                    (error ,msg)
                    (error "Assertion failed: " ',expr))) 
               #t))))
          (else #f))))

(define (normalize-sym s)
  (if (and (list? s) (scm-eq? (scm-car s) 'quote))
      (scm-cadr s)
      s))

(define (expression-with-semicolon tokenizer)
  (let ((expr (expression tokenizer)))
    (if (scm-eq? (tokenizer 'peek) '*semicolon*)
        (tokenizer 'next))
    expr))

(define (block-expr tokenizer #!optional (use-let #f))
  (if (scm-not (scm-eq? (tokenizer 'peek) '*open-brace*))
      (parser-error tokenizer "Missing block start.")
      (begin (tokenizer 'next)
             (let loop ((expr (if use-let (scm-cons 'let (scm-cons '() '())) (scm-cons 'begin '())))
                        (count 0))
               (let ((token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-brace*)
                        (tokenizer 'next)
                        (if (zero? count) (scm-append expr (scm-list *void*)) expr))
                       ((eof-object? token)
                        (parser-error tokenizer "Unexpected end of input. Missing closing brace?"))
                       (else
                        (loop (scm-append expr (scm-list (expression/statement tokenizer #f)))
                              (+ 1 count)))))))))

(define (cmpr-expr tokenizer)
  (let loop ((expr (addsub-expr tokenizer)))
    (if (cmpr-opr? (tokenizer 'peek))
      (case (tokenizer 'next)
        ((*equals*) (loop (swap-operands (scm-append (eq-expr tokenizer) (scm-list expr)))))
        ((*not-equals*) (loop (swap-operands (scm-append (not-eq-expr tokenizer) (scm-list expr)))))	
        ((*less-than*) (loop (swap-operands (scm-append (lt-expr tokenizer) (scm-list expr)))))
        ((*greater-than*) (loop (swap-operands (scm-append (gt-expr tokenizer) (scm-list expr)))))
        ((*less-than-equals*) (loop (swap-operands (scm-append (lteq-expr tokenizer) (scm-list expr)))))
        ((*greater-than-equals*) (loop (swap-operands (scm-append (gteq-expr tokenizer) (scm-list expr))))))
      expr)))

(define (logical-and-expr tokenizer)
  (let loop ((expr (logical-or-expr tokenizer)))
    (if (scm-eq? '*and* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (and-expr tokenizer) (scm-list expr)))))
        expr)))

(define (logical-or-expr tokenizer)
  (let loop ((expr (cmpr-expr tokenizer)))
    (if (scm-eq? '*or* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (scm-append (or-expr tokenizer) (scm-list expr)))))
        expr)))
  
(define (addsub-expr tokenizer)
  (let loop ((expr (term-expr tokenizer)))
    (if (add-sub-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*plus*) (loop (swap-operands (scm-append (add-expr tokenizer) (scm-list expr)))))
          ((*minus*) (loop (swap-operands (scm-append (sub-expr tokenizer) (scm-list expr))))))
        expr)))

(define (factor-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (scm-eq? token '*open-paren*)
        (begin (tokenizer 'next)
               (let ((expr (expression tokenizer)))
                 (if (scm-not (scm-eq? (tokenizer 'peek) '*close-paren*))
                     (begin (parser-error tokenizer "Missing closing parenthesis.")
                            #f)
                     (begin (tokenizer 'next)
                            (member-access/funcall-expr expr tokenizer)))))
        (let ((expr (if-expr tokenizer)))
          (if expr expr
              (let-expr tokenizer))))))

(define (handle-rvar-access sym)
  (if (rvar? sym)
      (scm-list 'scm-rget (normalize-rvar sym))
      sym))

(define (token->neg-number token)
  (if (number? token)
      (if (complex? token)
          (scm-list '* token -1)
          (string->number (string-append "-" (number->string token))))
      (scm-list '- token)))

(define (literal-expr tokenizer)
  (let ((expr (func-def-expr tokenizer)))
    (if expr
        (member-access/funcall-expr expr tokenizer)
        (let ((token (tokenizer 'peek)))
          (cond ((or (number? token)
                     (string? token)
		     (char? token))
                 (slgn-repr->scm-repr (tokenizer 'next)))
                ((add-sub-opr? token)
                 (tokenizer 'next)
                 (let ((sub (scm-eq? token '*minus*))
                       (next (tokenizer 'peek)))
                   (if sub
                       (if (or (number? next) 
                               (valid-identifier? next))
                           (begin (tokenizer 'next)
                                  (token->neg-number next))
                           (scm-list '- (expression tokenizer)))
                       (expression tokenizer))))                       
                ((valid-identifier? token) (handle-symbol token tokenizer))
                ((scm-eq? token '*open-bracket*)
                 (list-literal tokenizer))
                ((scm-eq? token '*open-brace*)
                 (block-expr tokenizer #t))
                ((scm-eq? token '*hash*)
                 (array-or-table-literal tokenizer))
                ((scm-eq? token '*delay*)
                 (tokenizer 'next)
                 (scm-list 'delay (func-body-expr tokenizer #t)))
                ((scm-eq? token '*quote*)
                 (tokenizer 'next)
                 (let ((sym (tokenizer 'peek)))
                   (if (scm-not (symbol? sym))
                       (parser-error tokenizer "Expected symbol."))
                   (tokenizer 'next)
                   (scm-list 'quote sym)))
		((symbol? token) (handle-symbol token tokenizer))
                (else (parser-error tokenizer "Invalid literal expression.")))))))

(define (handle-symbol token tokenizer)
  (cond ((scm-eq? token '?)                        
	 (tokenizer 'next)
	 (scm-list 'scm-rvar))
        ((scm-eq? token 'unquote_splicing)
         (tokenizer 'next)
         'unquote-splicing)
	(else (let ((var (tokenizer 'next)))
		(if (scm-eq? (tokenizer 'peek) '*period*)
		    (begin (tokenizer 'next)
			   (closure-member-access var tokenizer))
		    (handle-rvar-access (slgn-repr->scm-repr var)))))))

(define (member-access/funcall-expr expr tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*period*)
         (begin (tokenizer 'next)
                (closure-member-access expr tokenizer)))
        ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (func-call-expr expr tokenizer))
        (else expr)))

(define (list-literal tokenizer)
  (tokenizer 'next)
  (let loop ((result (scm-list 'scm-list)))
    (let ((token (tokenizer 'peek)))
      (if (scm-eq? token '*close-bracket*)
          (begin (tokenizer 'next)
                 (scm-reverse result))
          (let ((expr (expression tokenizer)))
            (if (scm-eq? (tokenizer 'peek) '*pipe*)
                (begin (tokenizer 'next)
                       (list-comprehension-expr tokenizer expr))
                (begin (assert-comma-separator tokenizer '*close-bracket*)
                       (loop (scm-cons expr result)))))))))

(define (list-comprehension-expr tokenizer result-expr)
  (let ((vars-lists-filters 
         (let loop ((vars '())
                    (lists '())
                    (filters '()))
           (let ((var (tokenizer 'next))
                 (extractor (tokenizer 'next)))
             (if (and (symbol? var)
                      (scm-eq? '*extractor* extractor))
		 (begin (check-if-reserved-name var tokenizer)
			(let ((lists (scm-cons (expression tokenizer) lists))
			      (vars (scm-cons var vars))
			      (filters (scm-cons (if (scm-eq? (tokenizer 'peek) 'where)
						 (begin (tokenizer 'next)
							(expression tokenizer))
						 #t)
					     filters)))
			  (assert-comma-separator tokenizer '*close-bracket*)
			  (loop vars lists filters)))
                 (begin (tokenizer 'put extractor)
                        (tokenizer 'put var)
                        (scm-list (scm-reverse vars) (scm-reverse lists) 
                              (scm-reverse filters))))))))
    (let ((expr (list-comprehension (scm-cadr vars-lists-filters) 
                                    (scm-car vars-lists-filters) 
                                    (scm-caddr vars-lists-filters) 
                                    result-expr)))
      (let ((t (tokenizer 'next)))
        (if (scm-not (scm-eq? t '*close-bracket*))
            (parser-error tokenizer "Expected closing bracket.")))
      expr)))
                    
(define (array-prefix? prefix tokenizer) 
  (or (scm-eq? prefix 'u8)
      (scm-eq? prefix 's8)
      (scm-eq? prefix 'b)
      (scm-eq? prefix 'v)
      (scm-eq? prefix 'u16)
      (scm-eq? prefix 's16)
      (scm-eq? prefix 'u32)
      (scm-eq? prefix 's32)
      (scm-eq? prefix 'u64)
      (scm-eq? prefix 's64)
      (scm-eq? prefix 'f32)
      (scm-eq? prefix 'f64)))

(define (array-prefix->constructor prefix)
  (case prefix
    ((v) 'scm-vector)
    ((u8) 'scm-u8vector)
    ((s8) 'scm-s8vector)
    ((u16) 'scm-u16vector)
    ((s16) 'scm-s16vector)
    ((u32) 'scm-u32vector)
    ((s32) 'scm-s32vector)
    ((u64) 'scm-u64vector)
    ((s64) 'scm-s64vector)
    ((f32) 'scm-f32vector)
    ((f64) 'scm-f64vector)
    (else 'bit_array)))

(define (array-literal tokenizer)
  (let ((prefix (tokenizer 'peek)))
    (if (array-prefix? prefix tokenizer)
        (tokenizer 'next)
        (set! prefix 'v))
    (if (scm-eq? (tokenizer 'peek) '*open-bracket*)
        (begin (tokenizer 'next)
               (let loop ((expr (scm-list (array-prefix->constructor prefix)))
                          (token (tokenizer 'peek)))
                 (cond ((scm-eq? token '*close-bracket*)
                        (tokenizer 'next)
                        (scm-reverse expr))
                       (else (let ((e (expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-bracket*)
                               (loop (scm-cons e expr) (tokenizer 'peek)))))))
        (parser-error tokenizer "Invalid start of array literal."))))

(define (table-literal mkset? tokenizer)
  (tokenizer 'next)
  (let ((close-token (if mkset? '*close-paren* '*close-brace*)))
    (let loop ((args '()))
      (if (scm-eq? (tokenizer 'peek) close-token)
          (begin
            (tokenizer 'next)
            (if mkset?
                `(make-set ,@args)
                `(make-equal-hashtable (scm-list ,@args))))
          (let ((keyval (expression tokenizer)))
            (begin
              (if (and (not mkset?)
                       (scm-not (and
                                 (pair? keyval)
                                 (scm-eq? (scm-car keyval) 'scm-cons))))
                  (parser-error tokenizer "Expected key-value pair."))
              (assert-comma-separator tokenizer close-token)
              (loop (scm-cons keyval args))))))))
    
(define (array-or-table-literal tokenizer)
  (tokenizer 'next)
  (let ((token (tokenizer 'peek)))
    (cond ((scm-eq? token '*open-brace*)
           (table-literal #f tokenizer))
          ((scm-eq? token '*open-paren*)
           (table-literal #t tokenizer))
          (else
           (array-literal tokenizer)))))

(define (let-expr tokenizer)
  (let ((expr (let ((letkw (letkw? (tokenizer 'peek))))
		(if letkw
		    (begin (tokenizer 'next)
			   (if (valid-identifier? (tokenizer 'peek))
			       (named-let-expr letkw tokenizer)
			       (normal-let-expr letkw tokenizer)))
		    (func-call-expr (literal-expr tokenizer) tokenizer)))))
    expr))

(define (normal-let-expr letkw tokenizer)
  (scm-list letkw (let-bindings tokenizer) (func-body-expr tokenizer #f)))

(define (named-let-expr letkw tokenizer)
  (if (scm-not (scm-eq? letkw 'let))
      (parser-error tokenizer (string-append "Cannot define " (symbol->string letkw)
                                             " as a named let.")))
  (let ((name (tokenizer 'next)))
    (scm-list letkw name (let-bindings tokenizer) (func-body-expr tokenizer #f))))

(define (let-bindings tokenizer)
  (if (scm-not (scm-eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "Expected let variable bindings list."))
  (let loop ((token (tokenizer 'next))
	     (bindings '()))
    (cond ((scm-eq? token '*close-paren*)
	   bindings)
	  ((symbol? token)
           (check-if-reserved-name token tokenizer)
           (if (scm-not (scm-eq? (tokenizer 'next) '*assignment*))
               (parser-error tokenizer "Expected assignment."))
           (let ((expr (func-body-expr tokenizer #f)))
             (let ((next (tokenizer 'peek)))
               (if (scm-eq? next '*comma*) 
                   (tokenizer 'next)))
             (loop (tokenizer 'next) (scm-append bindings (scm-list (scm-list token expr))))))
          (else (parser-error tokenizer "Expected variable declaration.")))))

(define (letkw? sym)
  (if (and (symbol? sym)
	   (or (scm-eq? sym 'let)
	       (scm-eq? sym 'letseq)
	       (scm-eq? sym 'letrec)))
      (cond ((scm-eq? sym 'letseq)
             'let*)
            (else sym))
      #f))

(define (mod-exports-list tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((not (eq? '*open-paren* token))
           '())
          (else
           (tokenizer 'next)
           (let loop ((exports '()))
             (let ((token (tokenizer 'peek)))
               (if (scm-not (scm-eq? token '*close-paren*))
                   (if (symbol? token)
                       (begin
                         (check-if-reserved-name token tokenizer)
                         (tokenizer 'next)
                         (assert-comma-separator tokenizer '*close-paren*)
                         (loop (scm-cons token exports)))
                       (parser-error tokenizer "Invalid exported name."))
                   (begin
                     (tokenizer 'next)
                     (scm-reverse exports)))))))))

(define (check-if-body-has-exported-names body exports)
  (let ((defs-in-body
          (let loop ((body body) (defs '()))
            (if (null? body)
                defs
                (let ((e (scm-car body)))
                  (cond ((pair? e)
                         (loop (scm-cdr body)
                               (if (scm-eq? 'define (scm-car e))
                                   (scm-cons (scm-cadr e) defs)
                                   defs)))
                        ((symbol? e)
                         (loop (scm-cdr body)
                               (if (scm-eq? 'define e)
                                   (scm-cons (scm-cadr body) defs)
                                   defs)))
                        (else (loop (scm-cdr body) defs))))))))            
    (let loop ((exports exports))
      (if (null? exports)
          #t
          (if (scm-memq (scm-car exports) defs-in-body)
              (loop (scm-cdr exports))
              (error "Exported name not found in definitions." (scm-car exports)))))))

(define (merge-module name exports body)
  (check-if-body-has-exported-names body exports)
  (let ((dispatch-expr
         (let loop ((es exports)
                    (dispatcher `(case *name*)))
           (if (null? es)
               `(if *name*
                    ,(scm-append dispatcher '((else (error "Name not exported by module." *name*))))
                    ',exports)
               (let ((n (scm-car es)))
                 (loop (scm-cdr es) (scm-append dispatcher `(((,n) ,n)))))))))
    (let ((body-expr `(begin ,body ,dispatch-expr)))
      `(define ,name (lambda (#!optional *name*) ,body-expr)))))
                       
(define (module-def-expr tokenizer)
  (cond ((eq? 'module (tokenizer 'peek))
         (tokenizer 'next)
         (let ((mod-name (tokenizer 'next)))
           (if (not (symbol? mod-name))
               (parser-error tokenizer "Expected module name.")
               (check-if-reserved-name mod-name tokenizer))
           (let ((mod-exports (mod-exports-list tokenizer))
                 (mod-body (func-body-expr tokenizer '())))
             (merge-module mod-name mod-exports mod-body))))
        (else #f)))
             
(define (func-def-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (eq? '*fn* token) (eq? 'function token))
        (begin (tokenizer 'next)
               (let* ((params (scm-car (func-params-expr tokenizer #f)))
                      (body-expr (func-body-expr tokenizer params)))
                 (merge-lambda tokenizer params body-expr)))
        (module-def-expr tokenizer))))

(define (merge-lambda tokenizer params lambda-body)
  (let ((expr (let ((lambda-expr (scm-list 'lambda params)))
                (if (scm-not (list? lambda-body))
                    (set! lambda-body (scm-list 'begin lambda-body)))
                (if (<= 1 (scm-length lambda-body))
                    (scm-append lambda-expr (scm-list lambda-body))
                    (let loop ((lambda-expr lambda-expr)
                               (lambda-body (if (scm-eq? (scm-car lambda-body) 'begin)
                                                (scm-cdr lambda-body)
                                                lambda-body)))
                      (if (null? lambda-body)
                          lambda-expr
                          (loop (scm-append lambda-expr (scm-list (scm-car lambda-body)))
                                (scm-cdr lambda-body))))))))
    (if (> (tokenizer 'yield-count) 0)
        (tokenizer 'reset-yield-count))
    expr))

(define (wrap-in-return-cont expr)
  `(call/cc (lambda (*return*)
              (let ((*yield-obj* (make-s-yield #f *return*)))
                (begin ,expr
                       (let ((*r* (s-yield-k *yield-obj*)))
                         (s-yield-fn-set! *yield-obj* #f)
                         (*r* *yield-obj*)))))))

(define (stmt-or-expr tokenizer)
  (let ((expr (statement tokenizer)))
    (if (scm-not expr)
        (expression tokenizer)
        expr)))

(define (extract-param-names params)
  (let loop ((params params) (res '()))
    (if (null? params)
      (scm-reverse res)
      (let ((p (scm-car params)))
        (cond
          ((symbol? p) (loop (scm-cdr params) (scm-cons p res)))
          ((pair? p) (loop (scm-cdr params) (scm-cons (scm-car p) res)))
          (else (loop (scm-cdr params) res)))))))

(define (func-body-expr tokenizer params #!optional (use-let #f))
  (let ((implicit-match? #f))
    (if (scm-eq? (tokenizer 'peek) '*pipe*)
      (if (and params (> (scm-length params) 0))
        (begin
          (tokenizer 'next)
          (set! implicit-match? #t))
        (parser-error tokenizer "Implicit match cannot be specified here.")))
    (let ((match-value (if implicit-match?
                         (if (= (scm-length params) 1)
                           (scm-car params)
                           (append '(scm-list) (extract-param-names params))))))
      (let ((old-yield-count (tokenizer 'yield-count)))
        (let ((body-expr
                (let ((token (tokenizer 'peek)))
                  (if (or (scm-eq? token '*semicolon*) 
                        (eof-object? token))
                    '(begin (quote ()))
                    (if implicit-match?
                        (match-body-expr match-value tokenizer)
                        (if (scm-eq? (tokenizer 'peek) '*open-brace*)
                            (block-expr tokenizer use-let)
                            (stmt-or-expr tokenizer)))))))
          (if (and params (> (tokenizer 'yield-count) old-yield-count))
              (wrap-in-return-cont body-expr)
              body-expr))))))

(define (func-call-expr func-val tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (if (and (symbol? func-val)
                  (check-if-reserved-name func-val tokenizer)
                  (tokenizer 'pattern-mode?))
             (let ((s (symbol->string func-val)))
               (set! func-val (string->symbol (string-append "+" s)))))
         (tokenizer 'next)
         (let ((expr (mk-func-call-expr tokenizer func-val)))
           (cond ((scm-eq? (tokenizer 'peek) '*close-paren*)
                  (tokenizer 'next) 
                  (if (scm-eq? (tokenizer 'peek) '*period*)
                      (member-access/funcall-expr expr tokenizer)
                      expr))
                 (else (parser-error tokenizer "Missing closing parenthesis after function argument list.")))))
        (else func-val)))

(define (mk-func-call-expr tokenizer func-val)
  (let ((expr (func-args-expr tokenizer)))
    (scm-cons func-val expr)))

(define (record-def-stmt tokenizer)
  (if (scm-eq? (tokenizer 'peek) 'record)
      (begin (tokenizer 'next)
	     (let ((token (tokenizer 'peek)))
	       (if (scm-not (valid-identifier? token))
		   (parser-error tokenizer "Missing record name."))
	       (mk-record-expr (tokenizer 'next) tokenizer)))
      (assignment-stmt tokenizer)))

(define (rec-get-precond tokenizer)
  (tokenizer 'next)
  (let ((precond (expression tokenizer)))
    (assert-comma-separator tokenizer '*close-paren*)
    precond))

(define (mk-rec-type-check-expr field-name type-name)
  (let ((predic-name (string->symbol (string-append "is_" (symbol->string type-name)))))
    `(,predic-name ,field-name)))

(define (rec-get-field-def tokenizer field-name)
  (let ((token (tokenizer 'peek)))
    (cond
      ((scm-eq? token '*assignment*)
        (tokenizer 'next)
        (let ((val (expression tokenizer)))
          (if (scm-eq? (tokenizer 'peek) 'where)
            (scm-cons val (rec-get-precond tokenizer))
            (begin (assert-comma-separator tokenizer '*close-paren*)
              (scm-cons val #t)))))
      ((scm-eq? token '*colon*)
        (tokenizer 'next)
        (let ((type-name (tokenizer 'next)))
          (if (symbol? type-name)
            (let ((expr (scm-cons #f (mk-rec-type-check-expr field-name type-name))))
              (assert-comma-separator tokenizer '*close-paren*)
              expr)
            (parser-error tokenizer "Expected a type name here."))))
      (else
        (if (scm-eq? token 'where)
          (scm-cons #f (rec-get-precond tokenizer))
          (begin (assert-comma-separator tokenizer '*close-paren*)
            (scm-cons #f #t)))))))
  
(define (mk-record-expr name tokenizer)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((token (tokenizer 'peek))
                    (members '()) (default-values '())
                    (preconds '()))
           (cond ((valid-identifier? token)
                  (let ((token (tokenizer 'next))
                        (fdef (rec-get-field-def tokenizer token)))
                    (loop (tokenizer 'peek) (scm-cons token members)
                          (scm-cons (scm-car fdef) default-values) 
                          (scm-cons (scm-cdr fdef) preconds))))
                 ((scm-eq? token '*close-paren*)
                  (tokenizer 'next)
                  (def-struct-expr name (scm-reverse members) (scm-reverse default-values) (scm-reverse preconds)))
                 (else (parser-error tokenizer "Invalid record specification.")))))
        (else (parser-error tokenizer "Expected record member specification."))))

(define (def-struct-expr name members default-values preconds)
  (scm-append (scm-list 'begin (scm-append (scm-list 'define-structure name) members))
	  (mk-struct-accessors/modifiers name members default-values preconds)))

(define (mk-record-precond-expr precond mem)
  (if (eq? precond #t)
    precond
    (scm-list
      'if (scm-list 'not precond)
      (scm-list
        'error `(scm-cons 'preconditon_failed
                  ,(with-output-to-string 
                     '()
                     (lambda () 
                       (scm-display precond)
                       (scm-display ".")))))
      mem)))

(define (mk-record-precond-exprs preconds mems)
  (let loop ((preconds preconds) (mems mems) (result '()))
    (if (null? preconds) (scm-append (scm-list 'begin) (scm-reverse result))
        (loop (scm-cdr preconds) (scm-cdr mems)
              (if (eq? #t (scm-car preconds))
                  result
                  (scm-cons (mk-record-precond-expr (scm-car preconds) (scm-car mems)) result))))))
        
(define (mk-record-constructor recname members default-values preconds)
  (scm-append (scm-list 'lambda (scm-append (scm-list '#!key) (mk-record-constructor-params members default-values)))
          (scm-list (mk-record-precond-exprs preconds members) 
                (scm-cons (string->symbol (string-append "make-" recname)) members))))

(define (mk-record-constructor-params members default-values)
  (let loop ((members members) (default-values default-values) 
             (params '()))
    (cond ((null? members) (scm-reverse params))
          (else (loop (scm-cdr members) (scm-cdr default-values)
                      (scm-cons (scm-list (scm-car members) 
                                  (scm-car default-values)) params))))))

(define (mk-struct-accessors/modifiers name members default-values preconds)
  (let ((sname (symbol->string name)))
    (let loop ((members members)
               (preconds preconds)
               (i 0)
               (expr (scm-list 
                      (scm-list 'define (string->symbol sname) 
                            (mk-record-constructor sname members default-values preconds))
                      (scm-list 'define (string->symbol (string-append "make_" sname))
                            (string->symbol (string-append "make-" sname)))
                      (scm-list 'define 
                            (string->symbol (string-append "is_" sname))
                            (string->symbol (string-append sname "?"))))))
      (if (null? members) (scm-reverse expr)
          (begin (loop (scm-cdr members) (scm-cdr preconds) (+ i 1)
                       (scm-append expr (member-accessor/modifier name (scm-car members) (scm-car preconds) i))))))))

(define (member-accessor/modifier name mem precond index)
  (let ((sname (symbol->string name))
	(smem (symbol->string mem)))
    (let ((scm-accessor (string->symbol (string-append sname "-" smem)))
	  (scm-modifier (string->symbol (string-append sname "-" smem "-set!")))
	  (slgn-accessor (string->symbol (string-append sname "_" smem)))
          (idx-accessor (string->symbol (string-append sname "-" (number->string index))))
	  (slgn-modifier (string->symbol (string-append sname "_set_" smem))))
      (scm-list (scm-list 'define slgn-accessor scm-accessor)
            (scm-list 'define idx-accessor scm-accessor)
	    (scm-list 'define slgn-modifier (scm-append (scm-list 'lambda (scm-list '*s* mem)) 
                                                (scm-append (if (eq? #t precond) '() (scm-list (mk-record-precond-expr precond mem)))
                                                        (scm-list (scm-list scm-modifier '*s* mem)))))))))

(define (assert-comma-separator tokenizer end-seq-char #!optional comma-required)
  (let ((token (tokenizer 'peek)))
    (if (or (scm-eq? token '*comma*)
            (if (list? end-seq-char) 
                (scm-memq token end-seq-char) 
                (scm-eq? token end-seq-char)))
        (if (scm-eq? token '*comma*) (tokenizer 'next))
        (if comma-required
            (parser-error tokenizer (with-output-to-string
                                      '()
                                      (lambda ()
                                        (scm-display "Missing comma or ") 
                                        (slgn-display end-seq-char) 
                                        (scm-display "."))))))))

(define (func-args-expr tokenizer)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (scm-not (scm-eq? token '*close-paren*))
          (cond ((valid-identifier? token)
                 (let ((sym (tokenizer 'next)))
                   (if (scm-eq? (tokenizer 'peek) '*assignment*)
                       (begin (tokenizer 'next)
                              (let ((expr (expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (scm-append args (scm-list (slgn-variable->scm-keyword sym) expr)))))
                       (begin (tokenizer 'put sym)
                              (let ((expr (expression tokenizer)))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (scm-append args (scm-list expr))))))))
                (else
                 (let ((expr (expression tokenizer)))
                   (assert-comma-separator tokenizer '*close-paren*)
                   (loop (scm-append args (scm-list expr))))))
          args))))

(define (check-if-reserved-name sym tokenizer)
  (if (or (reserved-name? sym) (is_special_token sym))
      (parser-error tokenizer (string-append "Invalid use of keyword or operator: "
                                             (symbol->string sym) ".") sym)
      sym))

(define (valid-identifier? sym)
  (and (symbol? sym)
       (scm-not (or (reserved-name? sym)
		(is_special_token sym)))))
  
(define (check-func-param tokenizer) 
  (check-if-reserved-name (tokenizer 'peek) tokenizer)
  (let ((sym (tokenizer 'next)))
    (if (eq? sym '_) (gensym) sym)))

(define (func-param-type tokenizer)
  (let ((type (cond ((scm-eq? (tokenizer 'peek) '*colon*)
		     (tokenizer 'next)
		     (let ((s (tokenizer 'next)))
		       (if (symbol? s) s (parser-error tokenizer "Expected type name."))))
		    (else '_))))
    (assert-comma-separator tokenizer '*close-paren*)
    type))

(define (func-params-expr tokenizer params-required?)
  (cond ((scm-eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((params '()) (types '())
                    (directives-found #f))
           (let ((token (tokenizer 'peek)))
             (cond ((valid-identifier? token)
                    (let ((sym (check-func-param tokenizer)))
                      (cond ((param-directive? sym)
                             (loop (scm-cons (slgn-directive->scm-directive sym) params)
				   (if (eq? sym '@rest) (scm-cons sym types) types)
				   #t))
                            ((scm-eq? (tokenizer 'peek) '*assignment*)
                             (tokenizer 'next)
                             (let ((expr (expression tokenizer)))
                               (if directives-found
                                   (loop (scm-cons (scm-list sym expr) params)
					 (scm-cons (func-param-type tokenizer) types)					 
					 directives-found)
				   (loop (scm-cons 
					  (scm-list sym expr) 
					  (scm-cons 
					   (slgn-directive->scm-directive '@optional) params))
					 (scm-cons (func-param-type tokenizer) types)					 
					 #t))))
                            (else 
                             (loop (scm-cons sym params)
				   (scm-cons (func-param-type tokenizer) types)				   
				   directives-found)))))
                   (else
                    (if (scm-eq? token '*close-paren*)
                        (begin (tokenizer 'next)
                               (scm-cons (scm-reverse params) (scm-reverse types)))
                        (parser-error tokenizer "Missing closing parenthesis after parameter list.")))))))
        (else
	 (if params-required?
	     (parser-error tokenizer "Missing parameter list.")
	     (scm-cons '() '())))))

(define (param-directive? sym)
  (scm-memq sym '(@optional @key @rest)))

(define (closure-member-access var tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (let loop ((expr `(,var ',(tokenizer 'next))))
	(if (scm-eq? (tokenizer 'peek) '*period*)
	    (begin (tokenizer 'next)
		   (if (valid-identifier? (tokenizer 'peek))
		       (loop (scm-cons expr `(',(tokenizer 'next))))
		       (parser-error tokenizer "Expected identifier.")))
	    expr))
      (parser-error tokenizer "Expected identifier.")))

(define (add-expr tokenizer)
  (swap-operands (scm-cons '+ (scm-list (term-expr tokenizer)))))

(define (sub-expr tokenizer)
  (swap-operands (scm-cons '- (scm-list (term-expr tokenizer)))))

(define (mult-expr tokenizer)
  (swap-operands (scm-cons '* (scm-list (factor-expr tokenizer)))))

(define (div-expr tokenizer)
  (swap-operands (scm-cons '/ (scm-list (factor-expr tokenizer)))))

(define (eq-expr tokenizer)
  (swap-operands (scm-cons '== (scm-list (addsub-expr tokenizer)))))

(define (not-eq-expr tokenizer)
  (swap-operands (scm-cons '<> (scm-list (addsub-expr tokenizer)))))

(define (lt-expr tokenizer)
  (swap-operands (scm-cons '< (scm-list (addsub-expr tokenizer)))))

(define (lteq-expr tokenizer)
  (swap-operands (scm-cons '<= (scm-list (addsub-expr tokenizer)))))

(define (gt-expr tokenizer)
  (swap-operands (scm-cons '> (scm-list (addsub-expr tokenizer)))))

(define (gteq-expr tokenizer)
  (swap-operands (scm-cons '>= (scm-list (addsub-expr tokenizer)))))

(define (and-expr tokenizer)
  (swap-operands (scm-cons 'and (scm-list (logical-or-expr tokenizer)))))

(define (or-expr tokenizer)
  (swap-operands (scm-cons 'or (scm-list (cmpr-expr tokenizer)))))

(define (term-expr tokenizer)
  (let loop ((expr (factor-expr tokenizer)))
    (if (mult-div-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*asterisk*) (loop (swap-operands (scm-append (mult-expr tokenizer) (scm-list expr)))))
          ((*backslash*) (loop (swap-operands (scm-append (div-expr tokenizer) (scm-list expr))))))
        expr)))

(define (swap-operands expr)
  (if (= 3 (scm-length expr))
      (scm-list (scm-car expr) (scm-caddr expr) (scm-cadr expr))
      expr))

(define *reserved-names* '(^ function module method record true false
			     if else when let letseq letrec yield
			     case match where try trycc catch finally
			     declare assert))

(define (reserved-name? sym)
  (and (symbol? sym)
       (scm-memq sym *reserved-names*)))

(define (parened-names->list tokenizer)
  (if (scm-eq? (tokenizer 'next) '*open-paren*)
      (let loop ((token (tokenizer 'next))
                 (result '()))
        (cond ((scm-eq? token '*close-paren*)
               (scm-reverse result))
              ((valid-identifier? token)
               (assert-comma-separator tokenizer '*close-paren*)
               (loop (tokenizer 'next) (scm-cons token result)))
              (else #f)))
      #f))
