;; Copyright (c) 2013-2014 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define (slogan tokenizer)
  (expression/statement tokenizer))

(define (slgn-load tokenizer script-name)
  (let ((has-envvars (and (string? script-name)
                          (has-envvars? script-name))))
    (if (compile (if (symbol? script-name) 
                     (symbol->string script-name) 
                     (if has-envvars
                         (expand_envvars script-name)
                         script-name))
                 assemble: (tokenizer 'compile-mode?))
        (if (tokenizer 'compile-mode?)
            `(load (if has-envvars (expand_envvars ,script-name) ,script-name))
            `(load ,(string-append (if has-envvars (expand_envvars script-name) script-name) *scm-extn*)))
        (error "failed to compile " script-name))))

(define (expression/statement tokenizer #!optional (top #t))
  (if (eof-object? (tokenizer 'peek))
      (tokenizer 'next)
      (let ((v (add-def-to-namespace (statement tokenizer) top)))
        (if (not v) (set! v (intern-to-top-namespace (expression tokenizer) top)))
        (assert-semicolon tokenizer)
        v)))

(define (statement tokenizer)
  (if (eq? (tokenizer 'peek) '*semicolon*) *void*
      (load-stmt tokenizer)))

(define (highligted-line colno)
  (if (< colno 0)
      (set! colno 1))
  (with-output-to-string
    '()
    (lambda ()
      (let loop ((n 0))
	(if (= n colno) (display #\^)
	    (begin (display #\space)
		   (loop (+ n 1))))))))

(define (highligted-error-line tokenizer)
  (let ((curr-tok-len (current-token-length tokenizer)))
    (let loop ((line-no (tokenizer 'line)) 
               (n 1)
               (program-text (tokenizer 'program-text)))
      (if (not (null? program-text))
          (if (= n line-no)
              (cons (car program-text) (highligted-line (- (tokenizer 'column) curr-tok-len)))
              (loop line-no (+ n 1) (cdr program-text)))
          #f))))

(define (parser-error tokenizer msg)
  (pop-namespace)
  (error (with-output-to-string 
           '()
           (lambda ()
             (if tokenizer
                 (println "at [line: "(tokenizer 'line) 
                          ", column: " (tokenizer 'column) "]. " 
                          msg))
             (let ((hl (highligted-error-line tokenizer)))
               (if hl (begin (println (car hl))
                             (println (cdr hl)))))))))

(define (assert-semicolon tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (or (eq? token '*semicolon*)
            (eq? token '*close-brace*)
            (eof-object? token))
        (if (eq? token '*semicolon*)
            (tokenizer 'next))
        (parser-error tokenizer "Statement or expression not properly terminated."))))

(define (load-stmt tokenizer)
  (cond ((eq? (tokenizer 'peek) 'load)
         (tokenizer 'next)
         (slgn-load tokenizer (tokenizer 'next)))
        (else (namespace-stmt tokenizer))))

(define (namespace-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'namespace)
      (begin (tokenizer 'next)
             (if (valid-identifier? (tokenizer 'peek))
		 (push-namespace (check-if-reserved-name (tokenizer 'next) tokenizer))
		 (pop-namespace)))
      (import-stmt tokenizer)))

(define (import-with-prefix tokenizer ns-name import-names)
  (tokenizer 'next)
  (let ((prefix (tokenizer 'next)))
    (if (not (valid-identifier? prefix))
        (parser-error tokenizer "Expected name prefix.")
        (import-from-namespace ns-name import-names prefix))))
  
(define (import-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'import)
      (begin (tokenizer 'next)
             (let ((import-names (import-defs tokenizer)))
               (cond ((list? import-names)
                      (if (not (eq? (tokenizer 'next) 'from))
                          (parser-error tokenizer "Expected `from <namespace_name>'."))
                      (let ((nname (tokenizer 'next)))
                        (if (not (valid-identifier? nname))
                            (parser-error tokenizer "Expected namespace name."))
                        (if (eq? (tokenizer 'peek) 'with_prefix)
                            (import-with-prefix tokenizer nname import-names)
                            (import-from-namespace nname import-names))))
                     (else (if (eq? (tokenizer 'peek) 'with_prefix)
                               (import-with-prefix tokenizer import-names #f)
                               (import-from-namespace import-names))))))
      (declare-stmt tokenizer)))

(define (declare-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'declare)
      (begin (tokenizer 'next)
             (let ((name (tokenizer 'next)))
               (case name
                 ((lazy) (declare-lazy-stmt tokenizer))
                 ((imported) (declare-imported-stmt tokenizer))
                 ((generic) (declare-generic-stmt tokenizer))
                 (else
                  (parser-error tokenizer tokenizer "Invalid declare type.")))))
      (func-def-stmt tokenizer)))

(define (declare-lazy-stmt tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (valid-identifier? name)
	(declare-lazy (tokenizer 'next))
        (declare-lazy (parened-names->list tokenizer)))))

(define (declare-imported-stmt tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (declare-imported (tokenizer 'next))
      (let ((names (parened-names->list tokenizer)))
        (if names (declare-imported names)
            (parser-error tokenizer "Invalid import list.")))))

(define (declare-generic-stmt tokenizer)
  (let ((name (tokenizer 'next)))
    (if (valid-identifier? name)
        (define-generic-method name tokenizer)
        (parser-error tokenizer "Expected a valid generic method name."))))

(define (define-generic-method name tokenizer)
  (check-if-reserved-name name tokenizer)
  (let ((params (func-params-expr tokenizer)))
    (let ((generic-expr
	   `(define ,name 
	      (lambda ,params
	      (error "Method not defined.")))))
      (if (eq? (tokenizer 'peek) 'cases)
	  `(begin ,generic-expr ,@(generic-cases-expr tokenizer name params))
	  generic-expr))))

(define (generic-cases-expr tokenizer name params)
  (tokenizer 'next)
  (let loop ((types (method-types-decl tokenizer))
	     (method-defs '())
	     (found-else #f))
    (if (not (eq? (tokenizer 'next) '*inserter*))
	(parser-error tokenizer "Missing -> after types expression."))
    (let ((mdef (cons types (list 'define name (merge-lambda 
						params 
						(func-body-expr tokenizer params))))))
      (cond ((eq? (tokenizer 'peek) '*comma*)
	     (tokenizer 'next)
	     (cond ((eq? (tokenizer 'peek) 'else)
		    (tokenizer 'next)
		    (loop
		     '()
		     (cons (mk-method-def mdef) method-defs)
		     #t))
		   (else
		    (loop (method-types-decl tokenizer)
			  (cons (mk-method-def mdef) method-defs) #f))))
	    (found-else
	     (cons (mk-method-def mdef) (reverse method-defs)))
	    (else
	     (reverse (cons (mk-method-def mdef) method-defs)))))))

(define (import-defs tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (tokenizer 'next)
      (import-defs-list tokenizer)))

(define (import-defs-list tokenizer)
  (let ((names (parened-names->list tokenizer)))
    (if names names
        (parser-error tokenizer "Invalid import list."))))

(define (func-def-stmt-from-name tokenizer #!optional is-lazy noname)
  (let ((name (tokenizer 'peek)))
    (if (and (eq? name '*open-paren*)
             (not noname))
	(if is-lazy
            (parser-error tokenizer "lazy function must have a name.")
	    (let ((params (func-params-expr tokenizer)))
	      (merge-lambda params (func-body-expr tokenizer params))))
	(begin (if (not noname)
                   (begin (tokenizer 'next)
                          (remove-macro-lazy-fns-def name)))
	       (let ((params (func-params-expr tokenizer)))
		 (if (and is-lazy (not noname))
                     (def-lazy name (make-lazy #f #f)))
                 (let ((expr (merge-lambda 
				     params 
				     (if (and is-lazy (not noname))
					 (expr-forcify (func-body-expr tokenizer params) params)
					 (func-body-expr tokenizer params)))))
                   (if (not noname)
                       (list 'define name expr)
                       expr)))))))
                       
(define (func-def? token) (or (eq? 'fn token) (eq? 'function token)))

(define (func-def-stmt tokenizer)
  (cond ((func-def? (tokenizer 'peek))
         (tokenizer 'next)
         (if (eq? (tokenizer 'peek) 'lazy)
             (lazy-fn-stmt tokenizer)
             (func-def-stmt-from-name tokenizer)))
        (else (method-def-stmt tokenizer))))

(define (method-types-decl tokenizer)
  (if (not (eq? '*open-paren* (tokenizer 'next)))
      (parser-error tokenizer "Types declaration must start with opening parenthesis."))
  (let ((types-decl (func-args-expr tokenizer #f)))
    (if (not (eq? '*close-paren* (tokenizer 'next)))
        (parser-error tokenizer "Missing closing parenthesis after type declaration."))
    (if (not (for_all symbol? types-decl))
        (parser-error tokenizer "Invalid type declaration."))
    types-decl))

(define (mk-predic-name psym)
  (if (eq? psym '_)
      'is_object
      (string->symbol 
       (string-append 
        "is_" 
        (symbol->string psym)))))

(define (mk-method-types-chk types args)
  (let loop ((types types)
             (args args)
             (chk-expr '()))
    (if (null? types) (append (list 'and) (reverse chk-expr))
        (let ((type-name (car types)))
          (if (eq? type-name '@rest)
              (loop (cddr types)
                    (cdr args)
                    (cons `(for_all ,(mk-predic-name (cadr types)) ,(car args)) chk-expr))
              (loop (cdr types) 
                    (cdr args) 
                    (cons `(,(mk-predic-name (car types)) ,(car args)) chk-expr)))))))

(define (params->args params)
  (let loop ((params params)
             (args '()))
    (if (null? params)
        (reverse args)
        (cond ((pair? (car params))
               (loop (cdr params) (cons (caar params) args)))
              ((symbol? (car params))
               (loop (cdr params) (cons (car params) args)))
              (else (loop (cdr params) args))))))

(define (method-def-stmt-from-name tokenizer)
  (let ((name (tokenizer 'peek)))
    (if (not (valid-identifier? name))
        (parser-error tokenizer "Method must have a valid name."))
    (begin (tokenizer 'next)
           (remove-macro-lazy-fns-def name)
           (let ((types (method-types-decl tokenizer))
                 (params (func-params-expr tokenizer)))
             (cons types (list 'define name (merge-lambda 
                                             params 
                                             (func-body-expr tokenizer params))))))))

(define (method-def-stmt tokenizer)
  (cond ((eq? (tokenizer 'peek) 'method)
         (tokenizer 'next)
         (mk-method-def (method-def-stmt-from-name tokenizer)))
        (else (record-def-stmt tokenizer))))

(define (types-has-rest? types)
  (member '@rest types))

(define (mk-method-def method-def)
  (let ((func-def (cdr method-def))
	(types (car method-def)))
    (let ((name (cadr func-def))
	  (params (cadr (caddr func-def)))
	  (args (params->args (cadr (caddr func-def))))
	  (body (caddr (caddr func-def))))
      (let ((types-chk (mk-method-types-chk types args))
	    (old-name (string->symbol 
		       (string-append 
			"*" 
			(symbol->string name) 
			"*"))))
        (let ((parent-call (if (types-has-rest? types)
                               `(apply ,old-name ,@args)
                               `(,old-name ,@args))))
          `(define ,name (let ((,old-name ,name))
                           (lambda ,params 
                             (if ,types-chk 
                                 ,body
                                 ,parent-call)))))))))
  
(define (assignment-stmt tokenizer)
  (if (symbol? (tokenizer 'peek))
      (let ((sym (tokenizer 'next)))
	(if (eq? sym 'define)
	    (define-stmt tokenizer)
	    (cond ((not (valid-identifier? sym))
		   (tokenizer 'put sym)
		   #f)
		  ((eq? (tokenizer 'peek) '*assignment*)
		   (set-stmt sym tokenizer))
		  (else (tokenizer 'put sym) 
			#f))))
      #f))

(define (macro-def-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'macro)
      (begin (tokenizer 'next)
             (mk-macro-def (tokenizer 'next) tokenizer))
      (assignment-stmt tokenizer)))

(define (lazy-fn-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'lazy)
      (begin (tokenizer 'next)
	     (func-def-stmt-from-name tokenizer #t))
      (assignment-stmt tokenizer)))

(define (mk-macro-def macro-name tokenizer)
  (check-if-reserved-name macro-name tokenizer)
  (remove-macro-lazy-fns-def macro-name)
  (tokenizer 'macro-mode-on)
  (eval (let ((expr (list 'define macro-name (func-def-stmt-from-name tokenizer #f #t))))
          (add-def-to-namespace expr #t)))
  (def-macro macro-name #t)
  (tokenizer 'macro-mode-off)
  *void*)

(define (enter-scope) (push-macros-lazy-fns))

(define (leave-scope) (pop-macros-lazy-fns))

(define (define-stmt tokenizer)
  (let ((token (tokenizer 'next)))
    (if (symbol? token)
        (let ((unquote? (eq? '*unquote* token)))
          (if unquote?
              (if (not (tokenizer 'quote-mode?))
                  (parser-error tokenizer "Not in quote mode.")
                  (set! token (tokenizer 'next))))
          (check-if-reserved-name token tokenizer)
          (var-def-set (if unquote? (list 'unquote token) token) tokenizer #t))
        (parser-error tokenizer "Invalid variable name."))))

(define (set-stmt sym tokenizer) (var-def-set sym tokenizer #f))

(define (normalize-rvar sym)
  (let ((s (symbol->string sym)))
    (string->symbol (substring s 1 (string-length s)))))

(define (rvar? sym)
  (if (symbol? sym) 
      (let ((s (symbol->string sym)))
        (and (> (string-length s) 0)
             (char=? #\? (string-ref s 0))))
      #f))

(define (var-def-set sym tokenizer def)
  (remove-macro-lazy-fns-def sym)
  (if (eq? (tokenizer 'peek) '*assignment*)
      (begin (tokenizer 'next)
             (if (rvar? sym)
                 (if def
		     `(begin
			(define ,(normalize-rvar sym) (rvar))
			(rbind ,(normalize-rvar sym) ,(expression tokenizer)))
                     (list 'rbind (normalize-rvar sym) (expression tokenizer)))
                 (list (if def 'define 'set!) sym (expression tokenizer))))
      (parser-error tokenizer "Expected assignment.")))

(define (expression tokenizer)
  (let ((expr (logical-and-expr tokenizer)))
    (let loop ((expr expr)) 
      (cond ((eq? (tokenizer 'peek) '*open-paren*)
             (loop (func-call-expr expr tokenizer)))
            ((eq? (tokenizer 'peek) '*colon*)
             (pair-literal tokenizer expr))
            (else expr)))))

(define (pair-literal tokenizer expr)
  (tokenizer 'next)
  (let ((stream-pair? (eq? (tokenizer 'peek) '*colon*)))
    (if stream-pair? (tokenizer 'next))
    (let ((tail-expr (if stream-pair? 
			 `(delay ,(expression tokenizer))
			 (expression tokenizer))))
      (if (tokenizer 'quote-mode?)
	  `(,expr . ,tail-expr)
	  `(cons ,expr ,tail-expr)))))

(define (then-expr tokenizer)
  (if (not (eq? (tokenizer 'next) '*close-paren*))
      (parser-error tokenizer "Expected closing parenthesis."))
  (func-body-expr tokenizer #f #t))

(define (if-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'if)
         (tokenizer 'next)
         (if (not (eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Expected opening parenthesis."))         
         (let ((expr (cons 'if (list (expression tokenizer)
                                     (then-expr tokenizer)))))
           (if (eq? (tokenizer 'peek) 'else)
               (begin (tokenizer 'next)
                      (if (eq? (tokenizer 'peek) 'if)
                          (append expr (list (if-expr tokenizer)))
                          (append expr (list (func-body-expr tokenizer #f #t)))))
               expr)))
        (else (case-expr tokenizer))))

(define (case-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'case)
         (tokenizer 'next)
         (if (not (eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before case clause."))
         (let ((value (expression tokenizer)))
           (if (not (eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after case clause."))
           (let loop ((token (tokenizer 'peek)) (last-expr #f) (body '()))
             (if last-expr (append `(case ,value) (reverse body))
                 (let ((expr (normalize-sym (case-pattern-expression tokenizer))))
                   (if (not (eq? (tokenizer 'peek) '*inserter*))
                       (parser-error tokenizer "Missing -> after case expression.")
                       (tokenizer 'next))
                   (let ((result (func-body-expr tokenizer #f #t))
                         (next (tokenizer 'peek)) (le #f))
                     (if (eq? next '*comma*)
                         (tokenizer 'next)
                         (set! le #t))
                     (loop (tokenizer 'peek) le
                           (cons (list (if (or (list? expr) (eq? expr 'else)) expr (cons expr '()))
                                       result) body))))))))
        (else (match-expr tokenizer))))

(define (case-pattern-expression tokenizer)
  (if (eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (expression tokenizer)))

(define (pattern-expression tokenizer)
  (if (eq? (tokenizer 'peek) 'else)
      (begin 
	(tokenizer 'next)
	'else)
      (begin
	(tokenizer 'pattern-mode-on)
	(let ((expr (expression tokenizer)))
	  (tokenizer 'pattern-mode-off)
	  expr))))

(define (unbound? r) (eq? r '*unbound*))

(define (match-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'match)
         (tokenizer 'next)
         (if (not (eq? (tokenizer 'next) '*open-paren*))
             (parser-error tokenizer "Missing opening parenthesis before match clause."))
         (let ((value (expression tokenizer)))
           (if (not (eq? (tokenizer 'next) '*close-paren*))
               (parser-error tokenizer "Missing closing parenthesis after match clause."))
           (match-body-expr value tokenizer)))
        (else (try-catch-expr tokenizer))))

(define (match-body-expr value tokenizer)
  (let loop ((token (tokenizer 'peek)) (prev-pattern #f) (last-expr #f) (body '()))
    (if last-expr `(let ((*match-expr* ,value))
                     (let ((*value* *match-expr*)
                           (*orig-value* *match-expr*)
                           (*match-found* #f)
                           (*conv-value* #f)
                           (*result* '*unbound*))
                       ,@(reverse body)
                       (if (unbound? *result*)
                           (error "No match found.")
                           *result*)))
        (let ((pattern (pattern-expression tokenizer))
              (guard #t))
          (if (eq? (tokenizer 'peek) 'where)
              (begin (tokenizer 'next)
                     (set! guard (expression tokenizer))))
          (if (not (eq? (tokenizer 'peek) '*inserter*))
              (parser-error tokenizer "Missing -> after pattern.")
              (tokenizer 'next))
          (let ((consequent (func-body-expr tokenizer #f #t)))
            (if (not (eq? guard #t))
                (set! consequent `(if ,guard 
                                      ,consequent 
                                      (begin (set! *match-found* #f) 
                                             (set! *value* *orig-value*)
                                             '*unbound*))))
            (let ((next (tokenizer 'peek))
                  (le (eq? pattern 'else)))
              (if (eq? next '*comma*)
                  (if (not le) (tokenizer 'next))
                  (if (not le) (set! le #t)))
              (loop (tokenizer 'peek)
                    (if (eq? pattern '@) prev-pattern pattern) le
                    (cons (match-pattern (if (eq? pattern '@) prev-pattern pattern) consequent) body))))))))

(define (try-catch-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (cond ((or (eq? token 'try)
               (eq? token 'trycc))
           (tokenizer 'next)
           (let ((try-expr (expression tokenizer)))
             (case (tokenizer 'peek)
               ((catch)
                (make-try-catch-expr token try-expr (catch-args tokenizer) 
                                     (expression tokenizer) 
                                     (finally-expr tokenizer)))
               ((finally)
                (make-try-catch-expr token try-expr '(*e*) '(raise *e*)
                                     (finally-expr tokenizer)))
               (else (parser-error tokenizer "Expected catch or finally clauses.")))))
          (else #f))))

(define (catch-args tokenizer)
  (tokenizer 'next)
  (if (not (eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing opening parenthesis."))
  (tokenizer 'next)
  (let ((result (tokenizer 'next)))
    (if (not (and (symbol? result)
		  (check-if-reserved-name result tokenizer)))
        (parser-error tokenizer "Missing exception identifier."))
    (if (not (eq? (tokenizer 'peek) '*close-paren*))
        (parser-error tokenizer "Missing closing parenthesis."))
    (tokenizer 'next)
    (list result)))

(define (finally-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) 'finally)
         (tokenizer 'next)
         (expression tokenizer))
        (else *void*)))
      
(define (get-exception-handler-fnname try-token)
  (if (eq? try-token 'try) 'with-exception-catcher 'with-exception-handler))

(define (make-try-catch-expr try-token try-expr catch-args catch-expr finally-expr)
  (let ((try-expr (list (get-exception-handler-fnname try-token)
			(list 'lambda catch-args catch-expr)
			(list 'lambda (list) try-expr))))
    (if (void? finally-expr) try-expr
	(list 'let (list (list '*finally* (list 'lambda (list) finally-expr)))
            (list (get-exception-handler-fnname try-token)
                  (list 'lambda '(*e*) '(begin (*finally*) (raise *e*)))
                  (list 'lambda '() try-expr))
	    '(*finally*)))))
                   
(define (normalize-sym s)
  (if (and (list? s)
           (eq? (car s) 'quote))
      (cadr s)
      s))

(define (expression-with-semicolon tokenizer)
  (let ((expr (expression tokenizer)))
    (if (eq? (tokenizer 'peek) '*semicolon*)
        (tokenizer 'next))
    expr))

(define (block-expr tokenizer #!optional (use-let #f))
  (if (not (eq? (tokenizer 'peek) '*open-brace*))
      (parser-error tokenizer "Missing block start.")
      (begin (enter-scope)
             (tokenizer 'next)
             (let loop ((expr (if use-let (cons 'let (cons '() '())) (cons 'begin '())))
                        (count 0))
               (let ((token (tokenizer 'peek)))
                 (cond ((eq? token '*close-brace*)
                        (leave-scope)
                        (tokenizer 'next)
                        (if (zero? count) (append expr (list *void*)) expr))
                       ((eof-object? token)
                        (parser-error tokenizer "Unexpected end of input. Missing closing brace?"))
                       (else
                        (loop (append expr (list (expression/statement tokenizer #f)))
                              (+ 1 count)))))))))

(define (cmpr-expr tokenizer)
  (let loop ((expr (addsub-expr tokenizer)))
    (if (cmpr-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*equals*) (loop (swap-operands (append (eq-expr tokenizer) (list expr)))))
          ((*less-than*) (loop (swap-operands (append (lt-expr tokenizer) (list expr)))))
          ((*greater-than*) (loop (swap-operands (append (gt-expr tokenizer) (list expr)))))
          ((*less-than-equals*) (loop (swap-operands (append (lteq-expr tokenizer) (list expr)))))
          ((*greater-than-equals*) (loop (swap-operands (append (gteq-expr tokenizer) (list expr))))))
        expr)))

(define (logical-and-expr tokenizer)
  (let loop ((expr (logical-or-expr tokenizer)))
    (if (eq? '*and* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (append (and-expr tokenizer) (list expr)))))
        expr)))

(define (logical-or-expr tokenizer)
  (let loop ((expr (cmpr-expr tokenizer)))
    (if (eq? '*or* (tokenizer 'peek))
        (begin (tokenizer 'next)
               (loop (swap-operands (append (or-expr tokenizer) (list expr)))))
        expr)))
  
(define (addsub-expr tokenizer)
  (let loop ((expr (term-expr tokenizer)))
    (if (add-sub-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*plus*) (loop (swap-operands (append (add-expr tokenizer) (list expr)))))
          ((*minus*) (loop (swap-operands (append (sub-expr tokenizer) (list expr))))))
        expr)))

(define (factor-expr tokenizer)
  (let ((token (tokenizer 'peek)))
    (if (eq? token '*open-paren*)
        (begin (tokenizer 'next)
               (let ((expr (expression tokenizer)))
                 (if (not (eq? (tokenizer 'peek) '*close-paren*))
                     (begin (parser-error tokenizer "Missing closing parenthesis.")
                            #f)
                     (begin (tokenizer 'next)
                            (member-access/funcall-expr expr tokenizer)))))
        (let ((expr (if-expr tokenizer)))
          (if expr expr
              (let-expr tokenizer))))))

(define (handle-rvar-access sym)
  (if (rvar? sym)
      (list 'rget (normalize-rvar sym))
      sym))

(define (token->neg-number token)
  (if (number? token)
      (string->number (string-append "-" (number->string token)))
      (list '- token)))

(define (literal-expr tokenizer)
  (let ((expr (func-def-expr tokenizer)))
    (if expr
        (member-access/funcall-expr expr tokenizer)
        (let ((token (tokenizer 'peek)))
          (cond ((or (number? token)
                     (string? token)
		     (char? token))
                 (slgn-repr->scm-repr (tokenizer 'next)))
                ((add-sub-opr? token)
                 (tokenizer 'next)
                 (let ((sub (eq? token '*minus*))
                       (next (tokenizer 'peek)))
                   (if sub
                       (if (or (number? next) 
                               (valid-identifier? next))
                           (begin (tokenizer 'next)
                                  (token->neg-number next))
                           (list '- (expression tokenizer)))
                       (expression tokenizer))))                       
                ((valid-identifier? token) (handle-symbol token tokenizer))
                ((eq? token '*open-bracket*)
                 (list-literal tokenizer))
                ((eq? token '*open-brace*)
                 (block-expr tokenizer (not (tokenizer 'macro-mode?))))
                ((eq? token '*hash*)
                 (array-literal tokenizer))
		((eq? token '*quasiquote*)
		 (tokenizer 'next)
                 (let ((already-in-quote-mode (tokenizer 'quote-mode?)))
                   (tokenizer 'quote-mode-on)
                   (let ((e (expression tokenizer)))
                     (tokenizer 'quote-mode-off)
                     (if (not already-in-quote-mode) (list 'quasiquote e) e))))
                ((eq? token '*unquote*)
                 (if (not (tokenizer 'quote-mode?))
                     (parser-error tokenizer "Not in quote mode."))
                 (tokenizer 'next)
                 (let ((splice? (if (eq? (tokenizer 'peek) '*quasiquote*)
                                    (begin (tokenizer 'next) #t)
                                    #f)))
                   (list (if splice? 'unquote-splicing 'unquote) (func-body-expr tokenizer #f))))
                ((eq? token '*quote*)
                 (tokenizer 'next)
                 (let ((sym (tokenizer 'peek)))
                   (if (not (symbol? sym))
                       (parser-error tokenizer "Expected symbol."))
                   (tokenizer 'next)
                   (if (tokenizer 'quote-mode?) sym
                       (list 'quote sym))))
		((symbol? token) (handle-symbol token tokenizer))
                (else (parser-error tokenizer "Invalid literal expression.")))))))

(define (handle-symbol token tokenizer)
  (cond ((eq? token '?)                        
	 (tokenizer 'next)
	 (list 'rvar))
	(else (let ((var (tokenizer 'next)))
		(if (eq? (tokenizer 'peek) '*period*)
		    (begin (tokenizer 'next)
			   (closure-member-access var tokenizer))
		    (handle-rvar-access (slgn-repr->scm-repr var)))))))

(define (member-access/funcall-expr expr tokenizer)
  (cond ((eq? (tokenizer 'peek) '*period*)
         (begin (tokenizer 'next)
                (closure-member-access expr tokenizer)))
        ((eq? (tokenizer 'peek) '*open-paren*)
         (func-call-expr expr tokenizer))
        (else expr)))

(define (list-literal tokenizer)
  (tokenizer 'next)
  (let loop ((result (if (tokenizer 'quote-mode?) 
                         (list) 
                         (list 'list))))
    (let ((token (tokenizer 'peek)))
      (if (eq? token '*close-bracket*)
          (begin (tokenizer 'next)
                 (reverse result))
          (let ((expr (expression tokenizer)))
            (if (eq? (tokenizer 'peek) '*pipe*)
                (begin (tokenizer 'next)
                       (list-comprehension-expr tokenizer expr))
                (begin (assert-comma-separator tokenizer '*close-bracket*)
                       (loop (cons expr result)))))))))

(define (list-comprehension-expr tokenizer result-expr)
  (let ((vars-lists-filters 
         (let loop ((vars '())
                    (lists '())
                    (filters '()))
           (let ((var (tokenizer 'next))
                 (extractor (tokenizer 'next)))
             (if (and (symbol? var)
                      (eq? '*extractor* extractor))
		 (begin (check-if-reserved-name var tokenizer)
			(let ((lists (cons (expression tokenizer) lists))
			      (vars (cons var vars))
			      (filters (cons (if (eq? (tokenizer 'peek) 'where)
						 (begin (tokenizer 'next)
							(expression tokenizer))
						 #t)
					     filters)))
			  (assert-comma-separator tokenizer '*close-bracket*)
			  (loop vars lists filters)))
                 (begin (tokenizer 'put extractor)
                        (tokenizer 'put var)
                        (list (reverse vars) (reverse lists) 
                              (reverse filters))))))))
    (let ((expr (list-comprehension (cadr vars-lists-filters) 
                                    (car vars-lists-filters) 
                                    (caddr vars-lists-filters) 
                                    result-expr)))
      (let ((t (tokenizer 'next)))
        (if (not (eq? t '*close-bracket*))
            (parser-error tokenizer "Expected closing bracket.")))
      expr)))
                    
(define (byte-array-prefix? prefix tokenizer) 
  (or (eq? prefix 'u8) (eq? prefix 's8) (eq? prefix 'b)))

(define (byte-array-prefix->constructor prefix)
  (case prefix
    ((v) 'vector)
    ((u8) 'u8vector)
    ((s8) 's8vector)
    (else 'bit_array)))

(define (array-literal tokenizer)
  (tokenizer 'next)
  (let ((prefix (tokenizer 'peek)))
    (if (byte-array-prefix? prefix tokenizer)
        (tokenizer 'next)
        (set! prefix 'v))
    (if (eq? (tokenizer 'peek) '*open-bracket*)
        (begin (tokenizer 'next)
               (let loop ((expr (list (byte-array-prefix->constructor prefix)))
                          (token (tokenizer 'peek)))
                 (cond ((eq? token '*close-bracket*)
                        (tokenizer 'next)
                        (reverse expr))
                       (else (let ((e (expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-bracket*)
                               (loop (cons e expr) (tokenizer 'peek)))))))
        (parser-error tokenizer "Invalid start of array literal."))))

(define (let-expr tokenizer)
  (enter-scope)
  (let ((expr (let ((letkw (letkw? (tokenizer 'peek))))
		(if letkw
		    (begin (tokenizer 'next)
			   (if (valid-identifier? (tokenizer 'peek))
			       (named-let-expr letkw tokenizer)
			       (normal-let-expr letkw tokenizer)))
		    (func-call-expr (literal-expr tokenizer) tokenizer)))))
    (leave-scope)
    expr))

(define (normal-let-expr letkw tokenizer)
  (list letkw (let-bindings tokenizer) (func-body-expr tokenizer #f)))

(define (named-let-expr letkw tokenizer)
  (if (not (eq? letkw 'let))
      (parser-error tokenizer (string-append "Cannot define "
                                             (symbol->string letkw)
                                             " as a named let.")))
  (let ((name (tokenizer 'next)))
    (remove-macro-lazy-fns-def name)
    (list letkw name (let-bindings tokenizer) (func-body-expr tokenizer #f))))

(define (let-bindings tokenizer)
  (if (not (eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "Expected let variable bindings list."))
  (let loop ((token (tokenizer 'next))
	     (bindings '()))
    (cond ((eq? token '*close-paren*)
	   bindings)
	  ((symbol? token)
           (let ((unqoute? (eq? token '*unquote*)))
             (if unqoute?
                 (if (not (tokenizer 'quote-mode?))
                     (parser-error tokenizer "Not in quote mode.")
                     (set! token (tokenizer 'next))))
             (check-if-reserved-name token tokenizer)
             (if (not (eq? (tokenizer 'next) '*assignment*))
                 (parser-error tokenizer "Expected assignment."))
             (if (not unqoute?) (remove-macro-lazy-fns-def token))
             (let ((expr (func-body-expr tokenizer #f)))
               (let ((next (tokenizer 'peek)))
                 (if (eq? next '*comma*) 
                     (tokenizer 'next)))
               (loop (tokenizer 'next) (append bindings (list (list (if unqoute? (list 'unquote token) token) expr)))))))
	  (else (parser-error tokenizer "Expected variable declaration.")))))

(define (letkw? sym)
  (if (and (symbol? sym)
	   (or (eq? sym 'let)
	       (eq? sym 'letseq)
	       (eq? sym 'letrec)))
      (cond ((eq? sym 'letseq)
             'let*)
            (else sym))
      #f))

(define (func-def-expr tokenizer)
  (if (func-def? (tokenizer 'peek))
      (begin (tokenizer 'next)
             (let ((params (func-params-expr tokenizer)))
	       (merge-lambda params (func-body-expr tokenizer params))))
      #f))

(define (merge-lambda params lambda-body)
  (let ((lambda-expr (list 'lambda params)))
    (if (not (list? lambda-body))
        (set! lambda-body (list 'begin lambda-body)))
    (if (<= 1 (length lambda-body))
        (append lambda-expr (list lambda-body))
        (let loop ((lambda-expr lambda-expr)
                   (lambda-body (if (eq? (car lambda-body) 'begin)
                                    (cdr lambda-body)
                                    lambda-body)))
          (if (null? lambda-body)
              lambda-expr
              (loop (append lambda-expr (list (car lambda-body)))
                    (cdr lambda-body)))))))

(define (func-body-expr tokenizer params #!optional (use-let #f))
  (let ((token (tokenizer 'peek)))
    (if (or (eq? token '*semicolon*) 
            (eof-object? token))
        '(begin (quote ()))
        (begin (enter-scope)
	       (push-func-params params)
               (let ((expr (if (eq? (tokenizer 'peek) '*open-brace*)
                               (block-expr tokenizer use-let)
                               (let ((expr (statement tokenizer)))
                                 (if (not expr)
                                     (expression tokenizer)
                                     expr)))))
                 (leave-scope)
                 expr)))))

(define (func-call-expr func-val tokenizer)
  (if (and (eq? func-val '~@) (not (tokenizer 'macro-mode?)))
      (eval-ctime-func tokenizer)
      (if (and (symbol? func-val)
	       (check-if-reserved-name func-val tokenizer)
	       (get-macro-def func-val)
	       (not (tokenizer 'pattern-mode?)))
	  (macro-call-expr func-val tokenizer)
	  (let ((lazy-fn (get-lazy-def func-val)))
	    (cond ((eq? (tokenizer 'peek) '*open-paren*)
		   (if (and (symbol? func-val)
			    (check-if-reserved-name func-val tokenizer)
			    (tokenizer 'pattern-mode?))
		       (let ((s (symbol->string func-val)))
			 (set! func-val (string->symbol (string-append "+" s)))))
		   (tokenizer 'next)
		   (let ((expr (mk-func-call-expr tokenizer func-val lazy-fn)))
		     (cond ((eq? (tokenizer 'peek) '*close-paren*)
			    (tokenizer 'next) 
			    (if (eq? (tokenizer 'peek) '*period*)
				(member-access/funcall-expr expr tokenizer)
				expr))
			   (else (parser-error tokenizer "Missing closing parenthesis after function argument list.")))))
		  (else func-val))))))

(define (eval-ctime-func tokenizer)
  (if (not (eq? (tokenizer 'next) '*open-paren*))
      (parser-error tokenizer "Expected opening parenthesis."))
  (let ((expr (expression tokenizer)))
    (if (not (eq? (tokenizer 'next) '*close-paren*))
	(parser-error tokenizer "Expected closing parenthesis."))
    (eval expr)))

(define (mk-func-call-expr tokenizer func-val lazy-fn)
  (let ((expr (func-args-expr tokenizer lazy-fn)))
    (if (and (not (null? expr)) (not lazy-fn) 
             (eq? func-val 'task))
        (if (or (not (list? (car expr))) 
                (not (eq? (caar expr) 'lambda)))
            (set! expr (cons (merge-lambda '() (car expr)) (cdr expr)))))
    (cons func-val expr)))

(define (macro-args-list tokenizer)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (not (eq? token '*close-paren*))
          (let ((expr (func-body-expr tokenizer #f #t)))
            (assert-comma-separator tokenizer '*close-paren*)
            (loop (append args (list expr))))
          args))))

(define (macro-call-expr macro-name tokenizer)
  (if (not (eq? (tokenizer 'peek) '*open-paren*))
      (parser-error tokenizer "Missing macro argument list.")
      (tokenizer 'next))
  (let ((args (func-args-expr tokenizer #f)))
    (if (not (eq? '*close-paren* (tokenizer 'next)))
        (parser-error tokenizer "Missing closing parenthesis after macro argument list."))
    (expand-macro macro-name args)))

(define (expand-macro macro-name args)
  (let ((expr (apply (eval macro-name) args)))
    (if (pair? expr)
        (let loop ((expr expr)
                   (result '()))
          (cond
           ((null? expr) (reverse result))
           ((pair? (car expr))
            (if (get-macro-def (caar expr))
                (loop (cdr expr) (cons (expand-macro (caar expr) (cdar expr)) result))
                (loop (cdr expr) (cons (car expr) result))))
           (else (loop (cdr expr) (cons (car expr) result)))))
        expr)))              

(define (record-def-stmt tokenizer)
  (if (eq? (tokenizer 'peek) 'record)
      (begin (tokenizer 'next)
	     (let ((token (tokenizer 'peek)))
	       (if (not (valid-identifier? token))
		   (parser-error tokenizer "Missing record name."))
	       (mk-record-expr (tokenizer 'next) tokenizer)))
      (macro-def-stmt tokenizer)))

(define (rec-get-precond tokenizer)
  (tokenizer 'next)
  (let ((precond (expression tokenizer)))
    (assert-comma-separator tokenizer '*close-paren*)
    precond))
  
(define (rec-get-field-def tokenizer)
  (cond ((eq? (tokenizer 'peek) '*assignment*)
         (tokenizer 'next)
         (let ((val (expression tokenizer)))
           (if (eq? (tokenizer 'peek) 'where)
               (cons val (rec-get-precond tokenizer))
               (begin (assert-comma-separator tokenizer '*close-paren*)
                      (cons val #t)))))
        (else
         (if (eq? (tokenizer 'peek) 'where)
             (cons #f (rec-get-precond tokenizer))
             (begin (assert-comma-separator tokenizer '*close-paren*)
                    (cons #f #t))))))
  
(define (mk-record-expr name tokenizer)
  (cond ((eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((token (tokenizer 'peek))
                    (members '()) (default-values '())
                    (preconds '()))
           (cond ((valid-identifier? token)
                  (let ((token (tokenizer 'next))
                        (fdef (rec-get-field-def tokenizer)))
                    (loop (tokenizer 'peek) (cons token members)
                          (cons (car fdef) default-values) 
                          (cons (cdr fdef) preconds))))
                 ((eq? token '*close-paren*)
                  (tokenizer 'next)
                  (def-struct-expr name (reverse members) (reverse default-values) (reverse preconds)))
                 (else (parser-error tokenizer "Invalid record specification.")))))
        (else (parser-error tokenizer "Expected record member specification."))))

(define (def-struct-expr name members default-values preconds)
  (append (list 'begin (append (list 'define-structure name) members))
	  (mk-struct-accessors/modifiers name members default-values preconds)))

(define (mk-record-precond-expr precond mem)
  (list 'if (list 'not precond) (list 'error (with-output-to-string 
                                               '()
                                               (lambda () 
                                                 (display "Precondition failed: ")
                                                 (display precond)
                                                 (display ".")))
                                      mem)))

(define (mk-record-precond-exprs preconds mems)
  (let loop ((preconds preconds) (mems mems) (result '()))
    (if (null? preconds) (append (list 'begin) (reverse result))
        (loop (cdr preconds) (cdr mems)
              (cons (mk-record-precond-expr (car preconds) (car mems)) result)))))
        
(define (mk-record-constructor recname members default-values preconds)
  (append (list 'lambda (append (list '#!key) (mk-record-constructor-params members default-values)))
          (list (mk-record-precond-exprs preconds members) 
                (cons (string->symbol (string-append "make-" (add-namespace-prefix recname))) members))))

(define (mk-record-constructor-params members default-values)
  (let loop ((members members) (default-values default-values) 
             (params '()))
    (cond ((null? members) (reverse params))
          (else (loop (cdr members) (cdr default-values)
                      (cons (list (car members) 
                                  (car default-values)) params))))))

(define (mk-struct-accessors/modifiers name members default-values preconds)
  (let ((sname (symbol->string name)))
    (let loop ((members members)
               (preconds preconds)
               (i 0)
               (expr (list 
                      (list 'define (string->symbol sname) 
                            (mk-record-constructor sname members default-values preconds))
                      (list 'define (string->symbol (string-append "make_" sname))
                            (string->symbol (string-append "make-" (add-namespace-prefix sname))))
                      (list 'define 
                            (string->symbol (string-append "is_" sname))
                            (string->symbol (add-namespace-prefix (string-append sname "?")))))))
      (if (null? members) (reverse expr)
          (begin (loop (cdr members) (cdr preconds) (+ i 1)
                       (append expr (member-accessor/modifier name (car members) (car preconds) i))))))))

(define (member-accessor/modifier name mem precond index)
  (let ((sname (symbol->string name))
	(smem (symbol->string mem)))
    (let ((scm-accessor (string->symbol (add-namespace-prefix (string-append sname "-" smem))))
	  (scm-modifier (string->symbol (add-namespace-prefix (string-append sname "-" smem "-set!"))))
	  (slgn-accessor (string->symbol (string-append sname "_" smem)))
          (idx-accessor (string->symbol (string-append sname "-" (number->string index))))
	  (slgn-modifier (string->symbol (string-append sname "_set_" smem))))
      (list (list 'define slgn-accessor scm-accessor)
            (list 'define idx-accessor scm-accessor)
	    (list 'define slgn-modifier (append (list 'lambda (list '*s* mem)) 
                                                (append (list (mk-record-precond-expr precond mem))
                                                        (list (list scm-modifier '*s* mem)))))))))

(define (assert-comma-separator tokenizer end-seq-char #!optional comma-required)
  (let ((token (tokenizer 'peek)))
    (if (or (eq? token '*comma*)
            (if (list? end-seq-char) 
                (memq token end-seq-char) 
                (eq? token end-seq-char)))
        (if (eq? token '*comma*) (tokenizer 'next))
        (if comma-required
            (parser-error tokenizer (with-output-to-string
                                      '()
                                      (lambda ()
                                        (display "Missing comma or ") 
                                        (slgn-display end-seq-char) 
                                        (display "."))))))))

(define (func-args-expr tokenizer lazy-fn)
  (let loop ((args '()))
    (let ((token (tokenizer 'peek)))
      (if (not (eq? token '*close-paren*))
          (cond ((valid-identifier? token)
                 (let ((sym (tokenizer 'next)))
                   (if (eq? (tokenizer 'peek) '*assignment*)
                       (begin (tokenizer 'next)
                              (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (append args (list (slgn-variable->scm-keyword sym) expr)))))
                       (begin (tokenizer 'put sym)
                              (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                                (assert-comma-separator tokenizer '*close-paren*)
                                (loop (append args (list expr))))))))
                (else
                 (let ((expr (expr-lazify lazy-fn (expression tokenizer))))
                   (assert-comma-separator tokenizer '*close-paren*)
                   (loop (append args (list expr))))))
          args))))

(define (check-if-reserved-name sym tokenizer)
  (if (or (reserved-name? sym)
	  (is_special_token sym))
      (parser-error tokenizer (string-append "Invalid use of keyword or operator: "
                                             (symbol->string sym) "."))
      sym))

(define (valid-identifier? sym)
  (and (symbol? sym)
       (not (or (reserved-name? sym)
		(is_special_token sym)))))
  
(define (check-func-param tokenizer) 
  (check-if-reserved-name (tokenizer 'peek) tokenizer)
  (tokenizer 'next))

(define (func-params-expr tokenizer)
  (cond ((eq? (tokenizer 'peek) '*open-paren*)
         (tokenizer 'next)
         (let loop ((params '())
                    (directives-found #f))
           (let ((token (tokenizer 'peek)))
             (cond ((valid-identifier? token)
                    (let ((sym (check-func-param tokenizer)))
                      (cond ((param-directive? sym)
                             (loop (cons (slgn-directive->scm-directive sym) params) #t))
                            ((eq? (tokenizer 'peek) '*assignment*)
                             (tokenizer 'next)
                             (let ((expr (expression tokenizer)))
                               (assert-comma-separator tokenizer '*close-paren*)
                               (if directives-found
                                   (loop (cons (list sym expr) params) directives-found)
				   (loop (cons 
					  (list sym expr) 
					  (cons 
					   (slgn-directive->scm-directive '@optional) params)) 
					 #t))))
                            (else 
                             (assert-comma-separator tokenizer '*close-paren*)
                             (loop (cons sym params) directives-found)))))
                   ((eq? '*unquote* token)
                    (if (not (tokenizer 'quote-mode?))
                        (parser-error tokenizer "Not in quote more.")
                        (begin (assert-comma-separator tokenizer '*close-paren*)
                               (loop (cons (expression tokenizer) params)
                                     directives-found))))
                   (else
                    (if (eq? token '*close-paren*)
                        (begin (tokenizer 'next)
                               (reverse params))
                        (parser-error tokenizer "Missing closing parenthesis after parameter list.")))))))
        ((valid-identifier? (tokenizer 'peek))
         (check-func-param tokenizer))
        (else 
         (parser-error tokenizer "Missing opening parenthesis at the start of parameter list."))))

(define (param-directive? sym)
  (memq sym '(@optional @key @rest)))

(define (closure-member-access var tokenizer)
  (if (valid-identifier? (tokenizer 'peek))
      (let loop ((expr `(,var ',(tokenizer 'next))))
	(if (eq? (tokenizer 'peek) '*period*)
	    (begin (tokenizer 'next)
		   (if (valid-identifier? (tokenizer 'peek))
		       (loop (cons expr `(',(tokenizer 'next))))
		       (parser-error tokenizer "Expected identifier.")))
	    expr))
      (parser-error tokenizer "Expected identifier.")))

(define (add-expr tokenizer)
  (swap-operands (cons '+ (list (term-expr tokenizer)))))

(define (sub-expr tokenizer)
  (swap-operands (cons '- (list (term-expr tokenizer)))))

(define (mult-expr tokenizer)
  (swap-operands (cons '* (list (factor-expr tokenizer)))))

(define (div-expr tokenizer)
  (swap-operands (cons '/ (list (factor-expr tokenizer)))))

(define (eq-expr tokenizer)
  (swap-operands (cons 'equal? (list (addsub-expr tokenizer)))))

(define (lt-expr tokenizer)
  (swap-operands (cons '< (list (addsub-expr tokenizer)))))

(define (lteq-expr tokenizer)
  (swap-operands (cons '<= (list (addsub-expr tokenizer)))))

(define (gt-expr tokenizer)
  (swap-operands (cons '> (list (addsub-expr tokenizer)))))

(define (gteq-expr tokenizer)
  (swap-operands (cons '>= (list (addsub-expr tokenizer)))))

(define (and-expr tokenizer)
  (swap-operands (cons 'and (list (logical-or-expr tokenizer)))))

(define (or-expr tokenizer)
  (swap-operands (cons 'or (list (cmpr-expr tokenizer)))))

(define (term-expr tokenizer)
  (let loop ((expr (factor-expr tokenizer)))
    (if (mult-div-opr? (tokenizer 'peek))
        (case (tokenizer 'next)
          ((*asterisk*) (loop (swap-operands (append (mult-expr tokenizer) (list expr)))))
          ((*backslash*) (loop (swap-operands (append (div-expr tokenizer) (list expr))))))
        expr)))

(define (add-sub-opr? token)
  (or (eq? token '*plus*)
      (eq? token '*minus*)))

(define (mult-div-opr? token)
  (or (eq? token '*asterisk*)
      (eq? token '*backslash*)))

(define (cmpr-opr? token)
  (or (eq? token '*equals*)
      (eq? token '*less-than*)
      (eq? token '*greater-than*)
      (eq? token '*less-than-equals*)
      (eq? token '*greater-than-equals*)))

(define (and-or-opr? token)
  (or (eq? token '*and*)
      (eq? token '*or*)))

(define (swap-operands expr)
  (if (= 3 (length expr))
      (list (car expr) (caddr expr) (cadr expr))
      expr))

(define *reserved-names* '(fn function method define record true false
			      if else let letseq letrec 
			      case match where try trycc catch finally
                              macro load namespace import declare))

(define (reserved-name? sym)
  (and (symbol? sym)
       (memq sym *reserved-names*)))

(define (parened-names->list tokenizer)
  (if (eq? (tokenizer 'next) '*open-paren*)
      (let loop ((token (tokenizer 'next))
                 (result '()))
        (cond ((eq? token '*close-paren*)
               (reverse result))
              ((valid-identifier? token)
               (assert-comma-separator tokenizer '*close-paren*)
               (loop (tokenizer 'next) (cons token result)))
              (else #f)))
      #f))
