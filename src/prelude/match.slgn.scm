;; Copyright (c) 2013-2014 by Vijay Mathew Pandyalakal, All Rights Reserved.

(define-structure record-pattern name members)

(define (normalize-list-for-matching lst)
  (if (and (list? lst)
           (not (null? lst)))
      (if (eq? (car lst) 'list)
          (cdr lst)
          (list->record-pattern lst))
      lst))

(define (list->record-pattern lst)
  (if (symbol? (car lst))
      (let ((name (symbol->string (car lst))))
        (if (char=? #\+ (string-ref name 0))
            (let loop ((name (substring name 1 (string-length name)))
                       (lst (cdr lst))
                       (members '()))
              (cond ((null? lst)
                     (make-record-pattern name (reverse members)))
                    (else 
                     (if (keyword? (car lst))
                         (loop name (cddr lst)
                               (cons (cons (keyword->string (car lst)) (cadr lst)) members))
                         (loop name (cdr lst)
                               (cons (car lst) members))))))
            lst))
      lst))

(define (cons? pattern)
  (and (list? pattern)
       (eq? (car pattern) 'cons)))

(define (match-pattern pattern consequent)
  (set! pattern (normalize-list-for-matching pattern))
  (cond ((eq? pattern 'else)
         `(if (not *match-found*)
              (begin (set! *result* ,consequent)
                     (set! *match-found* #t)
                     *result*)))
        ((null? pattern)
         `(if (and (not *match-found*) (null? *value*))
              (begin (set! *result* ,consequent)
                     (set! *match-found* #t)
                     *result*)))
        ((cons? pattern)
         (set! pattern (cdr pattern))
         `(if (and (not *match-found*) (pair? *value*))
              (let ((*rest* (cdr *value*))
                    (*value* (car *value*)))
                ,(match-pattern (car pattern) `(let ((*value* *rest*))
                                                 ,(match-pattern (cadr pattern)
                                                                 consequent))))))
        ((list? pattern)
         (let ((pattern-length (length pattern)))
           (cond ((scm-symbol? (car pattern))
                  `(if (and (not *match-found*) (list? *value*) 
                            (= ,pattern-length (length *value*)))
                       (let ((,(car pattern) (car *value*))
                             (*value* (cdr *value*)))
                         ,(match-pattern (cdr pattern) consequent))))
                 ((record-pattern? (car pattern))
                  `(let ((*rest* (cdr *value*))
                         (*value* (car *value*)))
                     ,(match-record-pattern (car pattern) #f)
                     (if *match-found*
                         (begin (set! *match-found* #f)
                                (set! *value* *rest*)
                                ,(match-pattern (cdr pattern) consequent)))))
                 ((list? (car pattern))
                  `(let ((*rest* (cdr *value*))
                         (*value* (car *value*)))
                     ,(match-pattern (car pattern) #f)
                     (if *match-found*
                         (begin (set! *match-found* #f)
                                (set! *value* *rest*)
                                ,(match-pattern (cdr pattern) consequent)))))
                 (else                   
                  `(if (and (not *match-found*) (list? *value*) 
                            (= ,pattern-length (length *value*)))
                       (if (equal? ,(car pattern) (car *value*))
                           (let ((*value* (cdr *value*)))
                             ,(match-pattern (cdr pattern) consequent))))))))
        ((scm-symbol? pattern)
         `(if (not *match-found*) 
              (let ((,pattern *value*)) 
                (set! *result* ,consequent)
                (set! *match-found* #t) 
                *result*)))
        ((record-pattern? pattern)
         (match-record-pattern pattern consequent))
        (else `(if (and (not *match-found*) (equal? ,pattern *value*))
                   (begin (set! *result* ,consequent)
                          (set! *match-found* #t) 
                          *result*)))))

(define (match-record-pattern pattern consequent)
  (let ((predic (string->symbol (string-append (record-pattern-name pattern) "?"))))
    (let ((prefix `(if (and (not *match-found*) (,predic *value*)))))
      (let loop ((members (record-pattern-members pattern))
                 (conds '())
                 (bindings '()))
        (cond ((null? members)
               (let ((new-consequent `(begin (set! *result* ,consequent)
                                             (set! *match-found* #t)
                                             *result*)))
                 (let ((body (if (null? bindings) 
                                 new-consequent
                                 `(let (,@(reverse bindings)) ,new-consequent))))
                   (append prefix (list (if (null? conds) `(if #t ,body) `(if (and ,@(reverse conds)) ,body)))))))
              ((symbol? (car members))
               (let ((accessor (string->symbol (string-append (record-pattern-name pattern)
                                                              "-" (symbol->string (car members))))))
                 (loop (cdr members) conds (cons `(,(car members) (,accessor *value*)) bindings))))
              ((pair? (car members))
               (let ((accessor (string->symbol (string-append (record-pattern-name pattern)
                                                              "-" (caar members)))))
                 (loop (cdr members) (cons `(equal? ,(cdar members) (,accessor *value*)) conds) bindings)))
              (else
               (error "Invalid record pattern: " pattern)))))))
