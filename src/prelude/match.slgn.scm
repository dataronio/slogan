(define (atomic-literal? pattern)
  (or (slgn-symbol? pattern)
      (string? pattern)
      (number? pattern)
      (char? pattern)))

(define (normalize-list-for-matching lst)
  (if (and (list? lst)
           (not (null? lst))
           (eq? (car lst) 'list))
      (cdr lst)
      lst))

(define (match-pattern pattern value consequent tokenizer)
  (set! pattern (normalize-list-for-matching pattern))
  `((match? ',pattern ,value) (eval (bind-pattern-vars ',pattern 
                                                       ,value
                                                       ',consequent))))

(define (bind-pattern-vars pattern value body)
  (cond ((null? pattern) body)
        ((and (symbol? pattern)
              (not (slgn-symbol? pattern))
              (not (eq? pattern '_)))
         `(let ((,pattern ,value)) ,body))
        ((list? pattern)
         (if (eq? (car pattern) '__)
             `(let ((,(cadr pattern) ,(cdr value))) ,body)
             (bind-pattern-vars (car pattern)
                                (car value)
                                (bind-pattern-vars (cdr pattern)
                                                   (cdr value)
                                                   body))))
        (else body)))

(define (match? pattern value)
  (cond ((symbol? pattern) #t)
        ((and (null? pattern) (null? value)) #t)
        ((and (list? pattern) (list? value))
         (cond ((= (length pattern) (length value))
                (and (match? (car pattern) (car value))
                     (match? (cdr pattern) (cdr value))))
               ((eq? (car pattern) '__)
                (match? (cadr pattern) value))
               (else #f)))
        (else (equal? pattern value))))

