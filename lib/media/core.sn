namespace media_core;

function load_lib() ffi_open(string_append(getenv("SLOGAN_ROOT") "/lib/media/c/media.so"));
define lib_handle = load_lib();
function release_lib() ffi_close(lib_handle);

function flags_to_intlist(flags, mapping) 
    let loop (flags = flags, iflags = []) 
        if (is_empty(flags)) reverse(iflags) 
        else let (f = get(first(flags), mapping)) 
            if (f) loop(tail(flags), f : iflags)
            else error("Invalid flag -" first(flags));

define init_flags = %[haptic : 0,
                      audio : 1,
                      video : 2,
                      timer : 3,
                      joystick : 4,
                      everything : 5,
                      noparachute : 6];

function initialize(flags = %[everything]) 
    ffi_call_obj_1(lib_handle, "_media_init",
                   flags_to_intlist(flags, init_flags));

function release() 
    ffi_call_void_0(lib_handle, "_media_release");

function get_error() 
    ffi_call_obj_0(lib_handle, "_media_get_error");
    
define window_flags = %[fullscreen : 0,
                        opengl : 1,
                        shown : 2,
                        hidden : 3,
                        borderless : 4,
                        resizable : 5,
                        minimized : 6,
                        maximized : 7,
                        input_grabbed : 8,
                        input_focus : 9,
                        mouse_focus : 10,
                        foreign : 11];
    
function create_window(title, x, y, w, h, flags = %[shown]) 
    ffi_call_void_pointer_6(lib_handle,
                            "_media_create_window"
                            title, x, y, w, h,
                            flags_to_intlist(flags, window_flags));

function destroy_window(w) 
    ffi_call_void_with_void_pointer_1(lib_handle,
                                      "_media_destroy_window",
                                      w);                                      

function show_window(w) 
    ffi_call_void_with_void_pointer_1(lib_handle,
                                      "_media_show_window",
                                      w);                                      

function hide_window(w) 
    ffi_call_void_with_void_pointer_1(lib_handle,
                                      "_media_hide_window",
                                      w);                                      

function get_window_surface(w) 
    ffi_call_void_pointer_with_void_pointer_1(lib_handle,
                                              "_media_get_window_surface",
                                              w);

function update_window_surface(w) 
    ffi_call_obj_with_void_pointer_1(lib_handle,
                                     "_media_update_window_surface",
                                     w);

function texture_from_surface(rd, s) 
    ffi_call_void_pointer_with_void_pointer_2(lib_handle,
                                              "_media_texture_from_surface",
                                              rd, s);

function destroy_surface(s) 
    ffi_call_void_with_void_pointer_1(lib_handle, "_media_free_surface", s);

function destroy_texture(t) 
    ffi_call_void_with_void_pointer_1(lib_handle, "_media_free_texture", t);
    
define renderer_flags = %[software : 0,
                          accelerated : 1,
                          presentvsync : 2,
                          targettexture : 3];

function create_renderer(w, d, flags = []) 
    ffi_call_void_pointer_with_void_pointer_3(lib_handle,
                                              "_media_create_renderer"
                                              w, d,
                                              flags_to_intlist(flags, renderer_flags));

function destroy_renderer(rd) 
    ffi_call_void_with_void_pointer_1(lib_handle,
                                      "_media_destroy_renderer",
                                      rd);

function set_render_color(rd, r, g, b, a) 
    ffi_call_obj_with_void_pointer_5(lib_handle,
                                     "_media_set_render_color",
                                     rd, r, g, b, a);

function render_clear(rd) 
    ffi_call_obj_with_void_pointer_1(lib_handle,
                                     "_media_render_clear",
                                     rd);

function render_present(rd) 
    ffi_call_void_with_void_pointer_1(lib_handle,
                                      "_media_render_present",
                                      rd);

function sleep(ms) ffi_call_void_1(lib_handle, "_media_delay", ms);

function handle_event() 
    ffi_call_obj_0(lib_handle, "_media_handle_event");

function load_image(rd, path) 
    ffi_call_void_pointer_with_void_pointer_2(lib_handle,
                                              "_media_load_image", rd, path);

function render_copy(rd, texture, x, y, w = -1, h = -1,
                     angle = 0.0, center = [], flip = 0) 
    ffi_call_obj_8(lib_handle, "_media_render_copy",
                   [rd, texture], x, y, w, h,
                   angle, center, flip);

function render_line(rd, x1, y1, x2, y2) 
    ffi_call_obj_with_void_pointer_5(lib_handle, "_media_render_line",
                                     rd, x1, y1, x2, y2);

function render_lines(rd, points) 
    ffi_call_obj_with_void_pointer_2(lib_handle, "_media_render_lines",
                                     rd, points);

function render_rect(rd, x, y, w, h, fill = false) 
    ffi_call_obj_with_void_pointer_6(lib_handle, "_media_render_rect",
                                     rd, x, y, w, h, fill);

function render_point(rd, x, y) 
    ffi_call_obj_with_void_pointer_3(lib_handle, "_media_render_point",
                                     rd, x, y);

function render_circle(rd, x0, y0, radius) 
    let loop (x = radius,
              y = 0,
              decisionOver2 = 1 - radius) 
        if (y <= x) {
            render_point(rd, x + x0,  y + y0);
            render_point(rd, y + x0,  x + y0);
            render_point(rd, -x + x0,  y + y0);
            render_point(rd, -y + x0,  x + y0);
            render_point(rd, -x + x0, -y + y0);
            render_point(rd, -y + x0, -x + y0);
            render_point(rd, x + x0, -y + y0);
            render_point(rd, y + x0, -x + y0);
            y = y + 1;
            if (decisionOver2 <= 0)
                decisionOver2 = decisionOver2 + (2 * y + 1)
            else {
                x = x - 1;
                decisionOver2 = decisionOver2 + (2 * (y - x) + 1)
            };
            loop(x, y, decisionOver2)
        };

define colors = %[red : [255, 0, 0, 255],
                  green : [0, 255, 0, 255],
                  blue : [0, 0, 255, 255],
                  black : [0, 0, 0, 255],
                  white : [255, 255, 255, 255]];

function valid_color_value(v) is_integer(v) && v >= 0 && v <= 255;

function color_to_rgba(color) 
    if (is_symbol(color))
        let (rgba = get(color, colors)) 
            if (not(rgba)) [0, 0, 0, 255]
            else rgba
    else if (is_list(color) && length(color) == 4 && for_all(valid_color_value, color))
        color
    else error("invalid color specification - " color);
    
function line(surface, color, sxy, exy, width = 1)  
    ffi_call_obj_with_void_pointer_5(lib_handle,
                                     "_media_draw_line",
                                     surface, color_to_rgba(color),
                                     sxy, exy, width);

function ellipse(surface, color, bounds, width = 1) 
    ffi_call_obj_with_void_pointer_4(lib_handle,
                                     "_media_draw_ellipse",
                                     surface, color_to_rgba(color),
                                     bounds, width);

function circle(surface, color, x, y, radius, width = 1) 
    ffi_call_obj_with_void_pointer_6(lib_handle,
                                     "_media_draw_circle",
                                     surface, color_to_rgba(color),
                                     x, y, radius, width);

function arc(surface, color, bounds, sangle, eangle, width = 1) 
    ffi_call_obj_with_void_pointer_6(lib_handle,
                                     "_media_draw_arc",
                                     surface, color_to_rgba(color),
                                     bounds, sangle, eangle, width);

function polygon(surface, color, points, width = 1) 
    ffi_call_obj_with_void_pointer_4(lib_handle,
                                     "_media_draw_polygon",
                                     surface, color_to_rgba(color),
                                     points, width);

function rect(surface, color, rect, width = 1) 
    let (x = first(rect), y = second(rect),
         w = third(rect), h = fourth(rect))
        let (l = x, r = x + w - 1,
	     t = y, b = y + h - 1) 
            polygon(surface, color,
                    [l : t, r : t,
                     r : b, l : b],
                    width);


// Drawing text:

function text_init() 
    ffi_call_obj_0(lib_handle, "_media_text_init");

function text_quit() 
    ffi_call_void_0(lib_handle, "_media_text_quit");

function text_open_font(font_file, ptsize) 
    ffi_call_void_pointer_2(lib_handle,
                            "_media_text_open_font",
                            font_file, ptsize);

function text_close_font(font) 
    ffi_call_void_with_void_pointer_1(lib_handle, "_media_text_close_font", font);

function text_on_solid_surface(font, text, rgba) 
    ffi_call_void_pointer_with_void_pointer_3(lib_handle,
                                              "_media_text_render_solid",
                                              font, text, rgba);

namespace;
