/**
 * Parsing DER and PEM encoded certificates.
 * See the README file for sample usage.
 * Copyright (c) 2013-2015 by Vijay Mathew Pandyalakal, All Rights Reserved.
 **/

namespace crypto;
namespace cert;

record asn1_cert(constructed, tag_class, tag, data, children);

function pointer_to_asn1_cert(p) 
    let loop (p = p, result = []) 
        if (p) 
            let (data = make_u8array(ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                      "crypto_asn1_cert_length", p))) {
                ffi_call_void_with_void_pointer_2(__crypto_lib_handle, "crypto_asn1_cert_data", p, data);
                loop(ffi_call_void_pointer_with_void_pointer_1(__crypto_lib_handle,
                                                               "crypto_asn1_cert_next", p),
                     asn1_cert(constructed = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                              "crypto_asn1_cert_constructed", p),
                               tag_class = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                            "crypto_asn1_cert_tagclass", p),
                               tag = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                      "crypto_asn1_cert_tag", p),
                               data = data,
                               children = pointer_to_asn1_cert(ffi_call_void_pointer_with_void_pointer_1(__crypto_lib_handle,
                                                                                                         "crypto_asn1_cert_children", p)))
                     : result)
            }
        else reverse(result);
                           
function asn1_parse(data) 
    letseq (c = ffi_call_void_pointer_2(__crypto_lib_handle,
                                     "crypto_asn1_parse",
                                        data, u8array_length(data)),
            r = pointer_to_asn1_cert(c)) {
        ffi_call_void_with_void_pointer_1(__crypto_lib_handle,
                                          "crypto_asn1_cert_free", c);
        r
    };
    
function pem_decode(pemdata) 
    let (d = make_u8array(u8array_length(pemdata))) {
        ffi_call_void_2(__crypto_lib_handle,
                        "crypto_pem_decode",
                        pemdata, d);
        d
    };


record name(cn, org_unit, org, locality, state, country);
record public_key_info(algorithm, rsa_public_key, dsa_parameters, dsa_public_key);

record x509_cert(hash, signature_algorithm,
                 rsa_signature_value,
                 dsa_signature_value,
                 version, serial, signature,
                 issuer, subject, validity,
                 issuer_uid, subject_uid,
                 certification_authority,
                 pubkey_info);

function list_to_name(xs) 
    name(country = first(xs),
         state = second(xs),
         locality = third(xs),
         org = fourth(xs),
         org_unit = fifth(xs),
         cn = sixth(xs));

function list_to_pubkeyinfo(xs) 
    public_key_info(algorithm = first(xs),
                    rsa_public_key = second(xs),
                    dsa_parameters = third(xs),
                    dsa_public_key = fourth(xs));
    
function x509_parse(data, ispem) 
    let (c = ffi_call_void_pointer_3(__crypto_lib_handle
                                     "crypto_parse_x509",
                                     data, u8array_length(data),
                                     if (ispem) 1 else 0)) 
        if (not(c)) c
        else 
            let (h = make_array(ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                 "crypto_x509_cert_hashlen", c))) {
                ffi_call_void_with_void_pointer_2(__crypto_lib_handle, "crypto_x509_cert_hash", c, h);
                let (r = x509_cert(hash = h,
                                   signature_algorithm = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                          "crypto_x509_cert_signalgo", c),
                                   rsa_signature_value = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                          "crypto_x509_cert_rsa_sign_value", c),
                                   dsa_signature_value = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                          "crypto_x509_cert_dsa_sign_value", c),
                                   version = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                              "crypto_x509_cert_version", c),
                                   serial = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                             "crypto_x509_cert_serial", c),
                                   signature = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                "crypto_x509_cert_signature", c),
                                   issuer = list_to_name(ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                          "crypto_x509_cert_issuer", c)),
                                   subject = list_to_name(ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                           "crypto_x509_cert_subject", c)),
                                   validity = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                               "crypto_x509_cert_validity", c),
                                   issuer_uid = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                            "crypto_x509_cert_issueruid", c),
                                   subject_uid = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                  "crypto_x509_cert_subjectuid", c),
                                   certification_authority = ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                              "crypto_x509_cert_certautho", c),
                                   pubkey_info = list_to_pubkeyinfo(ffi_call_obj_with_void_pointer_1(__crypto_lib_handle,
                                                                                                     "crypto_x509_cert_pubkey_info", c)))) {
                    ffi_call_void_with_void_pointer_1(__crypto_lib_handle, "crypto_free_x509_cert", c);
                    r
                }
            };
        
namespace;
namespace;