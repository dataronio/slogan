/**
 * RC4 stream cipher.
 * See the README file for sample usage.
 * Copyright (c) 2013-2015 by Vijay Mathew Pandyalakal, All Rights Reserved.
 **/

namespace crypto;
namespace rc4;

function combksched(s, key, klen) 
    let loop (i = 0, j = 0)
        if (i < 256) 
            letseq (a = u8array_at(s, i)
                    j = mod(j + a + char_to_integer(string_at(key, mod(0, klen))), 256)) {
                u8array_set(s, i, u8array_at(s, j));
                u8array_set(s, j, a);
                loop(inc(i), j)
            };

record state(inited, i, j, s);

function init() state(inited = false, i = 0, j = 0, s = list_to_u8array(range(0, 255)));

function encdec(p, plen, s, out, state) 
    let loop (i = state_i(state), j = state_j(state),
              c = 0, plen = plen) 
        if (plen > 0) {
            i = mod(i + 1, 256);
            let (tmp = u8array_at(s, i)) {
                j = mod(j + tmp, 256);
                u8array_set(s, i, u8array_at(s, j));
                u8array_set(s, j, tmp);
                u8array_set(out, c, bitwise_xor(u8array_at(s, mod(u8array_at(s, i) + u8array_at(s, j), 256)),
                                                u8array_at(p, c)));
                loop(i, j, inc(c), plen - 1)
            }
        } else {
            state_set_i(state, i);
            state_set_j(state, j)
        };

function opr(in, key, klen, state = false) {
    if (state == false) state = init();
    let (s = state_s(state)
         plen = u8array_length(in)) 
    let (out = make_u8array(plen)) {
        if (not(state_inited(state))) {
            combksched(s, key, klen);
            state_set_inited(state, true)
        };
        encdec(in, plen, s, out, state);
        out
    }
};

function encdec_40(key, in, state = false) opr(in, key, 5, state);
function encdec_128(key, in, state = false) opr(in, key, 16, state);

define encrypt_40 = encdec_40;
define decrypt_40 = encdec_40;
define encrypt_128 = encdec_128;
define decrypt_128 = encdec_128;

namespace;
namespace;