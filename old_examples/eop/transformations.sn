// Returns number of steps reuired to reach y from x by repeatedly transforming
// x by applying f.
var distance = function (x, y, f, eq = is_equal)
    letrec dist_helper = function(x, y, n)
        if eq (x, y) n
        else dist_helper (f (x), y, n + 1)
    dist_helper (x, y, 0);

// Returns the collision point (where a cycle starts) of a transformation.
// If there is no collision point, the termination point is returned.
var collision_point = function (x, f, p, eq = is_equal)
    if not (p (x)) x
    else letrec loop = function (slow, fast)
            if not (eq (slow, fast))
               if not (p (fast)) fast
               else {
                   fast = f (fast);
                   if p (fast) loop (f (slow), f (fast))
                   else fast
               }
          loop (x, f (x));

var always_true = function (x) true;

var collision_point_nonterminating_orbit = function (x, f, eq = is_equal) 
    collision_point (x, f, always_true, is_eq);

// Determines whether an orbit is terminating.
var is_terminating = function (x, f, p, eq = is_equal) 
    not (p (collision_point (x, f, p, eq)));

var is_circular_nonterminating_orbit = function (x, f, eq = is_equal)  
    eq (x, f (collision_point_nonterminating_orbit (x, f, eq)));

var is_circular = function (x, f, p, eq = is_equal)
    let y = collision_point (x, f, p, eq) 
    p (y) && eq (x, f (y));
            
var convergent_point = function (x0, x1, f, eq = is_equal)
    letrec loop = function (x0, x1)
        if eq (x0, x1) x0
        else loop (f (x0), f (x1))
    loop (x0, x1);

var connection_point_nonterminating_orbit = function (x, f, eq = is_equal)
    convergent_point (x, f (collision_point_nonterminating_orbit (x, f, eq)), f, eq);

var connection_point = function (x, f, p, eq = is_equal)
    let y = collision_point (x, f, p, eq)
        if not (p (y)) y
        else convergent_point (x, f (y), f, eq);
    
                
            
