assert 1 + 2 == 3;
assert (1 + 2 <> 3) == false;
assert 1 + 2 * 5 == 11;
assert 1 + 2 <= 3;
assert 1 + 2 <= 3 && 4 * 3 == 12;
assert 1 + 2 > 3 || 4 * 3 == 12;

let a,b = 10, a+20;
assert a == 10;
assert b == 30;

function recur(a)
  if (a > 0) recur(a - 1)
  else a;

assert recur(10) == 0;
assert recur(-10) == -10;

declare generic concat(a, b);

method concat(a:list, b:list) append(a, b);
method concat(a:string, b:string) string_append(a, b);

assert concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6];
assert concat("hello ", "world") == "hello world";

let old_add = `+`;
method `+`(a:string, b:string) concat(a, b);
assert "hello " + "world" == "hello world";
assert 1 + 2 == 3;
`+` = old_add;

module n(f, lf)
{ function f(a) a;
  function lf(a, b) if (a) b() else false };

assert n.f(10) == 10;
let x = 10;
n.lf(true, ^x = 300);
assert x == 300;
n.lf(false, ^x = 0);
assert x == 300;

let b = n;
assert b.f(20) == 20;
x = 10;
b.lf(true, ^x = 1);
assert x == 1;
b.lf(false, ^x = 0);
assert x == 1;

let f, lf = n.f, n.lf;
assert f(100) == 100;
x = 0;
lf(true, ^x = 1);
assert x == 1;
lf(false, ^x = 1);
assert x == 1;

record r(a, b where is_integer(b) && b > 100);
let a = r(a = "hi", b = 200);
assert r_a(a) == "hi";
assert r_b(a) == 200;
let x = false;
let y = false;
try r(a=1, b=100) catch (e) x = true finally y = true;
assert x && y;

let x = true;
try r_set_b(a, "ok")
catch (e) r_set_b(a, 200)
finally x = false;

assert r_b(a) == 200;
assert x == false;

let x = ?;
task(^{task_sleep(2); ?x = 100});
assert ?x == 100;

function ints(n) n::ints(n+1);
x = ints(0);
assert nth(10, x) == 10;

x = [1, 2, 3, 4];
assert (match(x) [10, a, 3, b] -> 1000 | [1, a, 3, b] -> a + b) == 6;
x = [10, 2, 3, 4];
assert (match(x) [10, a, 3, b] -> 1000 | [1, a, 3, b] -> a + b) == 1000;

assert (case(x) [1, 2, 5, 4] -> "ok") == false;
x = 5;
assert (case(x) [1, 2, 5, 4] -> "ok") == "ok";

record rec_a(x, y);
record rec_b(x, y, z);
x = rec_a(x = 100, y = 200);
y = rec_b(x = 1, y = 2, z = 3);

assert (match(x) rec_a(x, y) -> x * y | rec_b(x, y, z = 3) -> x + y) == 20000;
assert (match(y) rec_a(x, y) -> x * y | rec_b(x, y, z = 3) -> x + y) == 3;

y = rec_b(x = 1, y = 2, z = 4);

assert (match(y) rec_a(x, y) -> x * y | rec_b(x, y, z = 3) -> x + y | rec_b(x, y, z = 4) -> y * 2) == 4;

y = rec_b(x = 1, y = 3, z = 4);

assert (match(y) rec_a(x, y) -> x * y | rec_b(x, y = 2, z) -> x + z | rec_b(x, y, z = 4) -> y * 2) == 6;
assert (match([1, 2, 3]) rec_a(x, y) -> x * y | [x, y, z] -> x + y + z) == 6;
assert (match(x) rec_a(x, y) -> x * y | [x, y, z] -> x + y + z) == 20000;

x = #{!name:!nemo, !age:3};
assert (match(x) #{!name:n, !age:a} -> [n, a]) == [!nemo, 3];
assert (match(x) #{!age:a, !name:n} -> [n, a]) == [!nemo, 3];
x = [!name:!nemo, !age:3];
assert (match(x) [!name:n, !age:a] -> [n, a]) == [!nemo, 3];
assert (match(x) [!age:a, !name:n] -> [n, a] | _ -> false) == false;
assert (match(#{1:2, 3:[1, 2, 3, 4, 5]}) [1:a, 3:[1, b, 3, c, 5]] -> a * b * c | #{1:a, 3:[1, b, 3, c, 5]} -> a+b+c) == 8;
assert (match([1:2, 3:[1, 2, 3, 4, 5]]) [1:a, 3:[1, b, 3, c, 5]] -> a * b * c | #{1:a, 3:[1, b, 3, c, 5]} -> a+b+c) == 16;

function u(a, b) if (a) b() else false;
x = false;

assert u(false, ^100) == false;
assert u(true, ^100) == 100;
u(false, ^x = true);
assert x == false;
u(true, ^x = true);
assert x == true;

function run_add(i, x, b) i + x;
assert do_times(10, run_add, init = 0) == 45;
assert do_times(10, run_add, init = 0, from = 5) == 35;
assert do_times(10, run_add, init = 0, from = -5) == 30;
assert do_times(-10, run_add, init = 0, from = -5) == -35;
assert do_times(-10, run_add, init = 0, from = -50) == -1220;
assert do_times(10, ^(i, x, b) if (i == 5) b("ok") else i) == "ok";
assert do_times(0, run_add, init = 0, from = 9) == 45;

// harmonic series
let a = fold_left(^(i, sum) sum + 1.0/i, 0, range(1,2));
assert a == 1.5;

// list comprehensions
let s =[expt(x,2) | x <- range(0, 10)];
assert s == [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];
assert [x | x <- s where remainder(x, 2) == 0] == [0, 4, 16, 36, 64, 100];

let words = string_split("The quick brown fox jumps over the lazy dog");
words = [[string_upcase(w), string_downcase(w), string_length(w)] | w <- words];
assert words == [["THE", "the", 3], ["QUICK", "quick", 5], ["BROWN", "brown", 5], ["FOX", "fox", 3], ["JUMPS", "jumps", 5], ["OVER", "over", 4], ["THE", "the", 3], ["LAZY", "lazy", 4], ["DOG", "dog", 3]];

// partial application
function deriv(f, dx, x) (f(x+dx) - f(x))/dx;
let pf = partial(deriv, cos, 1.5);
assert pf(1e-10) == deriv(cos, 1.5, 1e-10);

// contracts for functions
function precheck(x, y) is_integer(x) && x > 10 && is_integer(y) && y > 0;

function a(x, y) where precheck(x, y) -> is_integer(%)
 if (x == 20) "ok"
 else x * y;
 
assert (try a(1, 2) catch(e) error_message(e)) == !precondition_failed;
assert a(11, 2) == 22;
assert (try a(20, 2) catch(e) error_message(e)) == !postcondition_failed;

disable_function_contracts();
assert (try a(1, 2) catch(e) error_message(e)) == 2;
assert a(11, 2) == 22;
assert (try a(20, 2) catch(e) error_message(e)) == "ok";
enable_function_contracts();

disable_asserts();
assert (try a(1, 2) catch(e) error_message(e)) <> !precondition_failed;
assert a(11, 2) <> 22;
assert (try a(20, 2) catch(e) error_message(e)) <> !postcondition_failed;
enable_asserts();

function b(x, y) where precheck(x, y)
 if (x == 20) "ok"
 else x * y;

assert (try b(1, 2) catch(e) error_message(e)) == !precondition_failed;
assert b(11, 2) == 22;
assert (try b(20, 2) catch(e) e) == "ok";

function is_palindrome(s)
{ let chars = string_to_list("abcdefghijklmnopqrstuvwxyz");

  function to_chars(s)
   list_to_string(filter(^(c) member(c, chars),
                  string_to_list(string_downcase(s))));

  function is_pal(s)
   let (len = string_length(s))
    if (len <= 1) true
    else s[0] == s[len-1] && is_pal(s[1:len-1]);

   is_pal(to_chars(s)) };

assert not(is_palindrome("abc"));
assert is_palindrome("a");
assert is_palindrome("aba");
assert is_palindrome("malayalam");
assert is_palindrome("");

function is_palindrome2(s) where is_string(s)
{ let chars = string_to_list("abcdefghijklmnopqrstuvwxyz");

  function to_chars(s)
   list_to_string(filter(^(c) member(c, chars),
                  string_to_list(string_downcase(s))));

  function is_pal(s)
   let (len = string_length(s))
    if (len <= 1) true
    else s[0] == s[len-1] && is_pal(s[1:len-1]);

   is_pal(to_chars(s)) };

assert not(is_palindrome2("abc"));
assert is_palindrome2("a");
assert is_palindrome2("aba");
assert is_palindrome2("malayalam");
assert is_palindrome2("");
assert try is_palindrome2(121) catch (e) error_message(e) == !precondition_failed;

function is_palindrome3(s) where is_string(s) -> is_boolean(%)
{ let chars = string_to_list("abcdefghijklmnopqrstuvwxyz");

  function to_chars(s)
   list_to_string(filter(^(c) member(c, chars),
                  string_to_list(string_downcase(s))));

  function is_pal(s)
   let (len = string_length(s))
    if (len <= 1) true
    else s[0] == s[len-1] && is_pal(s[1:len-1]);

   if (s == "") 1
   else is_pal(to_chars(s)) };

assert not(is_palindrome3("abc"));
assert is_palindrome3("a");
assert is_palindrome3("aba");
assert is_palindrome3("malayalam");
assert try is_palindrome3("") catch(e) error_message(e) == !postcondition_failed;
assert try is_palindrome3(121) catch (e) error_message(e) == !precondition_failed;

let t1 = [1, "two", 3];
let t2 = [t1, 3.25];
assert append(t1, t2)[3] == [1, "two", 3];
assert append(t1, t2)[2:5] == [3, [1, "two", 3], 3.25];