assert 1 + 2 == 3;
assert (1 + 2 <> 3) == false;
assert 1 + 2 * 5 == 11;
assert 1 + 2 <= 3;
assert 1 + 2 <= 3 && 4 * 3 == 12;
assert 1 + 2 > 3 || 4 * 3 == 12;

function recur(a)
  if (a > 0) recur(a - 1)
  else a;

assert recur(10) == 0;
assert recur(-10) == -10;

declare generic concat(a, b);

method concat(a:list, b:list) append(a, b);
method concat(a:string, b:string) string_append(a, b);

assert concat([1 2 3], [4 5 6]) == [1 2 3 4 5 6];
assert concat("hello " "world") == "hello world";

let old_add = `+`;
method `+`(a:string, b:string) concat(a, b);
assert "hello " + "world" == "hello world";
assert 1 + 2 == 3;
`+` = old_add;

namespace n;
function f(a) a;
macro m(a, b) if (a) b else false;
function lf(a, b) if (a) b() else false;
namespace;

assert n_f(10) == 10;
let x = 10;
n_m(true, {x = 200});
assert x == 200;
n_m(false, {x = 0});
assert x == 200;
x = 100;
n_lf(true, ^x = 300);
assert x == 300;
n_lf(false, ^x = 0);
assert x == 300;

use n as b;
assert b_f(20) == 20;
x = 10;
b_m(true, {x = 400});
assert x == 400;
b_m(false, {x = 0});
assert x == 400;
x = 0;
b_lf(true, ^x = 1);
assert x == 1;
b_lf(false, ^x = 0);
assert x == 1;

use n;
assert f(100) == 100;
x = 0;
m(true, {x = 1});
assert x == 1;
m(false, {x = 0});
assert x == 1;
x = 0;
lf(true, ^x = 1);
assert x == 1;
lf(false, ^x = 1);
assert x == 1;

record r(a, b where is_integer(b) && b > 100);
let a = r(a = "hi", b = 200);
assert r_a(a) == "hi";
assert r_b(a) == 200;
let x = false;
let y = false;
try r(a=1, b=100) catch (e) x = true finally y = true;
assert x && y;

let x = true;
try r_set_b(a, "ok")
catch (e) r_set_b(a, 200)
finally x = false;

assert r_b(a) == 200;
assert x == false;

let x = ?;
task({task_sleep(2); ?x = 100});
assert ?x == 100;

function ints(n) n::ints(n+1);
x = ints(0);
assert nth(10, x) == 10;

x = [1 2 3 4];
assert (match(x) [10, a, 3, b] -> 1000, [1 a 3 b] -> a + b) == 6;
x = [10 2 3 4];
assert (match(x) [10, a, 3, b] -> 1000, [1 a 3 b] -> a + b) == 1000;

assert (case(x) [1 2 5 4] -> "ok") == false;
x = 5;
assert (case(x) [1 2 5 4] -> "ok") == "ok";

record rec_a(x, y);
record rec_b(x, y, z);
x = rec_a(x = 100, y = 200);
y = rec_b(x = 1, y = 2, z = 3);

assert (match(x) rec_a(x, y) -> x * y, rec_b(x, y, z = 3) -> x + y) == 20000;
assert (match(y) rec_a(x, y) -> x * y, rec_b(x, y, z = 3) -> x + y) == 3;

y = rec_b(x = 1, y = 2, z = 4);

assert (match(y) rec_a(x, y) -> x * y, rec_b(x, y, z = 3) -> x + y, rec_b(x, y, z = 4) -> y * 2) == 4;

y = rec_b(x = 1, y = 3, z = 4);

assert (match(y) rec_a(x, y) -> x * y, rec_b(x, y = 2, z) -> x + z, rec_b(x, y, z = 4) -> y * 2) == 6;
assert (match([1 2 3]) rec_a(x, y) -> x * y, [x y z] -> x + y + z) == 6;
assert (match(x) rec_a(x, y) -> x * y, [x y z] -> x + y + z) == 20000;

x = #{!name:!nemo !age:3};
assert (match(x) #{!name:n !age:a} -> [n a]) == [!nemo 3];
assert (match(x) #{!age:a !name:n} -> [n a]) == [!nemo 3];
x = [!name:!nemo !age:3];
assert (match(x) [!name:n !age:a] -> [n a]) == [!nemo 3];
assert (match(x) [!age:a !name:n] -> [n a], _ -> false) == false;
assert (match(#{1:2 3:[1 2 3 4 5]}) [1:a 3:[1 b 3 c 5]] -> a * b * c, #{1:a 3:[1 b 3 c 5]} -> a+b+c) == 8;
assert (match([1:2 3:[1 2 3 4 5]]) [1:a 3:[1 b 3 c 5]] -> a * b * c, #{1:a 3:[1 b 3 c 5]} -> a+b+c) == 16;

function u(a, b) if (a) b() else false;
x = false;

assert u(false, ^100) == false;
assert u(true, ^100) == 100;
u(false, ^x = true);
assert x == false;
u(true, ^x = true);
assert x == true;

function run_add(i, x, b) i + x;
assert do_times(10, run_add, init = 0) == 45;
assert do_times(10, run_add, init = 0, from = 5) == 35;
assert do_times(10, run_add, init = 0, from = -5) == 30;
assert do_times(-10, run_add, init = 0, from = -5) == -35;
assert do_times(-10, run_add, init = 0, from = -50) == -1220;
assert do_times(10, ^(i, x, b) if (i == 5) b("ok") else i) == "ok";
assert do_times(0, run_add, init = 0, from = 9) == 45;

// harmonic series
let a = fold_left(^(i, sum) sum + 1.0/i, 0, range(1,2));
assert a == 1.5;

// list comprehensions
let s =[expt(x,2) | x <- range(0, 10)];
assert s == [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];
assert [x | x <- s where remainder(x, 2) == 0] == [0, 4, 16, 36, 64, 100];

let words = string_split("The quick brown fox jumps over the lazy dog");
words = [[string_upcase(w), string_downcase(w), string_length(w)] | w <- words];
assert words == [["THE", "the", 3], ["QUICK", "quick", 5], ["BROWN", "brown", 5], ["FOX", "fox", 3], ["JUMPS", "jumps", 5], ["OVER", "over", 4], ["THE", "the", 3], ["LAZY", "lazy", 4], ["DOG", "dog", 3]];

// partial application
function deriv(f dx x) (f(x+dx) - f(x))/dx;
let pf = partial(deriv, cos 1.5);
assert pf(1e-10) == deriv(cos, 1.5, 1e-10);
